# Java 基础知识

## 基本类型

- 字符串不是基本类型，而是引用类型

- 浮点型可能只是一个近似值，而不是一个精确值

- 数据范围与字节数不一定相关

- 浮点数默认类型是`float`，整型默认是`int`

- 对于类型`float`和`long`类型来说，后缀`F`和`L`不要丢弃

- 如果使用`byte`或是`short`类型的变量，右边不能超过左边的范围

- `byte/char/short`三种类型在运算时，会首先转换为`int`处理

  ```java
  char A = 'A';
  System.outPrintln(A + 1); // 输出 66，'A' 被当做二进制处理
  
  byte num1 = 40;
  byte num2 = 50;
  byte sum = num1 + num2; // 报错，提示为不能 int 转 byte
  int sum = num1 + num2; // 正确
  byte sum = (byte) (num1 + num2);
  ```

- 对于`byte/char/short`三种类型，如果右侧类型没有超过左边范围，编译器会为它们补上一个`(byte)(char)(short)`，即自动补上强制类型转换，如果超过，直接报错

- 给变量进行赋值的时候，如果右侧的表达式当中全是常量 ，没有任何变量，那么编译器建会直接将若干个常量表达式计算的结果赋予变量

  ```java
  short a = 5;
  short b = 8;
  short result = a + b; // 上文提到，报错
  short result = 5 + 8; // 正确
  ```


## 函数

- 函数重载与下列因素相关
  1. 参数个数不同
  2. 参数类型不同
  3. 参数的多类型顺序不同
- 函数重载与下列因素无关
  1. 与参数的名称无关
  2. 与方法的返回值类型无关

## 数组

- 数组的特点

  1. 数组是一种引用数据类型

  2. 数组当中的多个数据，类型必须统一
  3. 数组的长度在程序运行期间不可改变

- 数组的两种常见的初始化方式

  1. 动态初始化（指定长度）`int[] strArr = new int[2];`

  2. 静态初始化（指定内容）

     ```java
     int[] strArr = new int[] {5, 15, 25};
     // 省略写法
     int[] arrayA = { 5, 15, 25 };
     ```

- 直接打印数组名称，得到的是数组对应的内存地址哈希值

  ```java
  int[] array = { 10, 20, 30 };
  //输出 [I@75412c2f [ 表示数组，I 表示 int 类型，75412c2f 表示 16 进制
  System.out.println(array); 
  ```

- 使用动态初始化数组的时候，其中的元素将会拥有一个默认值。规则如下：

  - 如果是整数，默认为`0`
  - 如果是浮点类型，默认为`0.0`
  - 如果是字符类型，默认为`\u0000`
  - 如果是布尔类型，默认为`false`
  - 如果是引用类型，默认为`null`

  > 静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成了大括号当中的具体数值

- Java 的内存要划分成为 5 个部分

  - 栈`stack`：存放的都是方法中的局部变量，一旦超出作用域，立刻从栈内存中消失。方法的运行一定要在栈当中运行
  - 堆`Heep`：凡是`new`出来的东西，都在堆当中，堆内存里的东西都有一个地址值：16进制。堆内存里面的数据，都有默认值
  - 方法区`Method Area`：存储`.class`相关信息，包含方法的信息
  - 本地方法栈`Native Method Stack`：与操作系统相关
  - 寄存区`pc Register`：与 CPU 相关

- 数组的变量只是在栈中只是存一个地址值，通过这个地址值在堆中找变量的存储地址，也就是`new`之后的部分，所以直接打印数组就是地址值。索引也是地址值，会通过索引值到内存中找到对应地址并获取值
- 数组索引越界异常，当需要读取超过数组长度的索引时，会发生越界异常`ArrayIndexOutOfBoundsException`
- 空指针异常，也就是声明了变量但是没有进行初始化，它会被初始化为`null`，此时使用索引调用会产生空指针异常`NullPointerException`

## 类

- 成员变量如果没有赋值，会有默认值，而局部变量没有
- 当方法的局部变量和成员变量重名的时候，优先使用局部变量，此时可以使用`this`来访问成员变量
- 构造方法是专门用来创建对象的方法，当我们通过关键字`new`来创建对象时，其实就是在调用构造方法，有几个注意事项
  1. 构造方法的名称必须和所在类名称完全一样，大小写也是一样
  2. 构造方法不要写返回值类型，连`void`都不写
  3. 构造方法不能`return`一个具体的返回值
  4. 如果没有编写任何构造方法，那么编译器就会默认赠送一个构造方法，没有参数、方法什么事都不做
  5. 一旦编写了至少一个构造方法，编译器就不再赠送
  6. 构造方法也可以重载
- 导包
   - `import 包路径.类名称`
   - 如果需要使用的目标类和当前类在同一个包下，则可以省略导包语句不写
   - 只有`java.lang`包下的内容不需要导包，其他的包都需要
- 匿名对象就是只有右边的`new`对象，而没有左边的赋值语句。匿名对象只能使用一次
- 静态方法只能访问静态变量，不能使用`this`。因为在内存中是先有的静态内容，后有的非静态内容
- 在方法区中有独立的静态方法区，也就是和类在一起的，只和类有关系
- 静态代码块只会在第一次用到类时执行一次，典型用法就是一次性地对静态成员变量进行赋值
  ```java
  public class Person {
    static {
      System.println("静态代码执行")
    }
  }
  ```
### 继承
- 子类方法的返回值类型必须小于等于父类的返回值范围
- 子类方法的权限必须大于等于父类方法的权限修饰符`public > protect > (default) > private`
- 继承关系中，父子类构造方法的访问特点
  1. 子类构造方法有一个默认隐含的`super()`调用，所以会先调用父类的构造方法再调用子类
  2. 可以通过`super`关键字来子类构造调用父类重载构造
  3. `super`的父类构造调用，必须是子类构造方法的第一个语句，不能多次调用`super`
- `super`关键字在内存中会保存对父类的引用，在堆中，子类内容会包含一个父类内容
- Java 继承的三个特点
  1. 一个类的直接父类只能有一个
  2. Java 可以多级继承
  3. 一个父类可以有多个子类
- 抽象类的子类必须覆盖重写抽象类中的所有抽象方法，除非子类也是抽象类
- 代码当中体现多态性就是：父类引用指向子类对象，口诀：编译看左边，运行看右边
  1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找，子类不可以覆盖重写变量
  2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找
  ```java
  Fu obj = new Zi();
  System.out.println(obj.num); // 父类的 10
  obj.showNum(); // 子类没有覆盖重写，则返回 10
  obj.showNum(); // 子类如果覆盖重写，则返回 20
  obj.methodZi(); // 编译看左，这里编译会报错，因为 obj 是 Fu 类，Fu 类没有 methodZi 方法
  ```
- 对象的向上转型，其实就是多态写法。`父类名称 对象名 = new 子类名称();`，其实就是右侧创建一个子类对象，把它当做父类使用。向上转型一定是安全的。但一旦转为父类，就无法使用子类的特别方法
- 对象的向下转型，其实是一个*还原*的操作。`子类名称 对象名 = （子类名称）父类对象;`，将父类对象还原为子类对象
  ```java
  Animal animal = new Cat()
  Cat cat = (Cat) animal; // 本来是猫，还原为猫。必须保证本来创建的时候，就是猫，才能向下转型
  Dog dog = (Dog) animal: // 本来是猫，非要还原为狗，错误写法，编译不会报错，但是运行出现异常
  ```
- 使用`instanceof`进行类型判断，如何知道一个父类引用的对象，本来是什么子类
  ```java
  if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.watchHouse();
  }
  ```
### `final`关键字
  有四种用法，不过对于类和方法来说`abstract`和`final`不能同时使用
  1. 可以用来修饰一个类，`public final class 类名称`，当前这个类不能有任何子类
  2. 可以用来修饰一个方法，`修饰符 final 返回值类型 方法名称`当前这个方法就是最终方法，不能对它进行覆盖重写
  3. 可以用来修饰一个局部变量，一旦使用`final`关键字对局部变量进行修饰，就不能进行更改，只要有唯一一次赋值即可
  4. 可以用来修饰一个成员变量，也是不可变，但是要注意
    1. 由于有默认值，必须手动赋值
    2. 对于`final`的成员变量，要么直接赋值，要是使用构造方法赋值
- Java 中有四种权限修饰符：`public > protected > (default) > private`
  - 同一个类 yes yes yes yes
  - 同一个包 yes yes yes no
  - 不同包子类 yes yes no no
  - 不同包非子类 yes no no no
### 内部类
  分为
  1. 成员内部类，调用它有两种方法
    - 间接方式：在外部类的方法中，使用内部类；然后`main`只是调用外部类的方法
    - 直接方式：类名称 对象名 = new 类名称();外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
      ```java
      Body.Heart heart = new Body().new Heart();
      ```
  2. 局部内部类（包含匿名内部类），如果一个类定义在一个方法内部，那么就是局部内部类。同时不能进行
- 内部类的同名对象访问，通过`this`访问，如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
- 局部内部类如果希望访问所在方法的局部变量，那么这个局部变量必须是`有效 final 的`，可以直接给它加上`final`或是保证它事实不变。原因：
  1. new 出来的对象是在堆内存中
  2. 局部变量是跟着方法走的，在栈内存当中
  3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失
  4. new 出来的对象会在堆中一直存在，知道垃圾回收为止
### 匿名类，
  如果接口的实现类（或是弗雷德子类）只需要使用唯一的一次，就可以省略这个类的定义
  - 匿名内部类的定义格式`接口名称 对象名 = new 接口名称() { 覆盖重写所有抽象方法 }`
  - 注意事项：
    1. 匿名内部类，在创建对象的时候，只能使用唯一一次。如果希望多次 new 的话，只能创建一个类
    2. 在使用匿名内部类创建了匿名对象的时候只能调用唯一一次
    3. 匿名内部类是省略了`实现类/子类名称`，但匿名对象是省略了`对象名称`
### 包装类
基本数据类型的数据使用起来方便但是没有对应的方法操作这些数据
- 包装对象
  - `Integer I = new Integer(1)`      
  - `Integer I = Integer.valueOf(4)`
- 拆箱
  - `int num = i.intValue()`
- 自动装箱和拆箱
  - `Integer I = 1`
  - `I = I + 1`
除了`Character`类之外，所有包装类都会有`parseXxx`静态方法将字符串类型转换为对应的基本类型

## ArrayList

- 可以装载一个泛型，泛型只能是引用类型，而不能是基本类型。从`JDK1.7+`开始，尖括号可以不写内容，但是尖括号不能省略。但是左边的赋值语句必须写
- 如果想向集合中存储基本类型数据，必须使用基本类型的包装类，包装类都位于`java.lang`包下，增删数组速度慢是因为每次增删都会创建一个新数组改变长度后复制原数组并进行增删
- 从`JDK1.5+`开始，支持自动装箱（基本类型-->引用类型），自动拆箱（引用类型-->基本类型）
- 对于`ArrayList`来说，直接打印的不是地址值，而是内容，如果内容为空，则为`[]`
- `public boolean add(E e)`向集合中添加元素，参数的类型和泛型一致。返回值表示添加动作是否成功。对于`ArrayList`来说，`add`操作一定是成功的，对于其他集合不一定是成功的,
- `public E get(int index)`向集合中获取元素，参数是索引值，返回值就是对应位置的元素
- `public E remove(int index)`删除元素
- `public int size()`获取集合的尺寸长度

## String
- Java 中的所有字面量值都作为`String`类的实例实现
- 字符串的特点
  1. 字符串是常量，创建之后不能更改
  2. 字符串是可以共享使用的
  3. 字符串效果上是`char[]`字符数组，但底层原理是`byte[]`字节数组
- 创建字符串的 3 + 1 种方式
  1. `public String()`创建一个空白字符串，不包含任何内容
  2. `public String(char[] array)`根据字符数组来创建字符串，但底层依然会转换成`byte[]`进行保存
  3. `public String(byte[] array)`根据字节数组来创建字符串
  4. 直接用双引号创建
- `String`的常量池，程序中直接写上的双引号字符串，就在字符串常量池中。字符串常量池是在堆当中的，其中保存的就是字符串字节数组的地址值。直接创建的字符串会在常量池中重复利用同一个地址值
  ```java
  String str1 = 'abc';
  String str2 = 'abc';

  char[] charArray = char[] {"a", "b", "c"};
  String str3 = new String(charArray);

  System.out.println(str1 == str2); // true
  System.out.println(str1 == str3); // false
  System.out.println(str2 == str3); // false
  ```
- 字符串的比较相关方法
  1. `public boolean equals(Object obj)`参数可以是任何对象，只有参数是一个字符串且内容相同才会给`true`，不管创建方法是什么。如果比较常量和变量，推荐把常量写在前面，避免变量为`null`
  2. `public boolean equalsIgnoreCase(String str)`忽略大小写进行内容比较
- 字符串获取的相关方法
  1. `public int length()`获取字符串当中含有的字符个数
  2. `public String concat(String str)`将当前字符串和参数字符串拼接成为返回值新的字符串
  3. `public char charAt(int index)`获取指定位置的单个字符
  4. `public int indexOf(String str)`查找参数字符串在本字符串首次出现的索引位置
- 字符串的截取方法
  1. `public String substring(int index)`截取从参数位置一直到字符串尾，返回新字符串
  2. `public String substring(int begin, int end)`截取从`begin`到`end`位置中间的字符串，`[begin, end)`也就是包含左边，不包含右边
- 字符串的转换方法
  1. `public char[] toCharArray()`将当前字符串拆分成为字符数组作为返回值
  2. `public byte[] getBytes()`获取当前字符串的底层字节数据
  3. `public String replace(CharSequence oldString, CharSequence newString)`将所有出现的老字符串替换为老字符串，返回新字符串。`CharSequence`是一个接口，表示接受字符串类型
- 字符串的分割方法
  1. `public String[] split(String regex)`按照参数规则将字符串切割成为若干部分，注意参数是一个正则表达式。

## 接口
- 接口就是多个类的公共规范，并且是一种引用类型，最重要的内容就是其中的抽象方法。如果是 Java 7 接口中可以包含的内容有
  1. 常量
  2. 抽象方法
  如果是 Java 8 可以包含的内容有
  3. 默认方法
  4. 静态方法
  如果是 Java 9 可以包含的内容有
  5. 私有方法
- 在任何版本的 Java 中间，接口都能定义抽象方法，接口中的抽象方法，必须是两个固定的关键字`public`和`abstract`，这两个关键字可以选择性地省略。
  `public abstract 返回值类型 方法名称（参数列表）`
- 接口使用步骤
  1. 接口不能直接使用，必须用一个实现类来实现接口
  2. 接口的实现类必须覆盖重写接口中的所有抽象方法
  3. 创建实现类的对象，进行使用
  > 如果实现类没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类
- 从 Java 8 开始，接口里允许定义默认方法，它可以解决接口升级问题
  `public default 返回值类型 方法名称（参数列表）{ 方法体 }`
- 从 Java 8 开始，接口中允许定义静态方法，不能通过接口实现类中的对象来调用接口中的静态方法。需要通过接口名称直接调用静态方法
  `public static 返回值类型 方法名称（参数列表）{ 方法体 }`
- 从 Java 9 开始，接口中允许定义私有方法
  1. 普通方法，为了解决多个默认方法之间重复代码问题
  `private 返回值类型 方法名称（参数列表）{ 方法体 }`
  2. 静态私有方法，为了解决多个默认静态方法之间的重复代码问题
  `private static 返回值类型 方法名称（参数列表）{ 方法体 }`
- 接口当中可以定义`成员变量`，但必须把`public`，`static`，`final`三个关键字进行修饰，当然也是可以省略。一旦赋值，不可修改。使用`final`就是表示不可一旦赋值，不可修改。
  `public static final 数据类型 常量名称 = 数据值`
- 常量推荐使用大写和下划线进行命名
- 当继承多个接口时，需要注意
  1. 接口是没有静态代码块或是构造方法的
  2. 如果存在重复的抽象方法，只需要重写或是覆盖一次即可
  3. 如果存在重复的默认方法，实现类就必须对重复的默认方法进行重写
  4. 如果父类的方法和接口中的方法产生了冲突，优先使用父类中的方法
- 接口继承接口时，如果默认方法重复，子接口需要重写，同时必须加上`default`关键字
- 接口可以作为成员变量类型，方法的参数或返回值

## 常见类
- `Objects`注意不是`Object`，它是一个工具类。当对象为 null 时候，调用`equals`方法会报错，所以可使用`Objects`的`equals`方法，会调用第一个参数的`equals`方法和第二个参数进行比较

### Collections
它是集合工具类，用于对集合进行操作，部分方法如下
- `public static <T> boolean addAll(Collections<T> c, T ... elements())`往集合中添加元素
- `public static void shuffle(List<?> list)`打乱集合顺序
- `public static <T> void sort(List<T> list)`将集合元素按默认顺序排序，但是注意被排序的集合里的元素必须实现`Comparable`，接口中的`compareTo`方法定义排序规则
- `public static <T> void sort(List<T> list, Comparator<? super T>)`将集合中元素按指定规则排序

## 常见接口
集合是 java 提供的一种容器，可以用来储存多种数据
集合按照其存储结构可以分为两大类，分别是单列集合`java.util.collection`和双列集合`java.util.map`

### Collection
单列集合类的根接口，它有两个重要的子接口，分别是`java.util.List`和`java.util.Set`。其中，`List`的特点是元素有序、元素可重复。`Set`的特点是元素无序，且不可重复。`List`接口的主要实现类有`java.util.ArrayList`和`java.util.LinkedList`，`Set`接口的主要实现类有`java.util.HashSet`和`java.util.TreeSet`
`Collection`就是所有单列集合中共用的方法
- `ArrayList`底层是数组实现的，查询快，增删慢
- `LinkedList`底层是链表实现的，查询慢，增删快
- `HashSet`底层是哈希表 + 红黑树实现的，无索引、不可以存储重复元素、存储无序
- `LinkedHashSet`底层是哈希表 + 链表实现的，无索引、不可以存储重复元素、可以保证存储顺序
- `TreeSet`底层是二叉树实现，一般用于排序
集合常用方法
- `boolean add(E, e)`向集合中添加元素
- `boolean remove(E, e)`删除集合中某个元素
- `void clear()`清空所有元素
- `boolean contains(E e)`判断集合中是否包含某个元素
- `boolean isEmpty()`判断集合是否为空
- `int size()`获取集合长度
- `Object[] toArray()`转换为数组，转换完成后可使用 for 循环遍历
- `Iterator<E> iterator()`返回在此 collection 元素上进行迭代的迭代器
常用功能

### List
`List`接口继承`Collection`接口，它是一个有序的集合，此接口用户可对列表中每个元素的插入位置进行精确地控制，允许重复元素。操作索引时，一定要防止索引越界异常
其实就是`ArrayList`，操作索引一定要防止索引越界异常
- `public void add(int index, E element)将指定元素添加到指定位置
- `public E get(int index)获取指定位置的元素
- `public E remove(int index)移除指定位置元素
- `public E set(int index, E element)用指定元素替换集合中指定位置元素，返回值的更新前元素

### LinkedList
`LinkedList`集合数据存储的是链表结构。方便元素添加删除的集合，它包含了大量操作首尾元素的方法。当使用`LinkedList`集合的特有方法时，不能使用多态
- `public void addFirst(E e)`将指定元素插入到列表的开头
- `public void addLast(E e)`将指定元素插入到列表的结尾
- `public E getLast()`获取最后一个元素
- `public E getFirst()`获取第一个元素
- `public E removeLast()`移除最后一个元素并返回
- `public E removeFirst()`移除第一个元素并返回
- `public E pop()`等同于`removeLast()`
- `public void push(E e)`将元素推入此列表所表示的堆栈
- `public boolean isEmpty()`等同于`addLast()`

### Vector
同步的集合，它的大小可以鞥剧需要增大或缩小，以适应创建`Vector`后进行添加或移除项的操作，使用比较少

### Set
`Set`接口继承自`Collection`接口，它不包含重复元素

### HashSet
此类继承`Set`接口
1. 它由一个哈希表(一个 HashMap 实例)支持，查询速度非常快
2. 它不保证`Set`的迭代顺序
3. 是一个无序的集合，存储元素和取出元素的顺序可能不一致
4. 没有索引，没有带索引的方法，不能使用简单的 for 循环遍历
哈希值是一个十进制的整数，由系统随机给出，其实就是对象的地址值，但是一个逻辑地址，不是数据实际存储的地址
- `int hashCode()`可以获取对象的哈希值，该方法底层调用的是本地操作系统的方法
- `String`重写了`Object`的`HashCode`，如果字符串相同则它们的`HashCode`值会相等
哈希表是`HashSet`集合存储数据的结构
- jdk1.8 之前，哈希表 = 数组 + 链表，jdk1.8 之后，哈希表 = 数组 + 链表 或是 哈希表 = 数组 + 红黑树(当集合长度大于 8) ，就是速度快
它存储数据到集合中，先计算元素的哈希值，如果哈希值相同则存储到同一个地方
当两个元素不同但是哈希值相同，就称为哈希冲突
`HashSet`如何避免元素重复
在调用`add`方法时，会先调用元素的`hashCode`方法比较，如果出现哈希冲突就会调用`equals`方法比较，判断元素是否重复。但如果 hash 值相同会存到同一地址
所以`HashSet`集合进行自定义元素存储时必须实现`hashCode`和`equals`方法

### LinkedHashSet
具有可预知迭代顺序的`Set`接口的哈希表和链接列表实现，底层是 哈希表 + 链表/红黑树 + 链表 多了一个链表用于记录元素存储顺序

### Iteration
`Iteration`用于迭代访问(遍历)`Collection`中的元素，因此它也被称为迭代器
迭代即在取元素之前判断集合中是否有元素，如果有，就把这个元素取出，继续进行判断，如此往复，直到把所有元素全部取出
获取迭代器的实现类对象，并且会把指针(索引)指向集合的`-1`索引，取出下一个元素后，会把指针后移一位
想要遍历`Collection`集合，那么就需要获取该集合迭代器来完成迭代操作
- `public Iteration iterator()`获取集合对应的迭代器，用来遍历元素
迭代器常用接口如下
- `public E next()`返回迭代的下一个元素
- `public boolean hasNext()`如果仍有元素可以迭代，返回 true
迭代器使用步骤
1. 使用集合中的`iteration`方法获取迭代器
2. 使用`hasNext`方法判断是否还有下一个元素
3. 会用`next`取出下一个元素，如果没有元素会抛出`NoSuchElementException`异常
```java
while(it.hasNext()) {
  it.next();
}
```
JDK1.5 之后有一个高级 for循环，专门用来遍历数组和集合。它的内部原理其实就是个`Iterator`迭代器，所以在遍历过程中，不能对集合进行增删操作
```java
for (元素的数据类型 变量：只能是 Collection集合 or 数组) { // do something }
```

### Map
`Map<K, V>`中`K`为此映射所维护的键类型，`V`为映射值的类型。它是将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值
`Map`集合保证`key`是唯一的，作为`key`的元素，必须冲洗`hashCode`方法和`equals`方法，以保证`key`唯一
此接口完全取代`Dictionary`类，后者是一个抽象类
常用方法
- `public V put(K key, V value);`把指定的键和指定的值加入到`Map`集合中，`key`不重复的话，返回值是null，`key`重复的时候，会返回被替换的 value
- `public V remove(Object key);`把指定的键所对应的键值对元素在`Map`集合中删除，返回被删除元素的值，`key`不存在，返回 null，存在返回删除的 value
- `public V get(Object key);`根据指定的键，在 Map 集合中获取对应的值，`key`值操作如上
- `boolean containskey(Object key);`判断集合中是否包含指定的键
- `public Set<K> keySet();`获取 Map 集合中所有的键，存储到 Set 集合中，可通过这个方法来遍历`Set`之后找到对应键的值
- `public Set<Map.Entry<k, v>> entrySet()`获取到 Map 集合中所有的键值对对象的集合，返回映射的`collection`视图，只能通过此视图的迭代器来实现
在`Map`接口中有一个内部接口`Entry`，当`Map`集合一创建，那么就会在`Map`集合中创建一个`Entry`对象，用来记录键与值，它有两个方法
- `getKey()`获取键
- `getValue()`获取值

### HashMap
基于哈希表的`Map`接口的实现。此实现提供所有可选的映射操作，并允许使用`null`值和`null`键。它不保证映射的顺序
它的特性和`HashSet`一致

### LinkedHashMap
基于哈希表和链表实现，具有可预知的迭代顺序。
它的特性和`LinkedHashSet`一致

### HashTable
此类实现一个哈希表，此哈希表将键映射到相应的值。任何非 null 对象都可以作为键或值，但它是同步的，是一个线程安全的集合，速度慢
`HashTable`和`Vector`集合一样，在 jdk1.2 之后被更先进的`HashMap`集合取代了，但它的子类`Properties`依然活跃在历史舞台，它是唯一一个和`IO`流相结合的集合

### `of`方法
`List`，`Set`和`Map`接口都增加了一个静态方法`of`，可以给集合一次性添加多个元素。使用前提是当集合中存储的元素的个数已经确定了，不在改变时使用
注意
1. `of`方法只适用于`List`接口，`Set`接口，`Map`接口，不适用于接口的实现类
2. `of`方法的返回值是一个不能改变的集合，集合不能再使用`add`，`put`方法添加元素，会抛出异常
3. `Map`和`Set`接口调用`of`方法的时候，参数不能有重复的元素
