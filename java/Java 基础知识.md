# Java 基础知识

## 基本类型

- 字符串不是基本类型，而是引用类型

- 浮点型可能只是一个近似值，而不是一个精确值

- 数据范围与字节数不一定相关

- 浮点数默认类型是`float`，整型默认是`int`

- 对于类型`float`和`long`类型来说，后缀`F`和`L`不要丢弃

- 如果使用`byte`或是`short`类型的变量，右边不能超过左边的范围

- `byte/char/short`三种类型在运算时，会首先转换为`int`处理

  ```java
  char A = 'A';
  System.outPrintln(A + 1); // 输出 66，'A' 被当做二进制处理
  
  byte num1 = 40;
  byte num2 = 50;
  byte sum = num1 + num2; // 报错，提示为不能 int 转 byte
  int sum = num1 + num2; // 正确
  byte sum = (byte) (num1 + num2);
  ```

- 对于`byte/char/short`三种类型，如果右侧类型没有超过左边范围，编译器会为它们补上一个`(byte)(char)(short)`，即自动补上强制类型转换，如果超过，直接报错

- 给变量进行赋值的时候，如果右侧的表达式当中全是常量 ，没有任何变量，那么编译器建会直接将若干个常量表达式计算的结果赋予变量

  ```java
  short a = 5;
  short b = 8;
  short result = a + b; // 上文提到，报错
  short result = 5 + 8; // 正确
  ```


## 函数

- 函数重载与下列因素相关
  1. 参数个数不同
  2. 参数类型不同
  3. 参数的多类型顺序不同
- 函数重载与下列因素无关
  1. 与参数的名称无关
  2. 与方法的返回值类型无关

## 数组

- 数组的特点

  1. 数组是一种引用数据类型

  2. 数组当中的多个数据，类型必须统一
  3. 数组的长度在程序运行期间不可改变

- 数组的两种常见的初始化方式

  1. 动态初始化（指定长度）`int[] strArr = new int[2];`

  2. 静态初始化（指定内容）

     ```java
     int[] strArr = new int[] {5, 15, 25};
     // 省略写法
     int[] arrayA = { 5, 15, 25 };
     ```

- 直接打印数组名称，得到的是数组对应的内存地址哈希值

  ```java
  int[] array = { 10, 20, 30 };
  //输出 [I@75412c2f [ 表示数组，I 表示 int 类型，75412c2f 表示 16 进制
  System.out.println(array); 
  ```

- 使用动态初始化数组的时候，其中的元素将会拥有一个默认值。规则如下：

  - 如果是整数，默认为`0`
  - 如果是浮点类型，默认为`0.0`
  - 如果是字符类型，默认为`\u0000`
  - 如果是布尔类型，默认为`false`
  - 如果是引用类型，默认为`null`

  > 静态初始化其实也有默认值的过程，只不过系统自动马上将默认值替换成了大括号当中的具体数值

- Java 的内存要划分成为 5 个部分

  - 栈`stack`：存放的都是方法中的局部变量，一旦超出作用域，立刻从栈内存中消失。方法的运行一定要在栈当中运行
  - 堆`Heep`：凡是`new`出来的东西，都在堆当中，堆内存里的东西都有一个地址值：16进制。堆内存里面的数据，都有默认值
  - 方法区`Method Area`：存储`.class`相关信息，包含方法的信息
  - 本地方法栈`Native Method Stack`：与操作系统相关
  - 寄存区`pc Register`：与 CPU 相关

- 数组的变量只是在栈中只是存一个地址值，通过这个地址值在堆中找变量的存储地址，也就是`new`之后的部分，所以直接打印数组就是地址值。索引也是地址值，会通过索引值到内存中找到对应地址并获取值
- 数组索引越界异常，当需要读取超过数组长度的索引时，会发生越界异常`ArrayIndexOutOfBoundsException`
- 空指针异常，也就是声明了变量但是没有进行初始化，它会被初始化为`null`，此时使用索引调用会产生空指针异常`NullPointerException`

## 类

- 成员变量如果没有赋值，会有默认值，而局部变量没有
- 当方法的局部变量和成员变量重名的时候，优先使用局部变量，此时可以使用`this`来访问成员变量
- 构造方法是专门用来创建对象的方法，当我们通过关键字`new`来创建对象时，其实就是在调用构造方法，有几个注意事项
  1. 构造方法的名称必须和所在类名称完全一样，大小写也是一样
  2. 构造方法不要写返回值类型，连`void`都不写
  3. 构造方法不能`return`一个具体的返回值
  4. 如果没有编写任何构造方法，那么编译器就会默认赠送一个构造方法，没有参数、方法什么事都不做
  5. 一旦编写了至少一个构造方法，编译器就不再赠送
  6. 构造方法也可以重载
- 导包
   - `import 包路径.类名称`
   - 如果需要使用的目标类和当前类在同一个包下，则可以省略导包语句不写
   - 只有`java.lang`包下的内容不需要导包，其他的包都需要
- 匿名对象就是只有右边的`new`对象，而没有左边的赋值语句。匿名对象只能使用一次
- 静态方法只能访问静态变量，不能使用`this`。因为在内存中是先有的静态内容，后有的非静态内容
- 在方法区中有独立的静态方法区，也就是和类在一起的，只和类有关系
- 静态代码块只会在第一次用到类时执行一次，典型用法就是一次性地对静态成员变量进行赋值
  ```java
  public class Person {
    static {
      System.println("静态代码执行")
    }
  }
  ```
### 继承
- 子类方法的返回值类型必须小于等于父类的返回值范围
- 子类方法的权限必须大于等于父类方法的权限修饰符`public > protect > (default) > private`
- 继承关系中，父子类构造方法的访问特点
  1. 子类构造方法有一个默认隐含的`super()`调用，所以会先调用父类的构造方法再调用子类
  2. 可以通过`super`关键字来子类构造调用父类重载构造
  3. `super`的父类构造调用，必须是子类构造方法的第一个语句，不能多次调用`super`
- `super`关键字在内存中会保存对父类的引用，在堆中，子类内容会包含一个父类内容
- Java 继承的三个特点
  1. 一个类的直接父类只能有一个
  2. Java 可以多级继承
  3. 一个父类可以有多个子类
- 抽象类的子类必须覆盖重写抽象类中的所有抽象方法，除非子类也是抽象类
- 代码当中体现多态性就是：父类引用指向子类对象，口诀：编译看左边，运行看右边
  1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找，子类不可以覆盖重写变量
  2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找
  ```java
  Fu obj = new Zi();
  System.out.println(obj.num); // 父类的 10
  obj.showNum(); // 子类没有覆盖重写，则返回 10
  obj.showNum(); // 子类如果覆盖重写，则返回 20
  obj.methodZi(); // 编译看左，这里编译会报错，因为 obj 是 Fu 类，Fu 类没有 methodZi 方法
  ```
- 对象的向上转型，其实就是多态写法。`父类名称 对象名 = new 子类名称();`，其实就是右侧创建一个子类对象，把它当做父类使用。向上转型一定是安全的。但一旦转为父类，就无法使用子类的特别方法
- 对象的向下转型，其实是一个*还原*的操作。`子类名称 对象名 = （子类名称）父类对象;`，将父类对象还原为子类对象
  ```java
  Animal animal = new Cat()
  Cat cat = (Cat) animal; // 本来是猫，还原为猫。必须保证本来创建的时候，就是猫，才能向下转型
  Dog dog = (Dog) animal: // 本来是猫，非要还原为狗，错误写法，编译不会报错，但是运行出现异常
  ```
- 使用`instanceof`进行类型判断，如何知道一个父类引用的对象，本来是什么子类
  ```java
  if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.watchHouse();
  }
  ```
### `final`关键字
  有四种用法，不过对于类和方法来说`abstract`和`final`不能同时使用
  1. 可以用来修饰一个类，`public final class 类名称`，当前这个类不能有任何子类
  2. 可以用来修饰一个方法，`修饰符 final 返回值类型 方法名称`当前这个方法就是最终方法，不能对它进行覆盖重写
  3. 可以用来修饰一个局部变量，一旦使用`final`关键字对局部变量进行修饰，就不能进行更改，只要有唯一一次赋值即可
  4. 可以用来修饰一个成员变量，也是不可变，但是要注意
    1. 由于有默认值，必须手动赋值
    2. 对于`final`的成员变量，要么直接赋值，要是使用构造方法赋值
- Java 中有四种权限修饰符：`public > protected > (default) > private`
  - 同一个类 yes yes yes yes
  - 同一个包 yes yes yes no
  - 不同包子类 yes yes no no
  - 不同包非子类 yes no no no
### 内部类
  分为
  1. 成员内部类，调用它有两种方法
    - 间接方式：在外部类的方法中，使用内部类；然后`main`只是调用外部类的方法
    - 直接方式：类名称 对象名 = new 类名称();外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
      ```java
      Body.Heart heart = new Body().new Heart();
      ```
  2. 局部内部类（包含匿名内部类），如果一个类定义在一个方法内部，那么就是局部内部类。同时不能进行
- 内部类的同名对象访问，通过`this`访问，如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
- 局部内部类如果希望访问所在方法的局部变量，那么这个局部变量必须是`有效 final 的`，可以直接给它加上`final`或是保证它事实不变。原因：
  1. new 出来的对象是在堆内存中
  2. 局部变量是跟着方法走的，在栈内存当中
  3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失
  4. new 出来的对象会在堆中一直存在，知道垃圾回收为止
### 匿名类，
  如果接口的实现类（或是弗雷德子类）只需要使用唯一的一次，就可以省略这个类的定义
  - 匿名内部类的定义格式`接口名称 对象名 = new 接口名称() { 覆盖重写所有抽象方法 }`
  - 注意事项：
    1. 匿名内部类，在创建对象的时候，只能使用唯一一次。如果希望多次 new 的话，只能创建一个类
    2. 在使用匿名内部类创建了匿名对象的时候只能调用唯一一次
    3. 匿名内部类是省略了`实现类/子类名称`，但匿名对象是省略了`对象名称`


## ArrayList

- 可以装载一个泛型，泛型只能是引用类型，而不能是基本类型。从`JDK1.7+`开始，尖括号可以不写内容，但是尖括号不能省略。但是左边的赋值语句必须写
- 如果想向集合中存储基本类型数据，必须使用基本类型的包装类，包装类都位于`java.lang`包下
- 从`JDK1.5+`开始，支持自动装箱（基本类型-->引用类型），自动拆箱（引用类型-->基本类型）
- 对于`ArrayList`来说，直接打印的不是地址值，而是内容，如果内容为空，则为`[]`
- `public boolean add(E e)`向集合中添加元素，参数的类型和泛型一致。返回值表示添加动作是否成功。对于`ArrayList`来说，`add`操作一定是成功的，对于其他集合不一定是成功的
- `public E get(int index)`向集合中获取元素，参数是索引值，返回值就是对应位置的元素
- `public E remove(int index)`删除元素
- `public int size()`获取集合的尺寸长度

## String
- Java 中的所有字面量值都作为`String`类的实例实现
- 字符串的特点
  1. 字符串是常量，创建之后不能更改
  2. 字符串是可以共享使用的
  3. 字符串效果上是`char[]`字符数组，但底层原理是`byte[]`字节数组
- 创建字符串的 3 + 1 种方式
  1. `public String()`创建一个空白字符串，不包含任何内容
  2. `public String(char[] array)`根据字符数组来创建字符串，但底层依然会转换成`byte[]`进行保存
  3. `public String(byte[] array)`根据字节数组来创建字符串
  4. 直接用双引号创建
- `String`的常量池，程序中直接写上的双引号字符串，就在字符串常量池中。字符串常量池是在堆当中的，其中保存的就是字符串字节数组的地址值。直接创建的字符串会在常量池中重复利用同一个地址值
  ```java
  String str1 = 'abc';
  String str2 = 'abc';

  char[] charArray = char[] {"a", "b", "c"};
  String str3 = new String(charArray);

  System.out.println(str1 == str2); // true
  System.out.println(str1 == str3); // false
  System.out.println(str2 == str3); // false
  ```
- 字符串的比较相关方法
  1. `public boolean equals(Object obj)`参数可以是任何对象，只有参数是一个字符串且内容相同才会给`true`，不管创建方法是什么。如果比较常量和变量，推荐把常量写在前面，避免变量为`null`
  2. `public boolean equalsIgnoreCase(String str)`忽略大小写进行内容比较
- 字符串获取的相关方法
  1. `public int length()`获取字符串当中含有的字符个数
  2. `public String concat(String str)`将当前字符串和参数字符串拼接成为返回值新的字符串
  3. `public char charAt(int index)`获取指定位置的单个字符
  4. `public int indexOf(String str)`查找参数字符串在本字符串首次出现的索引位置
- 字符串的截取方法
  1. `public String substring(int index)`截取从参数位置一直到字符串尾，返回新字符串
  2. `public String substring(int begin, int end)`截取从`begin`到`end`位置中间的字符串，`[begin, end)`也就是包含左边，不包含右边
- 字符串的转换方法
  1. `public char[] toCharArray()`将当前字符串拆分成为字符数组作为返回值
  2. `public byte[] getBytes()`获取当前字符串的底层字节数据
  3. `public String replace(CharSequence oldString, CharSequence newString)`将所有出现的老字符串替换为老字符串，返回新字符串。`CharSequence`是一个接口，表示接受字符串类型
- 字符串的分割方法
  1. `public String[] split(String regex)`按照参数规则将字符串切割成为若干部分，注意参数是一个正则表达式。

## 接口
- 接口就是多个类的公共规范，并且是一种引用类型，最重要的内容就是其中的抽象方法。如果是 Java 7 接口中可以包含的内容有
  1. 常量
  2. 抽象方法
  如果是 Java 8 可以包含的内容有
  3. 默认方法
  4. 静态方法
  如果是 Java 9 可以包含的内容有
  5. 私有方法
- 在任何版本的 Java 中间，接口都能定义抽象方法，接口中的抽象方法，必须是两个固定的关键字`public`和`abstract`，这两个关键字可以选择性地省略。
  `public abstract 返回值类型 方法名称（参数列表）`
- 接口使用步骤
  1. 接口不能直接使用，必须用一个实现类来实现接口
  2. 接口的实现类必须覆盖重写接口中的所有抽象方法
  3. 创建实现类的对象，进行使用
  > 如果实现类没有覆盖重写接口中的所有抽象方法，那么这个实现类自己就必须是抽象类
- 从 Java 8 开始，接口里允许定义默认方法，它可以解决接口升级问题
  `public default 返回值类型 方法名称（参数列表）{ 方法体 }`
- 从 Java 8 开始，接口中允许定义静态方法，不能通过接口实现类中的对象来调用接口中的静态方法。需要通过接口名称直接调用静态方法
  `public static 返回值类型 方法名称（参数列表）{ 方法体 }`
- 从 Java 9 开始，接口中允许定义私有方法
  1. 普通方法，为了解决多个默认方法之间重复代码问题
  `private 返回值类型 方法名称（参数列表）{ 方法体 }`
  2. 静态私有方法，为了解决多个默认静态方法之间的重复代码问题
  `private static 返回值类型 方法名称（参数列表）{ 方法体 }`
- 接口当中可以定义`成员变量`，但必须把`public`，`static`，`final`三个关键字进行修饰，当然也是可以省略。一旦赋值，不可修改。使用`final`就是表示不可一旦赋值，不可修改。
  `public static final 数据类型 常量名称 = 数据值`
- 常量推荐使用大写和下划线进行命名
- 当继承多个接口时，需要注意
  1. 接口是没有静态代码块或是构造方法的
  2. 如果存在重复的抽象方法，只需要重写或是覆盖一次即可
  3. 如果存在重复的默认方法，实现类就必须对重复的默认方法进行重写
  4. 如果父类的方法和接口中的方法产生了冲突，优先使用父类中的方法
- 接口继承接口时，如果默认方法重复，子接口需要重写，同时必须加上`default`关键字
- 接口可以作为成员变量类型，方法的参数或返回值

## 常见类
- `Objects`注意不是`Object`，它是一个工具类。当对象为 null 时候，调用`equals`方法会报错，所以可使用`Objects`的`equals`方法，会调用第一个参数的`equals`方法和第二个参数进行比较
- 
