## 基本概念

> 重构(n.)是对软件内部的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

> 重构(v.)是使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

### 何为重构

* 重构改进软件的设计

  如果没有重构，程序的内部设计会组件腐败变质，经常性的重构有助于代码维持自己该有的形态。

* 重构使软件更容易理解

  编程的核心在于“准确的说出我想说什么”，然而你的源码还有其他读者(当然我觉得大部分时候都是未来的自己)，他才是最重要的，所以很多时候代码要**考虑给别人看**。

* 重构帮助找到 bug

  我没有盯着一大段代码就能找出 bug 的能力，此时如果对代码进行重构，就能深入代码的所作所为，重构能够帮我更有效地写出健壮的代码。

* 重构提高编程速度

  前面的一切都归结到了一点，重构能够更快速地开发程序。我们需要记住一点，一旦开始编写代码，就算设计良好也会逐渐腐败，而不断的重构能够改善这种状况。

### 重构的挑战

* 该怎么和经理说重构的事

  如果经理屁都不懂的话，就不管他，我才是软件的创造者，我认为能够实现新功能的方式是重构，我就去重构。

* 延缓新功能开发

  重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值，重构应该是由经济利益驱动。如果你是一个团队的技术领导，一定要向团队成员表明，你重视改善代码库健康的价值，何时是否应该重构这样的判断需要多年的累积。
  
* 代码所有权

  很多重构手法不仅会影响一个模块内部，还会影响与其他部分的关系，有时调用方代码可能由令一支团队拥有。这样的函数属于已发布接口：接口的使用者与声明者彼此独立，声明者无权修改使用者的代码。可以把旧的接口标记为“不推荐使用”，但有些时候，旧的接口必须一直保留下去。

  由于这些复杂性，推荐一支团队成员都可以修改这个团队的代码，每个人监控自己责任区内发生的修改。跨团队时可以在团队A的员工可以在一个分支上修改团队B的代码，同时把代码发给团队B审核。

* 分支

  分支合并是一个复杂问题，随着特性分支存在的时间加长，合并到难度会指数上升。有种方法叫“持续集成(Continuous Integration, CI)”，也叫“基于主干开发(Trunk-Based Development)”。在使用 CI 时，每个团队成员每天至少向主线集成一次 。不过 CI 也有其代价，必须使用相关的实践以确保主线随时处于健康状态，必须学会将大功能拆分成小块，有时还需使用特性开关。

  实际上，对于开源项目特性分支可能是合适的做法，但对全职的开发团队而言，用上 CI 的团队在软件的交付上更加高效。

* 测试

  不会改变程序可观察的行为，这是重构的一个重要特征。人总有出错的时候，只要回滚到版本控制中最后一个版本就行了。这里的关键在于“快速发现错误”，绝大部分情况下，如果想要重构，得先有自测试的代码。自测试代码是极限编程的另一个重要组成部分，也是持续交付的重要环节。

* 遗留代码

  遗留代码往往很复杂，测试又不足，最关键的是：是别人写的 ：）。如果给缺乏测试的遗留系统加测试非常困难，因为它一开始就没有考虑到测试，此时可以尝试每次改善一点点。

### 重构相关

**重构，架构和 YAGNI**

有这样一种观点，在任何人写代码之前，必须先完成软件的设计和架构，一旦代码写出来，架构就固定了，只会因为程序员的草率对待而逐渐腐败。重构改变了这种观点，这种观点的最大问题在于，它假设了软件的需求可以预先充分理解，但经验显示，这个假设大多数时候是不切实际的，懂的都懂。

应对未来变化的办法之一，就是加入灵活性机制，比如预测给某个函数加入十多个参数，但有时这样会拖慢响应的速度。所以先评估“如果以后再重构会有多困难”，如果很困难时才会加入灵活性机制，这种设计方法又叫 YAGNI(you aren't going to need it) 这种工作方式必须有重构作为基础才可靠。

**重构与软件开发过程**

如果一个团队想要重构，那么每个团队成员都需要掌握重构技能，能够在需要时开展重构，而不会干扰其他人的工作，此时，自测试代码，持续集成，重构，彼此之间有很强的协同效应。有这三大核心时间打下的基础，才谈得上运用敏捷思想的其他部分，持续交付确保软件是总处于可以交付的状态，但这些东西说起来简单，做起来毫不容易。

**重构与性能**

大部分程序会把大半时间耗费在一小段代码上，所以我们先写出可调优的软件，然后调优它以获得足够的速度，之后分配一个性能调优阶段专门进行性能优化。

在性能优化阶段，我们应该用一个度量工具来监控程序的运行，之后找出性能热点并使用持续关注法来优化它们，和重构一样进行小幅度的修改，之后进行编译，测试，再次度量。知道达到客户满意的性能为止。

## 代码的坏味道

> 神秘命名

命名是编程最难的两件事之一，而改名可能是最常用的重构手法。

> 重复代码

重复代码需要使用提炼函数。

> 过长函数

函数越长，就越难理解。如果你的代码有注释，则可以把需要说明的东西写进一个独立函数中。分解成短函数之后，则需要进行良好的命名。

> 过长参数列表

实用类可以有效地缩短参数列表，同时也可以从现有的数据结构中抽出很多数据项。

> 全局数据

全局数据的问题在于，从代码库的任何一个角落都可以修改它，而没有任何机制可以探测出到底那段代码做出了修改。

> 可变数据

对数据的修改经常导致出乎意料的结果和难以发现的bug，这种bug只在很罕见的情况下发现。函数式编程就是完全建立在**数据永不变化**的概念基础上，如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变。

> 发散式变化

如果某个模块经常因为不同的原因在不同的方向发生变化，发散式变化出现了，比如新加入一个数据库，我必须修改这三个函数；如果新出现一个金融工具，我就必须修改这四个函数，这就是发散式变化的征兆。

> 霰弹式修改

霰弹式修改类似于发散式变化，如果每遇到某种变化，你都必须在不同的类内做出修改，你所面临的坏味道就是霰弹式变化。

> 依恋情结

所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互，但有时你会发现，一个函数和另一个模块中的函数或者数据交流格外频繁，远胜于自己模块内部的交流，这就是依恋情结的典型情况。

> 数据泥团

数据项就像小孩子，喜欢成群结队地待在一块，你尝尝可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数，这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。

> 基本类型偏执

大多数编程环境都大量使用基本类型。很多程序员不愿意创建对自己的问题域有用的基本类型，如钱、坐标、范围等。你可以以对象取代基本类型将原本单独存在的数据值替换为对象。

> 重复的 switch

如果你跟真正的面向对象布道者交谈，，任何 switch 语句都应该**以多态取代条件表达式**消除掉。

> 循环语句

循环已经有点儿过时，如今，函数作为一等公民已经得到了广泛的支持，因此我们可以使用**以管道取代循环**来让这些老古董退休。

> 亢赘的元素

程序元素能够给代码增加结构，但有时我们真的不需要这层额外的结构。

> 夸夸其谈通用性

当有人企图以各种各样的勾子和特殊情况来处理一些非标的事情，这种坏情况就出现了。这么做的结果往往造成系统更难理解和维护。

> 临时字段

有时你会看到这样的类：其内部某个字段仅为某种情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。

> 过长的消息链

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，这就是消息链。采取这种方式，意味着客户端代码将与查找过程中的导航结构紧密耦合。这时我们应该使用**隐藏委托关系**

> 中间人

对象的基本特征之一就是封装，对外部世界隐藏其内部细节。封装往往伴随着委托，比如，你问主管是否有时间参加加一个会议，他就把这个消息委托给他的记事本，然后他才能回答你。但是人们可能过度运用委托，你也许会看到某个类的接口有一般的函数都委托给其他类，这样就是过度运用，这是应该使用移除中间人，直接和真正负责的对象打交道。

> 内幕交易

软件喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合。在实际情况中，一定的数据交换不可避免，但我们必须尽量减少这种情况，把这种交换都放到明面上来。

> 过大的类

如果想利用单个类做太多事情，其内往往就会出现太多字段，你可以运用提炼类讲几个变量一起提炼至新类内。

> 异曲同工的类

使用类的好处之一就在于可以替换，但只有当两个类的接口一致时才能做这种替换。

> 纯数据类

它们拥有一些字段，一级用于访问这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐的操控着。此时需要把处理数据的行为从客户端搬移到纯数据类来，就能使这种情况大大改观。但不必认为每次都得这样做，十有八九这种坏味道很淡，不值得理睬。

> 被拒绝的遗赠

子类应该继承超类的函数和数据，但如果它们不想或不需要继承，这就意味着继承体系设计错误，你需要为这个子类新建一个兄弟类，再把所有用不到的函数下推给这个兄弟，这样超类就只持有所有子类共享的东西。

> 注释

当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。

## 构筑测试体系

重构是很有价值的工具，但是只有重构还不行。要正确进行重构，前提是得有一套稳固的测试集合，以便发现难以避免的疏漏。

### 自测试代码的价值

很多程序员花费在调试代码的时间上是最多的，此时可以注意一句话：类应该包含它们自己的测试代码。我们可与确保所有测试都完全自动化，让它们检查自己的测试结果。一套测试就是强大的 bug 侦测器，能够大大缩减查找 bug 所需的时间。

编写测试程序，意味者要写很多额外的代码。除非你确定体会到这种方法是如何提升编程速度的，否则自测试似乎就没有什么意义。但是，如果测试可以自动运行，编写测试代码就会真的很有趣。事实上，编写测试代码的最好时机是在开始动手编码之前。编写测试代码还能帮我把注意力集中于接口而非实现（这永远是一件好事）。预先写好的测试代码也为我的工作安上一个明确的结束标志：一旦测试代码正常运行，工作就可以结束了。

测试驱动开发的编程方式依赖于下面这个短循环：先编写一个测试，编写代码使测试通过，然后重构以保证代码整洁。这个“测试，编码，重构”的循环应该在每个小时内都重复完成很多次，这种良好的节奏感会使编程工作以更加高效、有条不紊的方式开展。

### 待测试的示例代码

下面代码能从 JSON 文件中构造一个行省对象

~~~javascript
class Province {
  constructor(doc) {
	this._name = doc.name
    this._products = []
	this._totalProduction = 0
    this._demand = doc.price
    this._price = doc.price
    doc.producers.forEach(d => this.addProducer(new Producer(this, d)))
  }
    
  addProducer (arg) {
    this._producers.push(arg)
    this._totalProduction += arg.production
  }
}
~~~

下面的函数会创建可用的 JSON 数据

```javascript
function sampleProvinceData() {
  return {
  	name: "Asia",
    producers: [
      { name: "Byzantium", cost: 10, production: 9 },
      { name: "Attalia", cost: 12, production: 10 },
      { name: "Sinope", cost: 10, production: 6 }
    ]
  }
}
```

代表生产商的 Producer 类基本只是一个存放数据的容器

```javascript
class Province {
  constructor(aProvince, data) {
    this._province = aProvince
    this._cost = data.cost
    this._name = data.name
    this._production = data.production || 0
  }
  
  get production() { return this._production }
  set production() {
    const amount = parseInt(amountStr)
    const newProduction = Number.isNaN(amount) ? 0 : amount
    this._province.totalProduction += newProduction - this._production
    this._production = newProduction
  }
    
   // 缺额的计算
   get shortfall () {
	 return this.demandValue - this.demandCost
   }
   
   // 计算利润
   get profit() {
     return this.demandValue - this.demandCost
   }
   
    get demandCost() {
      let remainingDemand = this.demand
      let result = 0
      this.producers
        .sort((a, b) => a.cost - b.cost)
        .forEach(p => {
       	  const contribution = Math.min(remainingDemand, p.production)
          remainingDemand -= contribution
          result += contribution * p.cost
      	})
      return result
    }
}
```

### 第一个测试

以下是为缺额计算过程编写的一个简单的测试

```javascript
describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData())
    assert.equal(asia.shortfall, 5)
  })
})
```

不同开发者在 describe 和 it 块中撰写的描述信息各有不同。我个人不喜欢多写，只要测试失败时足以识别出对应的测试就够了。

一个真实的系统可能拥有数千个测试。好的测试框架应该能帮我简单快速地运行这些测试，一旦出错，我马上能看到，尽管这种反馈非常简单，但对自测试代码来说却尤为重要。对于你正在处理地代码，与其对应的测试至少每隔几分钟就要运行一次，每天至少运行一次所有测试。

### 再添加一个测试

现在，我将继续添加更多测试。我遵循的风格是：观察被测试类应该做的所有事情，然后对这个类的每个行为进行测试，包括各种可能使它发生异常的边界条件。记住，测试应该是一种风险驱动的行为，我测试的目标是希望找出现在或未来可能出现的 bug。这一点很重要，**测试的重点应该是我最担心出错的部分，这样就能从测试工作中得到最大利益**。

我可以在一开始的测试夹具上，对总利润做一个基本的测试

```javascript
describe('province', function() {
  it('shortfall', function() {
    const asia = new Province(sampleProvinceData())
    expect(asia.shortfall).equal(5)
  })
  
  it('profit', function() {
    const asia = new Province(sampleProvinceData())
   	expect(asia.profit).equal(230)
  })
})
```

注意，虽然两个测试夹具产生了一些重复代码，但是最好不这样做，这会使测试间产生交互，是滋生 bug 的温床，最好用以下方法来进行测试。

```javascript
describe('province', function() {
  let asia
  beforeEach(function() {
    asia = new Province(sampleProvinceData())
  })
  it('shortfall', function() {
    expect(asia.shortfall).equal(5)
  })
  
  it('profit', function() {
   	expect(asia.profit).equal(230)
  })
})
```

beforeEach 子句会在每个测试之前运行一遍，将 asia 变量清空，每次都给它赋一个新的值，这样我就能在每个测试开始前，为他们各自构建一套新的测试夹具，这保证了测试的独立性，避免了可能带来麻烦的不确定性。

### 修改测试夹具

producer 类中的产量字段，它的设值函数行为比较复杂，它可以用来测试

~~~javascript
describe('province'...
it('change production', function() {
  asia.producers[0].production = 20
  expect(asia.shortfall).equal(-6)
  expect(asia.profit).equal(292)
})
~~~

这是一个常见的测试模式。我拿到 beforeEach **配置**好的初始标准夹具，然后对该夹具进行必要的**检查**，最后**验证**它是否表现我期望的行为。这是一套测试的常见术语，比如配置-检查-验证，或者准备-行为-断言等。其实还有第四个阶段，就是**拆除**阶段，此阶段可将测试夹具移除，以确保不同测试之间不会产生交互。这里因为是在 beforeEach 中配置好数据的，所以测试框架会默认在不同的测试间将我的测试夹具移除。

### 探测边界条件

到目前为止的测试都是聚焦于正常的行为上，这通常也被称为“正常路径”，它是指一切工作正常，用户使用方式也最符合规范的那种场景。同时，把测试推到这些条件的边界处也是不错的实践。比如看看集合为空的时候会发生什么

~~~javascript
describe('no producers', function() {
  let noProducers
  beforeEach(function() {
    const data = {
      name: 'No producers',
      producers: [],
      demand: 30,
      price: 20
    }
    noProducers = new Province(data)
  })
  it('shortfall', function() {
    expect(noProducers.shortfall).equal(30)
  })
  it('profit', function() {
    expect(noProducers.profit).equal(0)
  })
})
~~~

如果拿到的是数值类型，0 是不错的测试条件

```javascript
describe('province'...
it('zero demand', function() {
  asia.demand = 0
  expect(asia.shortfall).equal(-25)
  expect(asia.profit).equal(0)
})
```

负值同样值得一试

```javascript
describe('province'...
it('negative demand', function() {
  asia.demand = -1
  expect(asia.shortfall).equal(-26)
  expect(asia.profit).equal(-10)
})
```

可以看到，这里我是扮演’‘程序公敌“的角色，我积极思考如何破坏代码。

如果数据输入对象是可信的数据源提供的，比如同一个代码库的另一部分，就可以不用加入太多的检查，而如果输入对象是由另一个外部服务所提供，比如一个返回JSON数据的请求，那么校验和测试就显得必要了。

> 不要因为测试无法捕捉到所有的bug就不写测试，因为测试的确可以捕捉到大多数bug

什么时候要停下测试呢？当测试数量到达一定程度之后，继续增加测试带来的边际效用会递减：如果试图编写太多测试，你也可能因为工作量太大而放弃，最后什么也完不成。

### 测试远不止如此

之前，测试更多被认为另一个独立的团队的责任，但它现在愈发成为任何一个软件开发者所必备的技能，如今一个架构的好坏，很大程度要取决于它的可测试性，这是一个好的行业趋势。与编程的很多方面类似，测试也是一种迭代式的活动，除非你技能非常纯熟，或者非常幸运。

一个值得养成的好习惯是，每当你遇见一个bug，先写一个测试来复现它。仅当测试通过时，则视为把bug修完。另外，测试覆盖率的分析只能识别出那些未被测试覆盖到的代码，而不能用来衡量一个测试集的质量高低。一个测试集是否足够好，最好的衡量标准其实是主观的，请你试问自己，如果有人在代码里引入了一个缺陷，你有多大的自信它能被测试集就出来？这种信心难以被定量分析，但子测试代码的全部目标，就是要帮你获得这种信心。

测试同样可能过犹不及，测试写的太多的一个征兆是，相比要改的代码，我能感到测试就在拖慢我。

## 第一组重构

在重构名录的开头，先介绍一组我认为最有用的重构。

### 提炼函数(Extract Function)

**动机**

提炼函数是我最常用的重构之一（在这里使用的是函数这个词，但换成面向对象中的“方法/method“，或者其他任何形式的”过程/procedure“或者”子程序/subroutine“，也同样适用）。我会浏览一段代码，理解其作用，然后将其提炼到一个独立的函数中。

对于何时应该把代码放进独立的函数这个问题，我认为最合理的观点就是**如果你需要话一段时间浏览一段代码才能弄清楚它到底在干什么，那么就应该将其提炼到一个函数中，并根据它所做的事为其命名**。一旦接受了这个原则，我就逐渐养成了一个习惯：写非常小的函数——通常只有几行，在我看来，一个函数一旦超过六行，就开始散发臭味。我甚至经常写一些一行代码的函数。另外*代码的意图和实现之间有着相当大的距离*。

另外不用担心短函数会造成大量的函数调用从而造成性能问题，短函数常常会让编译器的优化功能运转更良好，应为短函数可以更容易地被缓存。另外小函数得有个好名字才行，所以你必须在命名上花心思。

**做法**

1. 创建一个新函数，根据这个函数的意图来对它命名（以它“做什么”来命名，而不是以它“怎样做”来命名）。
2. 将待提炼的代码从源函数复制到新建的目标函数中
3. 仔细检查提炼出的代码，看看其中是否引用了作用域限于源函数、在提炼出的新函数中访问不到的变量。若是，以参数的形式将它们传递给新函数。
4. 所有变量都处理完之后，编译。
5. 在源函数中，将被提炼代码段替换为对目标函数的调用。
6. 测试。
7. 查看其他代码是否有与被提炼的代码段相同或相似之处。如果有，考虑使用以函数调用取代内联代码令其调用出新的函数。

**范例：无局部变量**

```javascript
function printOwing(invoice) {
  let outstanding = 0
  for(const o of invoice.orders) {
    outstanding += o.amount
  }
  // 这是封装系统时钟调用的对象
  const today = Clock.today
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30),
  
  console.log(`name: ${invoice.customer}`)
  console.log(`amount: ${outstanding}`)
  console.log(`name: ${invoice.dueDate.toLocaleDateString()}`)
}
```

我可以轻松地把打印详细信息部分提炼出来

```javascript
function printOwing(invoice) {
  let outstanding = 0
  for(const o of invoice.orders) {
    outstanding += o.amount
  }
  // 这是封装系统时钟调用的对象
  const today = Clock.today
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30),
  
  printDetails()
    
  function printDetails() {
    console.log(`name: ${invoice.customer}`)
  	console.log(`amount: ${outstanding}`)
  	console.log(`name: ${invoice.dueDate.toLocaleDateString()}`)
  }
}
```

**范例：无局部变量**

局部变量最简单的情况是：被提炼代码段只是读取这些变量的值，并不修改它们，这种情况下我可以简单的地将它们当作参数传给目标参数。

```javascript
function printOwing(invoice) {
  let outstanding = 0
  
  for(const o of invoice.orders) {
    outstanding += o.amount
  }
  // 这是封装系统时钟调用的对象
  const today = Clock.today
  invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30),
  
  recordDueDate(invoice)
  printDetails(invoice, outstanding)
}

function printDetails(invoice, outstanding) {
  console.log(`name: ${invoice.customer}`)
  console.log(`amount: ${outstanding}`)
  console.log(`name: ${invoice.dueDate.toLocaleDateString()}`)
}

function recordDueDate(invoice) {
    const today = Clock.today
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30)
}
```

**范例：对局部变量再赋值**

如果你发现源函数地参数被赋值，应该马上使用**拆分变量**将其变成临时变量。

```javascript
function printOwing(invoice) {
  const outstanding = calculateOutstanding(invoice)
  recordDueDate(invoice)
  printDetails(invoice, outstanding)
}

function calculateOutstanding(invoice) {
  let result = 0
  for (const o of invoice.orders) {
    result += o.amount
  }
  return result
}

function printDetails(invoice, outstanding) {
  console.log(`name: ${invoice.customer}`)
  console.log(`amount: ${outstanding}`)
  console.log(`name: ${invoice.dueDate.toLocaleDateString()}`)
}

function recordDueDate(invoice) {
    const today = Clock.today
    invoice.dueDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 30)
}
```

如果返回的变量不止一个，有几种选择，最好的选择通常是：挑选另一块变量来提炼，我比较喜欢让每个函数都只返回一个值，所以我会安排多个函数用以返回多个值。如果真的有必要提炼一个函数返回多个值，可以构造并返回一个记录对象，不过通常最好的办法还是回过头来重新处理局部变量。

### 内联函数

**动机**

有时候你会遇到某些函数，其内部代码和函数名称同样清晰易读，也可能你重构了该函数的内部实现，使其内容和其名称变得同样清晰。若果真如此，你就应该去掉这个函数，直接使用其中的代码。间接性可能带来帮助，但非必要的间接性总让人不舒服。

另一种需要使用内联函数的情况是：我手上有一群组织不甚合理的函数，可以将他们都内联到一个大型函数中，再以我喜欢的方式重新提炼出小函数。

如果代码中有太多间接层，使得系统中的所有函数似乎都只是对另一个函数的间接委托，造成我在这些委托动作之间晕头转向，那么我通常会使用内联函数。

**做法**

1. 检查函数，确定它不具有多态性。如果该函数属于一个类，并且子类继承了这个函数，那么就无法内联。
2. 找出这个函数的所有调用点。
3. 将这个函数的所有调用点都替换为函数本体
4. 每次替换之后，执行测试。不必一次完成整个内联操作，如果某些调用点比较难以内联，可以等到时机成熟后再处理
5. 删除该函数的定义。

```javascript
function rating(aCustomer) {
  const lines = []
  gatherCustomerData(lines, aCustomer)
  return lines
}

function gatherCustomerData(out, aCustomer) {
  out.push(['name', aCustomer.name])
  out.push(['location', aCustomer.location])
}
```

重构为

```javascript
function rating(aCustomer) {
  const lines = []
  lines.push(['name', aCustomer.name])
  lines.push(['location', aCustomer.location])
  return lines
}
```

### 提炼变量

**动机**

表达式可能非常复杂而且难以阅读，这种情况下，局部变量可以帮助我们将表达式分解为比较容易管理的形式。再面对一块复杂逻辑时，局部变量使我能给其中一部分命名，这样我能更好的理解这部分逻辑是要干什么。

如果我考虑使用提炼变量，就意味着我要给代码中的一个表达式命名。如果这个名字只在当前函数中有意义，那么提炼变量个不错的选择，如果这个变量名在更宽的上下文中也有意义，我会考虑将其暴露出来。

**做法**

1. 确认要提炼的表达式没有副作用。
2. 生命一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值。
3. 用这个新变量取代原来的表达式
4. 测试

如果该表达式出现了多次，请用这个新变量逐一替换，每次替换之后都要执行测试。

**范例**

```javascript
function price(order) {
  return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100)
}
```

重构为

```javascript
function price(order) {
  const basePrice = order.quantity * order.itemPrice
  const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05
  const shipping = Math.min(order.quantity * order.itemPrice * 0.1, 100)
  return basePrice - quantityDiscount + shipping
}
```

**范例：在一个类中**

下面是同样的代码，但这次它位于一个类中

```javascript
class Order {
  constructor(aRecord) {
    this._data = aRecord
  }
  get price () {
    return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100)
  }
}
```

这些变量名所代表的概念，适用于整个 Order 类，而不仅仅是“计算价格”的上下文，因此，将它们提炼成方法显然更有益处。

```javascript
class Order {
  constructor(aRecord) {
    this._data = aRecord
  }
  get price () {
    return this.basePrice - this.quantityDiscount + this.shipping
  }
    
 get basePrice () { return order.quantity * order.itemPrice }
 get quantityDiscount () { return Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 }
  get shipping () { return Math.min(order.quantity * order.itemPrice * 0.1, 100) }
}
```

### 内联变量

**动机**

在一个函数内部，变量能给表达式提供有意义的名字，因此通常变量是好东西。

**做法**

1. 检查确认变量赋值语句的右侧表达式没有副作用。
2. 如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试。
3. 找到第一处该使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式。
4. 测试。
5. 重复前面两步，逐一替换其他所有使用该变量的地方。
6. 删除该变量的测试点和赋值语句。
7. 测试

### 改变函数声明

**动机**

函数是我们将程序拆分成小块的主要方式。函数声明则展现了如何将这些小块组合在一起工作——可以说，它们就是软件系统的关节。

对于这些关节而言，最重要的元素当属函数的名字，如果看到一个函数的名字不对，一旦发现了更好的名字，就得尽快给函数改名。

对于函数的参数，道理也是一样。函数的参数列表阐述了函数如何与外部世界共处。函数的参数设置了一个上下文，只有在这个上下文中，我才能使用这个函数。比如加入该函数参数是是 person，我就不能用它处理 company。

**做法**

改变函数声明有一套简单的做法，这套简单的做法常常够用，但在很多时候，有必要以更渐进的方式逐步迁移达到最终结果。迁移式的方法让我们可以逐步修改调用方方代码，如果函数被很多地方调用，或者修改不容易，或者要修改的是一个多态函数，或者对函数声明的修改比较复杂，能渐进式地逐步修改就很重要。

**简单做法**

1. 如果想移除一个参数，首先确定函数体内没有使用该参数。
2. 修改函数声明，使其成为你期望的状态。
3. 找出所有使用旧函数声明的地方，将他们改为新的函数声明。
4. 测试

**迁移式做法**

1. 如果有必要，先对函数内部加以重构
2. 使用提炼函数将函数体提炼成一个新函数
3. 如果提炼出的函数需要新增参数，用前面的简单做法添加即可
4. 测试
5. 对旧函数使用内联函数
6. 如果新函数使用了临时的名字，再次使用改变函数声明将其改回原来的名字
7. 测试

**范例：函数改名(简单做法)**

下列函数的名字太过简略了：

```javascript
function circum(radius) {
  return 2 * Math.PI * radius
}
```

修改函数声明

```java
function circumference(radius) {
  return 2 * Math.PI * radius
}
```

将所有调用 circum 的地方改为 circumference。

在不同的编程语言环境中，‘找到所有调用旧函数的地方’这件事的难度也各异。静态类型加上趁手的IDE 能提供最好的体验，通常可以全自动地完成函数改名。如果没有静态类型，就需要多花些功夫。

**范例：函数改名(迁移式做法)**

```javascript
function circum(radius) {
  return 2 * Math.PI * radius
}
```

首先对整个函数体使用提炼函数

```javascript
function circum(radius) {
  return circumference(radius)
}

function circumference(radius) {
  return 2 * Math.PI * radius
}
```

每次修改一处调用者，所有调用者都修改完之后，我就可以删除旧函数。

**范例：添加参数**

现在有一个管理函数的软件

```javascript
class Book...
addReservation(customer) {
  this._reservationhs.push(customer)
}
```

现在我需要支持“高优先级预定”，因此我要给 addReservation 额外添加一个参数，用于标记这次预定应该进入普通预定还是优先队列。搜先我用提炼函数把 addReservation 的函数体提炼出来，放进一个新函数。

```javascript
class Book...
addReservation(customer) {
  this._reservationhs.push(customer, false)
}

zz_addReservation(customer) {
  this._reservationhs.push(customer)
}
```

之后在新函数的声明中增加参数，同时修改旧函数中调用新函数的地方

```javascript
class Book...
addReservation(customer) {
  this._reservationhs.push(customer, false)
}

zz_addReservation(customer) {
  this._reservationhs.push(customer, isPriority)
}
```

在修改调用方之前，可以利用js的语言特性先**引入断言**

```javascript
class Book...

zz_addReservation(customer, isPriority) {
  assert(isPriority === true || isPriority === false)
  this._reservationhs.push(customer, isPriority)
}
```

现在，入股哦我在修改调用方时出了错，没有提供新参数，这个断言会帮我抓到错误。

**范例：把参数改为属性**

假如我有一个函数，用于判断顾客(custom)是否来自新英格兰(New England)地区：

```javascript
function inNewEngland(aCustomer) {
  return ['MA', 'CT'， 'ME'].includes(aCustomer.address.state)
}
```

下面是函数调用方

```javascript
const newEnglanders = someCustomers.filter(c => inNewEngland(c))
```

inNewEngland 函数只用到了顾客所在的州这项信息，我希望重构这个函数，使其接受州代码(state code) 作为参数，这样就能去掉对’顾客‘概念的依赖，使这个函数能在更多的上下文中使用。

```javascript
function inNewEngland(aCustomer) {
  const stateCode = aCustomer.address.state
  return ['MA', 'CT'， 'ME'].includes(stateCode)
}
```

然后再用提炼函数创建新函数

```javascript
function inNewEngland(aCustomer) {
  const stateCode = aCustomer.address.state
  return xxNEWinNewEngland(stateCode)
}

function xxNEWinNewEngland(stateCode) {
  return ['MA', 'CT'， 'ME'].includes(stateCode)
}
```

这时给新函数起一个好记又独特的临时名字，这样回头要改回原来的名字时也简单一些。

之后在原函数中使用内联变量，把刚才提炼出来的参数内联回去：

```javascript
function inNewEngland(aCustomer) {
  return xxNEWinNewEngland(aCustomer.address.state)
}
```

之后用内联函数把旧函数内联到调用处，可以每次修改一个调用处。

```javascript
const newEnglanders = someCustomers.filter(c => xxNEWinNewEngland(c.address.state))
```

旧函数被内联到各调用处之后，再次使用**改变函数声明**，把新函数改回旧名字：

```javascript
const newEnglanders = someCustomers.filter(c => inNewEngland(c.address.state))

function inNewEngland(stateCode) {
  return ['MA', 'CT'， 'ME'].includes(stateCode)
}
```

### 封装变量

**动机**
重构的作用就是调整程序中的元素。函数相对容易调整一些，应为函数只有一种用法，就是调用。在改名或搬移函数的过程中，总是可以比较容易地保留就函数作为转发函数（即旧代码调用旧函数，旧函数再调用新函数）。这样的转发函数通常不会存在太久，但的确能够简化重构过程。

而数据就麻烦的多，因为美发设计这样的转发机制。如果把数据搬走，就必须修改所有引用该数据的代码，否则该程序就不能运行。如果数据的可访问范围很大，重构的难度就会随之增大，这也是说全局数据是大麻烦的原因。

如果想要搬移一处被广泛使用的数据，最好的办法往往是先以函数形式封装对该数据的访问。封装还能提供一个清晰的观测点，可以由此监控数据的变化和使用情况。我的习惯是，对于所有可变的数据，只要它的作用域超过单个函数，我就会将其封装起来，只允许通过函数访问。数据的作用域越大，封装就越重要。

面向对象方法如此强调对象的数据应该保持私有(private)，背后也是同样的原因。每当看见一个公开(public)的字段时，我就会考虑使用封装变量。

**做法**

1. 创建封装函数，在其中访问和更新变量值。
2. 执行静态检查。
3. 逐一修改使用该变量的代码，将其改为调用合适的封装函数。每次替换之后，执行测试。
4. 限制变量的可见性。
5. 测试。
6. 如果变量的值是一个记录，考虑使用**封装记录**。

**范例**

下面这个全局变量中保存了一些有用的数据

```javascript
let defaultOwner = { firstName: "Martin", lastName: "Fowler" }

// 使用它的代码
spaceship.owner = defaultOwner
```

对这段数据进行处理

```JavaScript
let defaultOwner = { firstName: "Martin", lastName: "Fowler" }

function getDefaultOwner() { return defaultOwner }
function setDefaultOwner(arg) { defaultOwner = arg }

// 使用它的代码
spaceship.owner = getDefaultOwner()
setDefaultOwner({ firstName: "Rebecca", lastName: "Parsons" })
```

在替换完所有使用该变量的代码之后，就可以限制它的可见性，这一步的用意有两个，一来检查是否遗漏了变量的引用，二来可以保住以后的代码也不会直接访问该变量。在 JS 中，可以把变量和访问函数搬移到单独一个文件中，并且导出访问函数，这样就限制了变量的可见性。

如果条件不允许限制对变量的访问，可一个将该变量改名，起个有意义又难看的名字，比如 __privateOnly_defaultOwner，提醒后来的客户端。

**封装值**

前面介绍的基本重构手法对数据结构的引用做了封装，是我能控制对该数据结构的访问和重新赋值，但并不能对结构内部数据项的修改。

有两个办法可以做到禁止对数据结构内部的数值做修改：

1. 修改取值函数，时期返回该数据的一份副本

   ```javascript
   let defaultOwnerData = { firstName: "Martin", lastName: "Fowler" }
   
   function getDefaultOwner() { return Object.assign({}, defaultOwnerData) }
   function setDefaultOwner(arg) { defaultOwner = arg }
   ```

   对于列表数据，我尤其常用这一招。但在使用副本的做法时，我必须格外小心：有些代码可能希望修改共享的数据。若果真如此，我就只能依赖测试来发现问题了。

2. 阻止对数据的修改，比如通过**封装记录**就能很好的体现这一效果。

   ```javascript
   let defaultOwnerData = { firstName: "Martin", lastName: "Fowler" }
   function defaultOwner() { return new Person(defaultOwnerData) }
   function setDefaultOwner(arg) { defaultOwner = arg }
   
   class Person {
     constructor(data) {
       this._lastName = data.lastName
       this._firstName = data.firstName
     }
       
     get lastName() { return this._lastName }
     get firstName() { return this._firstName }
   }
   ```

到目前为止，我都在讨论“在取数据时返回一份副本”，其实设置函数也可以返回一份副本。这取决于数据从哪儿来，以及我是否需要保留对源数据的连接，以便知悉源数据的变化。如果不需要这样一条连接，那么设值函数就有好处：可以防止因为源函数发生变化而造成的意外事故。如果不做复制，风险则是可能未来可能会陷入漫长而困难的调试排错过程。

另外，前面的数据复制，类封装只是在数据记录结构中深入了一层，如果想要走的更深入，则需要更多层级的复制或是封装。

一言以蔽之，数据被使用得越广，就越是值得花精力给它一个体面的封装。

### 变量改名

**动机**

好的命名是整洁编程的核心。变量能够很好地解释一段程序在干什么。使用范围越广，名字的好坏就越重要。在 JS 这样的动态语言中，我喜欢把类型信息也放进名字里。

**机制**

1. 如果变量被广泛使用，考虑使用**封装变量**将其封装起来。
2. 找出所有使用该变量的代码，逐一修改。
3. 测试。

**范例**

如果要改名的变量只作用于一个函数(临时变量或参数)，对其改名是最简单的，这种情况太简单，根本不需要范例：找到变量的所有引用，修改过来就行。完成修改之后就执行测试。

如果变量的作用域不止于单个函数，问题就会出现。

```javascript
// 代码库的各处可能有很多地方使用它
let tpHd = 'untitled'
// 有些地方是在读取变量值
result += `<h1>${tpHd}</h1>`
// 还有些地方是在更新它的值
tpHd = obj['articleTitle']

// 对于这种情况，我通常的反应就是运用封装变量
result += `<h1>${tpHd}</h1>`
setTitle(obj['articleTitle'])

function title () { return tpHd }
function setTitle(arg) { tpHd = arg }

// 现在就可以给变量改名
let _title = 'untitled'

function title () { return _title }
function setTitle(arg) { _title = arg }
```

我可以继续重构下去，将包装函数内联回去，这样所有的调用者就变回直接使用变量的状态。不过我很少这样做，如果这个变量被广泛使用，以至于我感到先做封装才敢改名，将变量封装在函数后面。

**给常量改名**

我想改名的是一个常量(或者在客户端看来就像是常量的元素)，我可以复制这个常量，这样既不需要封装，又可以逐步完成改名。

```javascript
const cpyNm = 'Acme Gooseberries'

// 第一步是复制这个常量
const companyName = 'Acme Gooseberries'
const cpyNm = companyName
```

有了这个副本，就可以逐一修改引用旧常量的代码，使其引用新的常量，全部修改完成后，我会删掉旧的常量。这个做法不仅适用于常量，也适用于客户端只能读取的变量。

### 引入参数对象

**动机**

我常会看见，一组数据项总是结伴而行，出没于一个有一个函数。这样一组下数据就是所谓的数据泥团，我喜欢代之以一个数据结构。

将数据组织成结果是一件有价值的事，因为这让数据项之间的关系变得明晰。但这项重构的真正的意义在于，它会催生代码中更深层次的改变。一旦识别出新的数据结构，我就可以重做程序的行为来使用这些结构。我会 创建出函数来不做围绕这些数据的共用行为——可能只是一组公用的函数，也可能用一个类把数据结构与使用数据的函数组合起来。

**做法**

1. 如果还没有合适的数据结构，就创建一个。我倾向于使用类，因为稍后把行为放进来会比较容易。我通常会尽量确保这些新建的数据结构是值对象。
2. 测试。
3. 使用**改变函数声明**给原来的函数新增一个参数，类型是新建的数据结构。
4. 测试。
5. 调整所有调用者，传入新数据结构的适当实例。每修改一处，执行测试。
6. 用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数，测试。

**范例**

下面代码查看一组温度读数，数据如下

```javascript
const station = {
  name: 'ZB1',
  raadings: [
    { temp: 47, time: '2016-11-10 09:10' },
    { temp: 53, time: '2016-11-10 09:20' },
    { temp: 58, time: '2016-11-10 09:30' },
    { temp: 53, time: '2016-11-10 09:40' },
    { temp: 51, time: '2016-11-10 09:50' },
  ]
}

// 下面的函数负责找出超出指定范围的温度读数
function readingsOutsideRange(station, min, mas) {
  return station.reading
    .filter(r => r.temp < min || r.temp > max)
}

// 调用方的代码可能是下面这样
alerts = readingsOutsideRange(station, 
                             operationPlan.temperatureFloor,
                             operationPlan.temperatureCeiling)
```

这里的调用代码从另一个对象中抽出两项数据，转手又把这一堆数据传递给 readingsOutsideRange。像这样用 min 和 max 两项毫不相干的数据来表示一个范围的情况并不少见，最好是将其组合为一个对象。

```javascript
class NumberRange {
  constructor(min, max) {
    this._data = { min: min, max: max }
  }
  
  get min () { return this._data.min }
  get max () { return this._data.max }
}
```

我声明了一个类，而不是基本的 JavaScript 对象，因为这个重构通常只是一系列重构的起点，在这个新类中，我不会提供任何更新数据的函数，因为我有可能将其处理成值对象。在使用这个重构手法时，大多数情况下我都会创建值对象。

```javascript
function readingsOutsideRange(station, min, max, range) {
  return station.reading
    .filter(r => r.temp < range.min || r.temp > range.max)
}

const range = new NumberRange(operationPlan.temperatureFloor,  operationPlan.temperatureCeiling)

alerts = readingsOutsideRange(station, range)
```

这项重构手法到这儿就完成了。不过，创建一个类只是为了把行为搬移进去。这里我可以给‘范围’类添加一个函数，用于测试一个值是否落在范围之内。

```javascript
function readingsOutsideRange(station, min, max, range) {
  return station.reading
    .filter(r => r.temp < range.min || r.temp > range.max)
}

class NumberRange...
contains(arg) { return  (arg >= this.min && arg <= this.max)}
```

### 函数组合成类

**动机**

类，在大多数现代编程语言中都是基本的构造。它们是面向对象语言的首要构造，在其他程序设计方法中也同样有用。

如果发现一组函数形影不离地操作同一块数据，那么就是时候组建一个类了。除了可以把已有的函数组织起来，这个重构还给我们一个机会，去发现其他的计算逻辑，把它们也重构到新的类当中。

将函数组织到一起的另一种方式是**函数组合变换**。在有些编程语言中，类不是一等公民，而函数则是。面对这样的语言，可以用*函数所谓对象*的心事来实现这个重构手法。

**做法**

1. 运用**封装记录**对多个函数公用的数据记录加以封装，比如引入**参数对象**。
2. 对于使用该记录结构的每个函数，运用**搬移函数**将其移入新类。
3. 用以处理该数据记录的逻辑何以用**提炼函数**提炼出来，并移入新类。

**范例**

我虚构了一种用于向老百姓供给茶水计量器的数据，得到类似这样的读数

```javascript
reading = { customer: 'ivan', quantity: 10, month: 5, year: 2017 }

// 我发现有很多处理这些数据记录的代码
// 客户端1，此处计算“基础费用”
const aReading = acquireReading()
const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity

// 客户端2，计算交税
const aReading = acquireReading()
const base = baseRate(aReading.month, aReading.year) * aReading.quantity
const taxableCharge = Math.max(0, base - taxThreshold(aReading.year))

// 客户端3，基础费用计算了两次，有人已经提炼了
const aReading = acquireReading()
const basicChargeAmount = calculateBaseCharge(aReading)

function calculateBaseCharge(aReading) {
  return baseRate(aReading.month, aReading.year) * aReading.quantity
}
```

看到这里，我很自然地想把这个提炼的函数替换掉 客户端1 和 客户端2的代码。但这样一个顶层函数的问题在于，它通常位于一个文件中，读者不一定能先到来这里寻找它，我更愿意对代码做更多修改，让该函数与其处理的数据在空间上有更紧密的联系，为此目的，不妨把数据本身变为一个类。

```javascript
class Reading {
  constructor(data) {
    this._customer = data.customer
    this._quantity = data.quantity
    this._month = data.month
    this._year = data.year
  }
    
  get customer() { return this._customer }
  get quantity() { return this._quantity }
  get month() { return this._month }
  get year() { return this._year }
}
```

首先，我想把手上已有的函数 calculateBaseCharge 搬到新建的 Reading 类中

```javascript
class Reading...
get baseCharge() {
  return baseRate(this.month, this.year) * this.quantity
}

get taxableCharge() {
  return Math.max(0, this.baseCharge - taxThreshold(this.year))
}

// 客户端3
const rawReading = acquireReading()
const aReading = new Reading(rawReading)
const basicChargeAmount = aReading.taxableCharge

// 客户端1
const rawReading = acquireReading()
const aReading = new Reading(rawReading)
const basicChargeAmount = aReading.baseCharge
```

### 函数组合成变换

**动机**

在软件中，经常需要把数据喂给一个程序，让它计算出各种派生信息。我更愿意把所有计算派生数据的逻辑收拢到一处，这样始终可以在固定的地方找到和更新这些逻辑，避免重复。

一个方式是采用数据变换函数：这种函数接收源数据作为输入，计算出所有的派生数据，将派生数据以字段形式填入输出数据。函数组合成变换的替代方案是**函数组合成类**，先用源数据创建一个类，再把相关的计算逻辑搬移到类中。

> 不过这两者有一个重要的区别：如果代码中会对源数据做更新，那么使用类要好得多；如果使用变换，派生数据会被存储在新生成的记录中，一旦源数据被修改，我就会遭遇数据不一致。

把函数组合起来的原因有二：一是防止计算派生数据的逻辑到处重复。二是孤立存在的函数常常很难找到。

**做法**

1. 创建有一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。这一步通常需要对数据的记录做深复制，确保不会修改原来的记录。
2. 挑选一块逻辑，将其主题移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段。
3. 测试。
4. 针对其他相关的计算逻辑，重复上述步骤。

**范例**

```javascript
reading = { customer: 'ivan', quantity: 10, month: 5, year: 2017 }

// 我发现有很多处理这些数据记录的代码
// 客户端1，此处计算“基础费用”
const aReading = acquireReading()
const baseCharge = baseRate(aReading.month, aReading.year) * aReading.quantity

// 客户端2，计算交税
const aReading = acquireReading()
const base = baseRate(aReading.month, aReading.year) * aReading.quantity
const taxableCharge = Math.max(0, base - taxThreshold(aReading.year))

// 客户端3，基础费用计算了两次，有人已经提炼了
const aReading = acquireReading()
const basicChargeAmount = calculateBaseCharge(aReading)

function calculateBaseCharge(aReading) {
  return baseRate(aReading.month, aReading.year) * aReading.quantity
}
```

把这些计算派生数据的逻辑搬移到一个变换函数中，该函数接收原始的“读数”作为输入，输出则是增强的“读数”记录，其中包含所有共用的派生数据。

我首先要创建一个变换函数，它要做的事很简单，就是复制输入的对象：

```javascript
import _ from 'lodash'

function enrichReading(original) {
  const result = _.cloneDeep(original)
  result.baseCharge = calculateBaseCharge(result)
  result.taxableCharge = Math.max(0, result.baseCharge - taxThreshold(result.year))
  return result
}

// 客户端3
const rawReading = acquireReading()
const aReading = enrichReading(rawReading)
const taxableCharge = aReading.taxableCharge

// 客户端1
const rawReading = acquireReading()
const aReading = enrichReading(rawReading)
const basicChargeAmount = aReading.baseCharge
```

增强后的读数记录有一个大问题：如果某个客户端修改了一项数据的值，会导致数据不一致，在 js 中，避免这种情况的最好办法是不要使用本重构手法，改用函数组合成类。如果编程语言支持不可变的数据结构，那么就没有这个问题了。如果数据是在制度的上下文中使用(比如在网页上显示派生数据)，还是可以使用变换。

### 拆分阶段

**动机**

每当看见一段代码在同时处理两件不同的事，我就想把它拆分成各自独立的模块，因为这样到了需要修改的时，我就可以单独处理每个主题，而不必同时在脑子里考虑两个不同的主题。

最简单的拆分方法之一，就是把一大段行为分成顺序执行的两个阶段。可能你有一段处理逻辑，其数据数据的格式不符合计算逻辑的要求，所以你得先对输入数据作一番调整，使其便于处理

如果一块代码中出现了上下几段，各自使用不同的一组数据和函数，将这些代码片段拆分成各自独立的模块，更能明确地标识出它们之间的差异。

**作法**

1. 将第二阶段的代码提炼成独立的函数。
2. 测试。
3. 引入一个数据中转结构，将其作为参数添加到提炼出的新函数的参数列表中。
4. 测试。
5. 逐一检查提炼出的“第二阶段函数“的每个参数。如果某个参数被第一阶段用到，就将其移入中转数据结构。每次搬移之后都要进行测试。
6. 对第一阶段的代码运用**提炼函数**，让提炼出的函数返回中转数据结构。

**范例**

我有一段”计算订单价格“的代码

```javascript
function priceOrder(product, quantity, shioppingMethod) {
  // 根据商品信息计算订单中与商品相关的价格
  const basePrice = product.basePrice * quantity
  const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice * product.discountRate
  
  // 根据配送信息计算配送成本
  const shippingPerCase = (basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase
  const shippingCost = quantity * shippingPerCase
  const price = basePrice - discount + shippingCost
  return price
}
```

可以看出上面有两块逻辑相对独立

```javascript
function priceOrder(product, quantity, shippingMethod) {
  const priceData = calculatePricingData(product, quantity)
  return applyShipping(priceData, shippingMethod)
}

function calculatePricingData(product, quantity) {
  const basePrice = product.basePrice * quantity
  const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice * product.discountRate
  return { basePrice: basePrice, quantity: quantity, discount: discount }
}

function applyShipping(priceData, shippingMethod) {
  const shippingPerCase = (priceData.basePrice > shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase
  const shippingCost = priceData.quantity * shippingPerCase
  return priceData.basePrice - priceData.discount + shippingCost
}
```

## 封装

分解模块时最重要的标准，也许就是识别出那些模块应该对外界隐藏的小秘密了。类与模块已然是实施封装的最大实体了，但小一点的函数对于封装实现细节也有益处。

### 封装记录

**动机**

记录型结构是多数编程语言提供的一种常见特性。他们能直观地组织起存在关联的数据，但简单的记录型结构也有缺陷，它强迫我清晰地区分”记录中存储的数据“和”通过计算得到的数据“。

这就是对于可变数据，我总是更偏爱使用类对象而非记录的原因。对象可以隐藏结构的细节，该对象的用户不必追究存储的细节和计算的过程。另外，这是对于可变数据，对于不可变数据，大可直接把数据直接保存在记录里，需要做数据变换时增加一个填充步骤即可。

记录型结构可以有两种类型，一是需要声明合法的字段名字，另一种可以随便用任何字段名字，后者常用语言库本身实现，并通过类的形式提供出来。使用这类结构也有缺陷，就是一条记录上持有什么字段往往不够直观。

**做法**

1. 对持有记录的变量使用**封装变量**，将其封装到一个容易搜索到名字的函数中。
2. 创建一个类，将记录包装起来，并将记录变量都值替换为该类的一个实例。然后再类上定义一个访问函数，用于返回原始的记录。修改封装变量的函数。令其使用这个访问函数。
3. 测试。
4. 新建一个函数，让它返回该类的对象，而不是那条原始的记录。
5. 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例的函数调用。使用对象上的访问函数来获取数据的字段。
6. 一处类对于原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。
7. 测试。
8. 如果记录中的字段本身也是复杂结构，考虑对其再次应用**封装记录**。

**范例**

首先，我从与一个常量开始，该常量在程序中被大量使用。

```javascript
// 这是一个普通的 JS 对象，程序中很多地方都把它当作记录型结构在使用
const organization = { name: "Acme Gooseberries", country: "GB" }
// 下面是对其进行读取和更新的地方
result += `<h1>${organization.name}</h1>`
organization.name = newName
```

使用一个类进行封装

```javascript
class Organization {
  constructor(data) {
    this._name = data.name
    this._country = data.country
  }
  
  get name() { return this._name }
  set name(aString) { this._name = aString }
  get country() {  return this._country }
  set country(aCountryCode) { this._country = aCountryCode }
}

const organization = new Organization({ name: 'Acme Gooseberries', country: 'GB' })
function getOrganization() { return organization }

result += `<h1>${getOrganization().name}</h1>`
```

这样做可以使外界无法引用原始的数据记录，直接持有原始的记录会破坏封装的完整性。

**封装嵌套记录**

上面的例子我们使用了浅复制展开到了对象里，但当我处理深层嵌套的数据时，重构手法的核心步骤依然适用，但对记录的读取点则有多种处理方案。

下面是一组顾客信息的集合，保存在散列映射中，通过顾客ID进行索引

```javascript
"1920": {
  name: 'martin',
  id: '1920',
  usages: {
    '2016': {
      '1': 50,
      '2': 55
    },
    '2015': {
      '1': 70,
      '2': 63
    }
  }
},
'38765': {
  name: 'neal',
  id: '38673'
}

// 对数据进行更新
customerData[customerID].usages[year][month] = amount

// 读取数据
function compareUsage(customerID, laterYear, month) {
  const later = customerData[customerID].usages[lateYear][month]
  const earlier = customerData[customerID].usages[lateYear - 1][month]
  return { laterAmount: later, change: later - earlier }
}
```

接下来创建一个类来容纳整个数据结构

```javascript
class CustomerData {
  constructor(data) {
    this._data = data
  }
    
  get rawData () {
    return _.clone(this._data)
  }
  
  setUsage(customerID, year, month, amount) {
    this._data[customerID].usages[year][month] = amount
  }
}

const getCustomerData () { return new CustomerData(customerData) }
getCustomerData().setUsage(customerID, year, month, amount)
```

封装大型数据时，我会更多关注更新操作，将它们集中到一个地方，是此次封装过程最重要的一部分。

另一个方式是，返回一份只读的数据代理，如果客户端代码尝试修改对象的结构，那么该数据代理就会抛出异常。读取数据有下面几种方式。

第一种是与设值函数采用同等待遇，把所有对数据的读取提炼成函数，并将它们搬移到 CustomerData 类中

```javascript
class CustomerData...
usage(customerID, year, month) {
  return this._data[customerID].usage[year][month]
}
```

这种方式能够为 customerData 提供一份清晰的 API 列表，清楚描绘了该类的全部用途，但这样会使代码量剧增，现代编程语言大多提供直观的语法，，以支持从深层的列表和散列结构中获得数据，因此直接把这样的数据结构给到客户端，也不失为一种选择。

如果客户端想要拿到一份数据结构，我大可直接将实际的数据交出，但这样做我无法阻止用户直接对数据进行修改。最简单的方法是返回原始数据的一份副本，但这种方案会导致复制举到的数据结构时代价颇高。另一种方案需要更多工作，但能提供更可靠的控制粒度：对每个字段循环应用封装记录。

### 封装集合

**动机**

我喜欢封装程序中的所有可变数据，这使我很容易看清楚数据被修改的地点和修改方式。我们通常鼓励封装——使用面向对象技术的开发者对封装尤其重视——但封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。

最好的做法是，不要让集合的取值函数返回原始集合，这就避免了客户端的意外修改。

一种避免直接修改集合的方式是，永远不要直接返回集合的值，这种方式提倡，不要直接使用集合的字段，而是通过定义类上的方法来代替，比如将 aCustomer.orders.size 替换为 aCustomer.numberOfOrders

还有一种方法是，以某种形式限制集合的访问权，只允许对集合进行读操作，比如返回一个只读代理。

也许最常见的做法是，危机和提供一个取值函数，令其返回一个集合的副本，但如果这个集合很大，这个做法可能带来性能问题，，但多数列表都没这么大。

采用哪种方法并无定式，但最重要的是在同个代码库中做法要保持一致。

**做法**

1. 如果集合的引用尚未封装起来，先用**封装变量**封装它。
2. 在类上添加用于“添加集合元素”和“移除集合元素”的函数
3. 执行静态检查。
4. 查找集合的引用点，如果由调用者直接修改集合，令该处调用使用新的添加/移除元素的函数。每次修改后执行测试。
5. 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本。
6. 测试。

**范例**
假设有个人要去上课，我们用一个简单的 Course 来表示 “课程”

```javascript
class Person...
constructor(name) {
  this._name = name
  this._courses = []
}
get name() { return this._name }
get courses() { return this._courses }
set courses(aList) { this._courses = aList }

class Course...
constructor(name) {
  this._name = name
  this._isAdvanced = isAdvanced
}
get name() { return this._name }
get isAdvanced() { return this._isAdvanced }

// 客户端会使用课程集合来获取课程的相关信息
numAdvancedCourses = aPerson.coursers
  .filter(c => c.isAdvanced)
  .length

// 客户端代码
const basicCourseNames = readBasicCourseNames(filename)
aPerson.courses = basicCourseNames.map(name => new Course(name, false))

// 但客户端也可能发现，直接更新课程列表显然更容易
for (const name of readBasicCourseNames(filename)) {
  aPerson.courses.push(new Course(name, false))
}
```

上面就破坏了封装性，因为以此种方式更新列表Person 类更笨无从得知。这里仅仅封装了字段引用，而未真正封装字段的内容。

现在我来对类实施真正的封装

```javascript
class Person...
addCourse(aCourse) {
  this._courses.push(aCourse)
}
removeCourse(aCourse, fnIfAbsent = () => {throw new RangError()}) {
  const index = this._courses.indexOf(aCourse)
  if (index === -1) fnIfAbsent()
    else this._courses.splice(index, 1)
}

// 如果必须提供一个设置方法作为API，我至少要确保用一份副本为字段赋值
set courses(aList) {this._courses = aList .slice()}

// 同时我还希望确保所有的修改都通过这些方法进行，为达此目的，我会让取值函数返回一份副本
get courses() { return this._courses.slice() }
```

任何负责管理集合的类都应该总是返回数据副本，只要我做的事看起来可能改变集合，我也会返回一个副本。

### 以对象取代基本类型

**动机**

开发初期，你可能会用简单的数据项来表示简单的情况，比如使用数字或字符串来表示电话号码等。但随着开发的进行，你可能会发现，这些简单的数据项不再是那么简单了，比如电话号码可能还需要格式化，抽取区号之类的特殊行为，这类逻辑很快会制造出许多重复代码。

一旦我对某个数据不仅仅局限于打印时，我就会为它创建一个新类，创建新类无需太大的工作量，但它们对代码库有深远的影响，实际上，很多有经验的开发者认为，这是他们工具箱里最实用的重构手法之一。

**做法**

1. 如果变量尚未被封装起来，先使用**封装变量**封装它。
2. 为这个数据值创建一个简单的类，类的构造函数应该保存这个数据值，并为它提供一个取值函数。
3. 执行静态检查。
4. 修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明。
5. 修改取值函数，令其调用新类的取值函数，并返回结果。
6. 测试。
7. 对第一步得到的访问函数使用**函数改名**。
8. 考虑应用将**引用对象改为值对象**或**将值对象改为引用对象**。

**范例**

从一个简单的订单(order)类开始。该类有冲一个简单的记录结构里读取所需要的数据，其中有一个 priority 字段。

```javascript
class Order...
constructor(data) {
  this.priority = data.priority
  // more initialization
}

// 客户端代码
highPriorityCount = orders.filter(o => 'high' === o.priority || 'rush' === o.priority).length
```

接下来对这个字段进行处理

```javascript
class Order...
get priority() {return this._priority}
get priorityString() {return this._priority.toString()}
set priority(aString) {this._priority = new Priority(aString)}

class Priority {
  constructor(value) {this._value = value}
  // 一个返回字符串描述的 API 更能传达“发生了数据转换”的信息
  toString() {return this._value}
}

// 客户端
highPriorityCount = orders.filter(o => 'high' === o.priority.toString() || 'rush' === o.priority.toString()).length
```

此时我可以开始支持让 Order 类的客户端拿着 Priority 实例来调用设值函数，这可以通过调整 Priority 类的构造函数来实现。

```javascript
class Priority...
constructor(value) {
  if (value instanceof Priority) return value
  this._value = value
}
```

这样做的意义在于，新的 Priority 类可以容纳更多的业务行为——无论是新的业务代码，还是从别处搬移过来的，下面是一些比较逻辑。

```javascript
class Priority...
constructor(value) {
  if (value instanceof Priority) return value
  if (Priority.legalValues().includes(value))
    this._value = value
  else
    throw new Error(`<${value}> is invalid for Priority`)
  this._value = value
}

toString() {return this._value}
// 确保 index 值不可修改
get _index() {return Priority.legalValues().findIndex(s => s === this._value)}
static legalValues() {return ['low', 'normal', 'high', 'rush']}

equals(other) {return this._index === other._index}
higherThan(other) {return this._index > other._index}
lowerThan(other) {return this._index < other._index}

// 客户端
highPriorityCount = orders.filter(o => o.priority.higherThan(new Priority('normal'))).length
```

### 以查询取代临时变量

**动机**

临时变量的一个作用是保存某段代码的返回值，以哦便在函数的后面部分使用它。临时变量允许我引用之前的值，既能解释它的含义，还能避免对代码进行重复计算。但尽管使用变量很方便，很多时候还是值得将它们抽取成函数。

这项函数在类中施展效果最好，因为类为待提炼函数提供了一个共同的上下文。**以查询取代临时变量**手法只是用预处理某些类型的临时变量：那些只被计算一次且之后不再被修改的变量。

**做法**

1. 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到同样的值。
2. 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它。
3. 测试。
4. 将为变量赋值的代码段提炼成函数。
5. 测试。
6. 应用**内联变量**手法移除临时变量。

**范例**

这里有一个简单的订单类

```javascript
class Order...
constructor(quantity, item) {
  this._quantity = quantity
  this._item = item
}

get price() {
  var basePrice = this._quantity * this._item.price
  var discountFactor = 0.98
  if (basePrice > 1000) discountFactor -= 0.03
  return basePrice * discountFactor
}
```

我希望吧basePrice 和 discount Factor 两个临时变量变成函数。

```javascript
class Order...
constructor(quantity, item) {
  this._quantity = quantity
  this._item = item
}

get price () {
  return this.basePrice * this.discountFactor
}

get basePrice() {
  return this._quantity * this._item.price
}

get discountFactor() {
  var discountFactor = 0.98
  if (this.basePrice > 1000) discountFactor -= 0.03
  return discountFactor
}
```

### 提炼类

**动机**

你也许听过类似这样的建议：一个类应该是一个清晰的抽象，只处理一些明确的责任，等等。但在实际工作中，随着责任不断增加，这个类会变得过于复杂。

如果类太大，类中的某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示你应该将它们分离出去。另一个往往在开发后期出现的信号是类的子类化方式。

**做法**

1. 决定如何分解类所负的责任。
2. 创建一个新的类，用以表现从旧类中分离出来的责任。
3. 构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系。
4. 对于你想搬移的字段，运用**搬移字段**搬移之。每次更改后进行测试。
5. 使用**搬移函数**将必要函数搬移到新类。先搬移较低层函数(也就是多次被其他函数调用)。每次更改后进行测试。
6. 检查两个类的接口，去掉不再需要的函数。
7. 决定是否公开新的类。如果确实需要，考虑对新类应用**将引用对象改为值对象**使其成为一个值对象。

**范例**
我们从一个简单的 Person 类开始

```javascript
class Person...
get name() {return this._name}
set name(arg) {this._name = arg}
get telephoneNumber() {return `(${this.officeAreaCode}) ${this.officeNumber}`}
get officeAreaCode() {return this._officeAreaCode}
set officeAreaCode(arg) {this._officeAreaCode = arg}
get officeNumber() {return this._officeNumber}
set officeNumber(arg) {this._officeNumber = arg}
```

这里，我可以将与电话号码相关的行为分离到一个独立的类中。

```javascript
class Person...
constructor() {
  this._telephoneNumber = new TelephoneNumber()
}

get telephoneNumber() {return this._telephoneNumber.toString()}

get officeAreaCode() {return this._telephoneNumber._areaCode}
set officeAreaCode(arg) {this._telephoneNumber._areaCode = arg}
get officeNumber() {return this._telephoneNumber.number}
set officeNumber(arg) {this._telephoneNumber.number = arg}

class TelephoneNumber...
toString() {return `(${this.areaCode}) ${this.number}`}
get areaCode() {return this._areaCode}
set areaCode(ary) {this._areaCode = arg}

get number() {return this._number}
set number(arg) {this._number = arg}
```

### 内联类

**动机**

内联类正好与提炼类相反，如果一个类不再提供足够责任，不再有单独存在的理由(通常是因为重构动作移走了这个类的责任)，我就会将这个类塞进另一个类中。

应用这个手法的拎一个场景是，我手头有两个类，想重新安排它们肩负的责任，并让它们产生关联。

**做法**

1. 对于待内联类(源类)中所有的 public 函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类。
2. 修改源类 public 方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试。
3. 将源类中的函数和数据全部搬移到目标类，每次修改后进行测试，知道源类变成空壳。
4. 删除源类。

**范例**

下面这个类存储了一次物流运输的若干跟踪信息。

```javascript
class TrackingInformation {
  get shippingCompany() {return this._shippingCompany}
  set shippingCompany(arg) {this._shippingCompany = arg}
  get trackingNumber() {return this._trackingNumber}
  set trackingNumber(arg) {this._trackingNumber = arg}
  get display() {
    return `${this.shippingCompany}: ${this.trackingNumber}`
  }
}

// 它作为 Shipment 类的一部分被使用。
class Shipment...
get trackingInfo() {
  return this._trackingInformation.display
}
get trackingInformation() {return this._trackingInformation}
set trackingInformation(aTrackingInformation) {
  this._trackingInformation = aTrackingInformation
}

// 调用方
aShipment.trackingInformation.shippingCompany = request.vendor
```

变为

```javascript
class Shipment...
get trackingInfo() {
  return `${this.shippingCompany}: ${this.trackingNumber}`
}
get shippingCompany() {return this._shippingCompany}
set shippingCompany(arg) {this._shippingCompany = arg}
get trackingNumber() {return this._trackingNumber}
set trackingNumber(arg) {this._trackingNumber = arg}
```

### 隐藏委托关系

**动机**

一个好的模块化设计，“封装”即使不是其最关键特征，也是最关键特征之一。如果某些客户端先通过服务对象的字段得到另一个对象(受托类)，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一受托类修改了接口，变化会别波及通过服务对象使用它的所有客户端。我可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，从而去除这种依赖。

**做法**

1. 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数。
2. 调整客户端，令它只调用服务对象提供的函数。每次调整后运行测试。
3. 如果将来不再有任何客户端需要取用受托类，便可移除服务对象中的相关访问函数。
4. 测试。

**范例**

本例从两个类开始，代表‘人’的 Person 和代表‘部门’的 Department。

```javascript
class Person...
constructor(name) {
  this._name = name
}
get name() {return this._name}
get department() {return this._department}
set department(arg) {this._department = arg}

class Department...
get chargeCode() {return this._chargeCode}
set chargeCode(arg) {this._chargeCode = arg}
get manager() {return this._manager}
set manager(arg) {this._manager = arg}

// 有些客户端希望知道某人的经理是谁，为此，它必须先取得 Department 对象
// 客户端代码
manager = aPerson.department.manager
```

此时如果对客户隐藏 Department 可以减少耦合

```javascript
class Person...
get manager() {return this._department.manager}

// 客户端代码
manager = aPerson.manager
```

只要完成了对 Department 所有函数的修改，并相应修改了 Person 的所有客户端，我就可以给移除 Person 中的 department 访问函数了。

### 移除中间人

**动机**

在**隐藏委托关系**的重构手法中。如果每次客户端要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数，随着受托类的特性越来越多，服务类完全变成了一个中间人，此时就应该让客户直接调用受托类。

很难说什么程度的隐藏才是合适的，还好，有了隐藏委托关系和删除中间人，我大可不必操心这个问题。

**做法**

1. 为受托对象创建一个取值函数。
2. 对于每个委托函数，让其客户端转为连续的访问函数调用，每次替换后运行测试。

**范例**

我又要从一个 Person 类开始了，这个类通过维护一个部门对象来决定某人的经理是谁。

```javascript
// 客户端代码
manager = aPerson.manager

class Person...
get manager() {return this._department.manager}

class Department...
get manager() {return this._manager}
```

此时如果有大量函数用于在 Person 对象中调用 Department 的数据，就需要移除中间人

```javascript
// 首先在 Person 中建立一个函数用于获取受托对象。
class Person...
get department() {return this._department}

// 之后注意处理每个客户端，使它们直接通过受托对象完成工作
manager = aPerson.department.manager
```

## 搬移特性

到目前为止，介绍的重构手法都是关于如何新建、移除或重命名程序的元素。此外还有一种类型的重构也很重要，就是在不同的上下文之间搬移元素。

### 搬移函数

**动机**

模块化是优秀软件设计的核心所在，好的模块化能够让我在修改程序时只需理解程序的一小部分。但我对模块设计的理解并不是一成不变的，随着我对代码的加深，我会知道哪些设计要素如何组织最为恰当。

任何函数都需要具备上下文环境才能存活，这个上下文环境可以是全局的，但它更多时候是由某种形式的模块所提供的。搬移函数最直接的一个动因是，它频繁引用其他上下文中的元素，而对自身上下文中的元素却关心甚少。此时让它去与那些更亲密的函数相会，通常能取得更好的效果。

同样，如果我在整理代码时，发现需要频繁调用一个别处的函数，我也会考虑搬移这个函数。

**做法**

1. 检查函数在当前上下文里引用的所有程序元素(包括变量和函数)，考虑是否将它们一并搬移。
2. 检查待搬移函数是否具备多态性。
3. 将函数复制一份到目标上下文中。调整函数，使它们能适应新家。
4. 执行静态检查。
5. 设法从源上下文中正确引用目标函数。
6. 修改源函数，使之成为一个纯委托函数。
7. 测试。
8. 考虑对源函数使用内联函数。

**搬移内嵌函数至顶层**

比如下面这个函数会计算一条GPS轨迹记录的总距离

```javascript
function trackSummary(points) {
  const totalTime = calculateTime()
  const totalDistance = calculateDistance()
  const pace = totalTime / 60 / totalDistance
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  }

  function calculateDistance() {
    let result = 0
    for (let i = 1; i < points.length; i++) {
      result += distance(points[i - 1], points[i])
    }
    return result
  }

  function distance(p1, p2) {...}
  function radians(degrees) {...}
  function calculateTime() {...}
}
```

我希望把 calculateDistance 函数搬移至顶层，这样我就能单独计算轨迹的距离，而不必计算出汇总报告的其他部分。

```javascript
// 将 calculateDistance 复制一份至顶层，同时把 distance 也一并搬移
function trackSummary(points) {
  const totalTime = calculateTime()
  const totalDistance = calculateDistance()
  const pace = totalTime / 60 / totalDistance
  return {
    time: totalTime,
    distance: totalDistance,
    pace: pace
  }
    
  function calculateDistance() {
    let result = 0
    for (let i = 1; i < points.length; i++) {
      result += distance(points[i - 1], points[i])
    }
    return result
  }

  function calculateTime() {...}
}

function top_calculateDistance() {
  let result = 0
  for (let i = 1; i < points.length; i++) {
    result += distance(points[i - 1], points[i])
  }
  return result

  function distance(p1, p2) {...}
  function radians(degrees) {...}
}           
```

之后我需要在原`calculateDistance`函数体内调用`top_calculateDistance`函数

```javascript
function trackSummary(points)...
function calculateDistance() {
  return top_calculateDistance(points)
}

// 测试通过后，将 top_calculateDistance 改名为 totalDistance
// 此时发现与原来的变量名相同，此时可以直接替换
// 如果不想删除变量，可以再取一个名
function trackSummary(points) {
  const totalTime = calculateTime()
  const totalDistance = calculateDistance()
  const pace = totalTime / 60 / totalDistance(points)
  return {
    time: totalTime,
    distance: totalDistance(points),
    pace: pace
  }
}
```

**范例：在类之间搬移函数**

在类之间搬移函数也是一种常见场景，下面有一个账户类

```javascript
class Account...
get bankCharge() {
  let result = 4.5
  if (this._daysOverdrawn > 0) result += this.overdraftCharge
  return result
}

get overdraftCharge() {
  if (this.type.isPremium) {
    const baseCharge = 10
    if (this.daysOverdrawn <= 7)
      return baseCharge
    else
      return baseCharge + (this.daysOverdrawn - 7) * 0.85
  }
  else
    return this.daysOverdrawn * 1.75
}
```

上面的代码根据账户类型的不同，决定不同的“透支金额计费”算法，因此，会很自然地将`overdraftCharge`函数搬移到`AccountType`类上去。

我将`overdraftCharge`函数主体复制到`AccountType`类中，并做相应调整。

```javascript
class AccountType...
// 此处传入一个 account 对象是为了以后可能要调用 account 的其他数据
overdraftCharge(account) {
  if (this.isPremium) {
    const baseCharge = 10
    if (account.daysOverdrawn <= 7)
      return baseCharge
    else
      return baseCharge + (account.daysOverdrawn - 7) * 0.85
  }
  else
    return daysOverdrawn * 1.75
}

// 完成函数复制后，再将原来的方法代之以一个委托调用
class Account...
get bankCharge() {
  let result = 4.5
  if (this._daysOverdrawn > 0) result += this.overdraftCharge
  return result
}

get overdraftCharge() {
  return this.type.overdraftCharge(this.daysOverdrawn)
}
```

### 搬移字段

**动机**

变成活动中你需要编写许多代码，为系统实现特定的行为，但往往数据结构才是一个健壮程序的根基。如果我发现数据结构已经不适应于需求，就应该马上修缮它。搬移字段的操作通常是在其他更大的改动背景下发生的。另外如果你的类进行了封装，那么会比裸数据更容易进行这个重构手法。

**做法**

1. 确保源字段已经得到了良好封装。
2. 测试。
3. 在目标对象上创建一个字段。
4. 执行静态检查。
5. 确保源对象能够正常引用目标对象。如果你没有现成的字段或方法得到目标对象，那么你可能就得在源对象里创建一个字段，用于存储目标对象。
6. 调整源对象的访问函数，令其使用目标对象的字段。
7. 测试。
8. 移除源对象上的字段。
9. 测试。

**范例**

下面这个例子中`Customer`类代表一位 ‘顾客'，`CustomerContract`代表与顾客关联的一个‘合同’。

```javascript
class Customer...
constructor(name, discountRate) {
  this._name = name
  this._discountRate = discountRate
  this._contract = new CustomerContract(dateToday())
}

get discountRate() {return this._discountRate}
becomePreferred() {
  this._discountRate += 0.03
}
apply Discount(amount) {
  return amount.subtract(amount.multiply(this._discountRatre))
}

class CustomerContract...
constructor(startDate) {
  this._startDate = startDate
}
```

此时我想将折扣率`discountRate`字段从`Custoemr`类中搬移到`CustomerContract`中。

```javascript
class CustomerContract...
constructor(startDate, discountRate) {
  this._startDate = startDate
  this._discountRate = discountRate
}
get discountRate() {return this._discountRate}
set discountRage(arg) {this._discountRage = arg}

class Customer...
constructor(name, discountRate) {
  this._name = name
  this._setDiscountRate(discountRate)
  this._contract = new CustomerContract(dateToday())
}

get discountRate() {return this._contract._discountRate}
_setDiscountRage(aNumber) {this._contract.discountRate = aNumber}
```

**搬移裸记录**
如果我要搬移的字段是裸记录，并被许多函数直接访问，那么这项重构仍然很有意义，不过情况会复杂不少。

**范例：搬移字段到共享对象**

现在，让我们看另外一个场景。还是那个代表‘账户’的`Account`类，类上有一个代表‘利率’的字段`_interestRage`

```javascript
class Account...
constructor(number, type, interestRage) {
  this._number = number
  this._type = type
  this._interestRate = interestRate
}
get interestRate() {return this._interestRage}
 
class AccountType...
constructor(nameString) {
  this._name = nameString
}
```

我希望利率字段由`AccountType`类来进行维护

```javascript
class Account...
constructor(nameString, type) {
  this._name = nameString
  this._type = type 
}
get interestRate() {return this._type.interestRage}
 
class AccountType...
constructor(nameString, interestRate) {
  this._name = nameString
  this._interestRate = interestRate 
}
get interestRate() {return this._interestRage}
```

### 搬移语句到函数

**动机**

要维护代码的健康发展，要遵循几条黄金法则，其中最重要的一条当属“消除重复”。如果我发现调用某个函数时，总有一些相同代码也需要每次执行，那么我会考虑将此段代码合并到函数里。如果某些语句与一个函数放在一起更像一个整体，那我也会将语句搬移到函数里。

**做法**

1. 如果重复代码段离调用目标函数的地方还有些距离，则先用移动语句将它们弄懂到紧邻目标函数的位置。
2. 如果目标函数只被一个源函数调用，只需将源函数的重复代码剪切粘贴到目标函数中即可。
3. 如果函数不止一个调用点，则先将其中一个调用点应用提炼函数将待搬移的语句和目标函数一起提炼成一个新函数。给新函数取个临时的易于搜索的名字。
4. 调整函数的其他调用点，令它们调用新提炼的函数。每次调整之后运行测试。
5. 完成所有引用点的替换后，应用内联函数将目标函数内联到新函数中，并移除原目标函数。
6. 对新函数应用函数改名，将其改名为目标函数的名字。

**范例**

以下代码会生成一些关于相片的 HTML

```javascript
function renderPerson(outStream, person) {
  const result = []
  result.push(`<p>${person.name}</p>`)
  result.push(renderPhoto(person.photo))
  result.push(`<p>title: ${person.photo.title}</p>`)
  result.push(emitPhotoData(person.photo))
  return result.join('/n')
}

function photoDiv(p) {
  return [
    '<div>',
    `<p>title: ${p.title}</p>`,
    emitPhotoData(p),
    '</div>'
  ]
}

function emitPhotoData(aPhoto) {
  const result = []
  result.push(`<p>location: ${aPhoto.location}</p>`)
  result.push(`<p>date: ${aPhoto.data.toDateString()}</p>`)
  return result.join('/n')
}
```

这个例子中`emitPhotoData`函数中有两个调用点，每个调用点的前面都有一行类似的重复代码，用于打印与标题有关的信息。我会选择一个调用点，对其应用提炼函数，除了要搬移的语句，我还把`emitPhotoData`函数一起提炼到新函数中。

```javascript
function photoDiv(p) {
  return [
   '<div>',
   zznew(p),
   '</div>'
  ].join('/n')
}

function zznew(p) {
  return [
    '<p>title: ${p.title}</p>',
    emitPhotoData(p),
  ].join('/n')
}

// 之后将其它调用点一并替换成对新函数的调用
function renderPerson(outStream, person) {
  const result = []
  result.push(`<p>${person.name}</p>`)
  result.push(renderPhoto(person.photo))
  result.push(zznew(person.photo))
  return result.join('/n')
}
```

替换完之后，用内联函数将`emitPhotoData`函数内联到新函数中

```javascript
function zznew(p) {
  return [
    `<p>title: ${p.title}</p>`,
    `<p>location: ${aPhoto.location}</p>`,
    `<p>date: ${aPhoto.data.toDateString()}</p>`
  ].join('/n')
}
```

最后将新提炼的函数`zznew`改为`emitPhotoDate`即可

### 搬移语句到调用者

**动机**

程序抽象能力的源泉来自于函数。但随着系统能力发生演进，原先设定的抽象边界总会悄无声息地发生偏移，对于函数来说这样的边界偏移意味着曾经一个整体，一个单元的行为，如今可能已经分化出两个甚至是多个不同的关注点。

函数边界发生偏移的一个征兆是，以往多个地方共用的欣慰，如今需要在某些调用点面前表现出不同的行为。于是我们得把表现不同的行为从函数里挪出，并搬移到其调用处。

**做法**

1. 最简单的情况下，原函数非常简单，其调用者只有一两个，此时只要复制粘贴即可。
2. 如果调用点不止一两个，则需要先用**提炼函数**将你不想搬移的代码提炼成一个新函数，函数名可以临时起一个，只要后续容易搜索即可。
3. 对原函数应用**内联函数**。
4. 对提炼出的函数应用改变**函数声明**，令其与原函数使用同一个名字，如果有更好的名字也可以用。

**范例**
`emitPhotoData`是一个函数，在两处地方被调用。

```javascript
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`)
  renderPhoto(outStream, person.photo)
  emitPhotoData(outStream, person.photo)
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n")
      emitPhotoData(outStream, p)
      outStream.write("</div>\n")
    })
}

function emitPhotoData(outStream, photo) {
  outStream.write(`<p>title: ${person.title}</p>\n`)
  outStream.write(`<p>date: ${person.date.toDateString()}</p>\n`)
  outStream.write(`<p>location: ${person.location}</p>\n`)
}
```

此时我想修改支持`listRecentPhotos`函数以不同方式渲染相片的`location`信息，而`renderPerson`的行为则保持不变。

```javascript
// 首先提炼函数，把最总希望留在 emitPhotoData 的函数语句先提炼出去
function emitPhotoData(outStream, photo) {
  zztmp(outStream, photo)
  outStream.write(`<p>location: ${person.location}</p>\n`)
}

function zztmp(outStream, photo) {
  outStream.write(`<p>title: ${person.title}</p>\n`)
  outStream.write(`<p>date: ${person.date.toDateString()}</p>\n`)
}
```

之后将所有`emitPhotoData`函数的调用点使用**内联函数**

```javascript
function renderPerson(outStream, person) {
  outStream.write(`<p>${person.name}</p>\n`)
  renderPhoto(outStream, person.photo)
  zztmp(outStream, photo)
  outStream.write(`<p>location: ${person.location}</p>\n`)
}

function listRecentPhotos(outStream, photos) {
  photos
    .filter(p => p.date > recentDateCutoff())
    .forEach(p => {
      outStream.write("<div>\n")
      zztmp(outStream, photo)
      outStream.write(`<p>location: ${person.location}</p>\n`)
      outStream.write("</div>\n")
    })
}
```

之后将`zztmp`改名为原函数名字`emitPhotoData`，完成本次重构。

### 移动语句

**动机**

让存在关联的东西一起出现，可以使代码更容易理解。如果有几行代码取用了同一个数据结构，那么最好是让它们一起出现，而不是夹杂在取用其他数据结构的代码中间。

**做法**

1. 确定带移动的代码片段应该搬往何处。仔细检查带移动片段与目的地之间的语句，看看搬移后是否会影响这些代码的正常工作，如果会，则放弃这项重构。
2. 剪切源代码片段，粘贴到上一步选定的位置上。
3. 测试。

**范例**

移动代码片段时，通常需要想清楚两件事：本次调整的目标是什么，以及该目标能否达到。有以下代码片段：

```javascript
let result
if (availableResources.length === 0) {
  result = createResource()
  allocatedResources.push(result)
} else {
  result = availableResources.pop()
  allocatedResources.push(result)
}
return result
```

变为

```javascript
let result
if (availableResources.length === 0) {
  result = createResource()
} else {
  result = availableResources.pop()
}
allocatedResources.push(result)
return result
```

### 拆分循环

**动机**

你常常能见到一些身兼多职的循环，它们一次做了两三件事情，就为了只循环一次。如果能够将循环拆分，让一个循环只做一件事情，那就能确保每次修改时只理解要修改的那部分代码。

拆分循环还能让每个循环更容易使用，如果循环做了太多件事，那就只得返回结构型数据或通过局部变量传值了。

这项手法可能慧染很多程序员感到不安，因为它迫使你执行多次循环。对此我的建议还是：先进行重构，然后在进行性能优化，如果重构之后该循环确实成为了性能瓶颈，届时再把拆开的循环合到一起也很容易。但实际情况是，循环本身很少成为性能瓶颈。

**做法**

1. 复制一遍循环代码。
2. 识别并移除循环中的重复代码，使每个循环只做一件事。
3. 测试。

**范例**
下面一段循环会计算需要支付给所有员工的总薪水，并计算出最年轻员工的年龄：

```javascript
let youngest = people[0] ? people[0].age : Infinity
let totalSalary = 0
for (const p of people) {
  if (p.age < youngest) youngest = p.age
  totalSalary += p.salary
}

return `youngestAge: ${youngest}, totalSalary: ${tatalSalary}`
```

复制一边循环并删除重复的计算逻辑

```javascript
let youngest = people[0] ? people[0].age : Infinity
let totalSalary = 0
for (const p of people) {
  totalSalary += p.salary
}

for (const p of people) {
  if (p.age < youngest) youngest = p.age
}

return `youngestAge: ${youngest}, totalSalary: ${tatalSalary}`
```

拆分循环这个手法本身的内容就结束了，但本手法的意义不仅在于此，它还为进一步优化提供了良好的起点。

```javascript
let youngest = people[0] ? people[0].age : Infinity
return `youngestAge: ${youngestAge()}, totalSalary: ${totalSalary()}`

function totalSalary() {
  let totalSalary = 0
  for (const p of people) {
    totalSalary += p.salary
  }
  return totalSalary
}

function youngestAge() {
  let youngest = prople[0] ? people[0].age : Infinity
  for (const p of people) {
    if (p.age < youngest) youngest = p.age
  }
  return youngest
}
```

进一步优化

```javascript
function totalSalary() {
  return people.reduce((total, p) => total + p.salary, 0)
}

function youngestAge() {
  return Math.min(...people.map(p => p.age))
}
```

### 以管道取代循环

**动机**

时代在发展，有一种比循环更好的语言结构来处理迭代过程，这种结构就叫做**集合管道**。它有时会让代码段可读性更强。

**做法**

1. 创建一个新变量，用以存放参与循环过程的集合。
2. 从循环顶部开始，将循环里的每一块行为一次搬移出来，在上一步创建的集合变量上用一种管道替换替代之。每次修改后运行测试。
3. 搬移完循环里的全部行为后，将循环整个删除。

**范例**

我们有一个 CSV 文件，里面存放着各个办公室的一些数据

```javascript
office, country, teletphohe
Chicago, USA, +1 312 373 1000
Beiging, China, +86 4008 900 505
Bangalore, India, +91 80 4064 9570
Porto Alegre, Brazil, +55 51 3079 3550
Chennai, India, +91 44 660 44766

// 下面这个函数用于从数据中筛选出印度的所有办公室，并返回办公室所在城市信息和联系电话
function acquireData(input) {
  const lines = input.split('\n')
  let firstLine = true
  const result = []
  for (const line of lines) {
    if (firstLine) {
      firstLine = false
      continue
    }
    if (line.trim() === '') continue
    const record = line.split(',')
    if (record[1].trim() === 'India') {
      result.push({city: record[0].trim(), phone: record[2].trim()})
    }
  }
  return result
}
```

之后改为

```javascript
function acquireData(input) {
  const lines = input.split('/n')
  return lines
    .slice  (1)
    .filter (line => line.trim() !== '')
    .map    (line => line.split(','))
    .filter (fields => fields[1].trim() === 'India')
    .map    (fields => ({city: record[0].trim(), phone: record[2].trim()}))
}
```

### 移除死代码

**动机**

当你尝试阅读代码时，无用代码会带来很多额外的思维负担，所以一旦代码不再被使用，我们就应该删除它，可能以后又会需要这段代码，我也可以从版本控制系统里再次将它翻找出来。

**做法**

1. 如果四代码可以从外部直接引用，比如它是一个独立的函数，先查找一下有无调用点。
2. 将死代码移除。
3. 测试。

## 重新组织数据

数据结构在程序中扮演着重要的角色，我有一组重构手法专门用于数据结构的组织。将一个值用于多个不同的用途，这就是催生混乱和 bug 的温床。

### 拆分变量

**动机**

变量有各种不同的用途，其中某些用途会很自然地导致临时变量被多次赋值。“循环变量”和“结果收集变量“就是两个典型例子：循环变量即为 for 循环中的 i；结果收集变量则将”通过整个函数的运算“而构成的某个值收集起来。

**做法**

1. 在待分解变量的声明及第一次被赋值处，修改其名称。
2. 如果可能，将新的变量声明为不可修改。
3. 以该变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量。
4. 测试
5. 重复上述过程，每次都在声明处对变量改名，并修改下次赋值之前的引用，直至到达最后一处赋值。

**范例**

下面我要计算一个苏格兰布丁运动的距离

```javascript
function distanceTravelled(scenario, time) {
  let result
  let acc = scenario.primaryForce / scenario.mass
  let primaryTime = Math.min(time, scenario.delay)
  result = 0.5 * acc * primaryTimr * primaryTime
  let secondaryTime = time - scenario.delay
  if (secondaryTime > 0) {
    let primaryVelocity = acc * scenario.delay
    acc = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass
    result += primaryVelocity * secondaryTimr + 0.5 * acc * secondaryTime * secondaryTime
  }
  return result
}
```

上面代码真是丑陋。`acc`变量有两个责任：第一是保存第一个力造成的初始加速度，第二是保存两个力共同造成的加速度。将`acd`以两个变量替换。

```javascript
function distanceTravelled(scenario, time) {
  let result
  let primaryAcceleration = scenario.primaryForce / scenario.mass
  let primaryTime = Math.min(time, scenario.delay)
  result = 0.5 * acc * primaryTimr * primaryTime
  let secondaryTime = time - scenario.delay
  if (secondaryTime > 0) {
    let primaryVelocity = acc * scenario.delay
    const secondaryAcceleration = (scenario.primaryForce + scenario.secondaryForce) / scenario.mass
    result += primaryVelocity * secondaryTimr + 0.5 * secondaryAcceleration * secondaryTime * secondaryTime
  }
  return result
}
```

### 字段改名

**动机**

命名很重要，对于程序中广泛使用的记录结构，其中字段的命名格外重要。

**做法**

1. 如果记录对作用域较小，可以直接修改所有该字段的代码，然后测试。
2. 如果记录还未封装，请先封装。
3. 在对象内部对私有字段改名，对应调整内部访问该字段的函数。
4. 测试。
5. 如果构造函数的参数使用了旧的字段名，运用**改变函数声明**将其改名。
6. 运用**函数改名**给访问函数改名

**范例：给字段改名**

先从一个常量开始

```javascript
const organization = {name: 'Acme Gooseberries', country: 'GB'}

// 先进行封装
class Organization {
  constructor (data) {
    this._name = data.name
    this._country = data.country
  }
  get name() {return this._name}
  set name(aString) {this._name = aString}
  get country() {return this._country}
  set country(aCountryCode) {this._country = aCountryCode}
}
const organization = new Organization({name: 'Acme Gooseberries', country: 'GB'})
```

现在，记录结构已经被封装成类。在对字段改名时，有4个地方需要留意：取值函数、设值函数、构造函数以及内部数据结构。我现在可以分别修改这4处，小步修改意味着每一步出错的可能性大大减少。

```javascript
class Organization {
  constructor (data) {
    // 先修改构造函数中的值。现在既可以使用 name 也可以使用 title
    this._title = (data.title !== undefined) ? data.title : data.name
    this._country = data.country
  }
  // 设值取值都返回修改后的值
  get name() {return this._title}
  set name(aString) {this._title = aString}
  get country() {return this._country}
  set country(aCountryCode) {this._country = aCountryCode}
}
```

接下来就可以在构造函数中使用 title 字段

```javascript
// 修改为新字段
const organization = new Organization({title: 'Acme Gooseberries', country: 'GB'})
// 之后查看所有调用构造函数的地方，改为新名
class Organization {
  constructor (data) {
    this._title = data.title
    this._country = data.country
  }
  // 接下来改名访问函数和设值函数
  get title() {return this._title}
  set title(aString) {this._title = aString}
  get country() {return this._country}
  set country(aCountryCode) {this._country = aCountryCode}
}
```

### 以查询取代派生变量

**动机**

可变数据是软件中最大的错误源头之一。对数据的修改常常导致代码段各个部分以丑陋的方式互相耦合：在一处修改数据，却在另一处造成难以发现的破坏，完全去掉可变数据并不现实，但我还是强烈建议：精良吧可变数据的作用域限制在最小范围。

**做法**

1. 识别出所有对变量做更新的地方。如有必要可使用**拆分变量**。
2. 新建一个函数，用于计算该变量的值。
3. 用引入断言断言该变量和计算函数始终给出同样的值。
4. 测试。
5. 修改读取该变量的代码，令其调用新建的函数。
6. 测试。
7. 用**移除死代码**去掉变量的声明和赋值。

**范例**

下面这个例子虽小，却完美展示了代码的丑陋。

```javascript
class ProductionOPlan...
get production() {return this._production}
applyAdjustment(anAdjustment) {
  this._adjustments.push(anAdjustment)
  this._production += anAdjustment.amount
}
```

我可以对`production`进行即时计算

```javascript
class ProductionOPlan...
get production() {return this.calculatedProduction}
get calculatedProduction() {
  return this._adjustments
    .reduce((sum, a) => sum + a.amount, 0)
}
```

之后用**内联函数**将计算逻辑内联到`production`函数内

```javascript
class ProductionOPlan...
get production() {
  return this._adjustments
    .reduce((sum, a) => sum + a.amount, 0)
}
applyAdjustment(anAdjustment) {
  this._adjustments.push(anAdjustment)
}
```

### 将引用对象改为值对象

**动机**

在把一个对象嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可被视为值对象。两者最明显的差异在于如何更新内部对象的属性：如果将内部对象视为引用对象，在更新其属性时，我会保留原对象不变，更行内部对象的属性；如果将其视为值对象，我就会替换整个内部对象，新换上的对象会有我想要的属性值。

一般来说，不可变的数据结构处理起来更容易，我可以放心地把不可变的数据值传给程序的其他部分，而不必担心对象中包装的数据被偷偷修改。值对象在分布式系统和并发系统中尤为有用。

如果我想在几个对象之间共享一个对象，以便几个对象都能看见对共享对象的修改，那么这个共享的对象就应该是引用。

**做法**

1. 检查重构目标是否为不可变对象，或是否可修改为不可变对象。
2. 用**移除设值函数**注意去掉所有设值函数。
3. 提供一个基于值的相等性判断函数，在其中使用值对象字段。

**范例**

设想一个代表“人”的`Person`类，其中包含一个代表“电话号码”的`Telephone Number`对象

```javascript
class Person...
constructor() {
  this._telephoneNumber = new TelephoneNumber()
}
// 可以看到类中仍然有一些函数在修改新对象的属性
get officeAreaCode() {return this._telephoneNumber.areaCode}
set officeAreaCode(arg) {this._telephoneNumber.areaCode = arg}
get officeNumber() {return this._telephoneNumber.number}
set officeNumber(arg) {this._telephoneNumber.number = arg}

class TelephoneNumber...
get areaCode() {return this._areaCode}
set areaCode(arg) {this._areaCode = arg}
get number() {return this._number}
set number(arg) {this._number = arg}
```

先把`TelephoneNumber`类变为不可变的。

```javascript
class TelephoneNumber...
constructor(areaCode, number) {
  this._areaCode = areaCode
  this._number = number
}

class Person...
get officeAreaCode() {return this._telephoneNumber.areaCode}
set officeAreaCode(arg) {this._telephoneNumber = new TelephoneNumber(arg, this.officeNumber)}
get officeNumber() {return this._telephoneNumber.number}
set officeNumber(arg) {this._telephoneNumber = new TelephoneNumber(this.officeAreaCode, arg)}
```

现在，`TelephoneNumber`类已经是不可变的类，可以将其变成真正的值对象了。可以创建自己的`equal`函数用于值的相等性判断。

```javascript
class TelephoneNumber...
equals(other) {
  if (!(other instanceof TelephoneNumber)) return false
  return this.areaCode === other.areaCode && this.number === other.number
}

// 进行测试
it('telephone equals', function() {
  assert(new TelephoneNumber('312', '55-0142').equals(new TelephoneNumber('312', '55-0142')))
})
```

### 将值对象改为引用对象

**动机**

一个数据结构可能包含多个记录，而这些记录都关联到同一个逻辑数据结果。把值对象改为引用对象会带来以恶搞结果：对于一个客观实体，只有一个代表它的对象，只为某个实体创建一次对象，以后始终从仓库中获取该对象。

**做法**

1. 为相关对象创建一个仓库
2. 确保构造函数有办法找到关联对象的正确实例
3. 修改宿主对象的构造函数，令其从长苦衷获取关联对象，每次修改后执行测试。

**范例**

我将从一个代表“订单”的`Order`类开始，其实例对象从一个`JSON`文件创建，用来创建订单数据中有一个顾客`customer`ID，我们用它来进一步创建`Customer`对象。

```javascript
class Order...
constructor(data) {
  this._number = data.number
  this._customer = new Customer(data.customer)
}
get customer() {return this._customer}

class Customer...
constructor(id) {
  this._id = id
}
get id() {return this._id}
```

这种方式创建的`Customer`是值对象。如果有5个订单都属于ID为123的顾客，就会有5个独自的`Customer`对象。对其中一个的修改，不会反映在其他几个对象上。如果我想增强`Customer`对象，比如接受了更多关于客户的信息，我就必须用同样的数据更新所有5个对象。

如果我每次都使用同一个`Customer`对象，那么就需要有一个地方存储这个对象。最简单的情况下，我会使用一个仓库对象。

```javascript
let _repositoryData

export function initialize() {
 _repositoryData = {}
 _repositoryData.customers = new Map()
}

export function registerCustomer(id) {
  if (!_repositoryData.customers.has(id))
   _repositoryData.customers.set(id, new Customer(id))
  return findCustomer(id)
}

export function findCustomer(id) {
  return _repositoryData.customers.get(id)
}
```

仓库对象根据ID注册顾客，并且对于一个ID只会创建一个`Customer`对象。有了仓库对象，我就可以修改`Order`对象的构造函数来使用它。

```javascript
class Order...
constructor(data) {
  this._number = data.number
  this._customer = _repositoryData(data.customer)
}
get customer() {return this._customer}
```

上面的代码还有一个问题：构造函数与一个全局的仓库对象耦合。如果想解决这个问题，可以将仓库对象作为参数传递给构造函数。

## 简化条件逻辑

程序的大部分威力来自条件逻辑，但是程序的复杂度也大多来自条件逻辑。

### 分解条件表达式

**动机**

程序之中，复炸的条件逻辑是最常导致复杂度上升的地点之一，我必须编写代码来检查不同的条件分支，更具不同条件做不同的事，然后我就会得到一个相当长的函数。大型函数本身就会使代码的可读性下降，而条件逻辑会使代码更难阅读。

和任何大块头代码一样，我可以将它分解成多个独立的函数，将每个分支条件分解成新函数还可以带来更多好处：可以突出条件逻辑，更清楚的表明每个分支的作用，并且突出每个分支的原因。

**做法**

1. 对条件判断和每个条件分支分别运用**提炼函数**手法。

**范例**

假设我要计算购买某样商品的总价（总价 = 数量 * 单价），而这个商品在冬季和夏季的单价是不同的。

```javascript
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
  charge = quantity * plan.summerRage
else
  charge = quantity * plan.regularRage + plan.regularServiceCharge
```

我把条件判断提炼到一个独立的函数中，然后提炼条件判断真和假的分支

```javascript
if (summer())
  charge = summerCharge()
else
  charge = regularCharge()

function summer () {
  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)
}
function summerCharge() {
  return quantity * plan.summerRage
}
function regularCharge() {
  return quantity * plan.regularRage + plan.regularServiceCharge
}
```

提炼完成后，可以用三元运算符重新安排条件语句

```javascript
charge = summer() ? summerCharge() : regularCharge()
```

### 合并条件表达式

**动机**

有时我会发想这样一串条件检查：检查条件各不相同，最终行为却一致。如果发现这种情况，就应该使用“逻辑或”和“逻辑与”将它们合并为一个条件表达式。这样做有两个好处：第一是使这一次条件检查的用意更清晰，第二是这项重构往往可以为使用**提炼函数**做准备。

**做法**

1. 确定这些条件表达式都没有副作用。
2. 使用适当的逻辑运算符，将两个相关条件表达式合并成一个。
3. 测试。
4. 重复前面的合并过程，直到所有相关的条件表达式都合并到一起。
5. 可以考虑对合并后的条件表达式实施提炼函数。

**范例**

有下面一段代码

```javascript
function disabilityAmount(anEmployee) {
  if (anEmployee.seniority < 2) return 0
  if (anEmployee.monthsDisabled > 12) return 0
  if (anEmployee.isPartTime) return 0
}
```

上面有一连串的条件检查，都指向同样的结果，既然结果是相同的，就应该把这些条件检查合并成一条表达式。对于这样顺序执行的条件检查，可以用逻辑或运算符来合并。

```javascript
function disabilityAmount(anEmployee) {
  if (isNotEligableForDiasblility()) return 0
}

function isNotEligableForDisability () {
 return ((anEmployee.seniority < 2)
          || (anEmployee.monthsDisabled > 12)
          || (anEmployee.isPartTime))
}
```

**范例：使用逻辑与**

上面的例子展示了用逻辑或合并条件表达式的做法，不过我有可能遇到需要逻辑与的情况。

```javascript
if (anEmployee.onVacation)
  if (anEmployee.seniority > 10)
    return 1
return 0.5
```

使用逻辑与运算符将其合并

```javascript
if ((anEmployee.onVacation) && (anEmployee.seniority > 10)) return 1
return 0.5
```

### 以卫语句取代嵌套条件表达式

**动机**

根据我的经验，条件表达式通常有两种风格。第一种风格是：两个条件分支都属于正常行为。第二种风格是：只有一个条件分支是正常行为，另一个分支则是异常的情况。

这两类条件表达式有不同的用途，这一点应该通过代码表现出来。如果两个分支都是正常行为，就应该使用形如`if...else...`的条件表达式，如果某个条件极其罕见，就应该单独检查该语句，并在该条件为真时立刻从函数中返回。这样的单独检查常常被成为*卫语句*。

以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。如果使用`if-then-else`结构，你对`if`和`else`的重视是同等的，卫语句就不同了，它告诉阅读者：这种情况不是本函数的核心逻辑所关心的，如果它发生了，请做一些必要的整理工作，然后退出。

**做法**

1. 选中最外层需要被替换的条件逻辑，将其替换为卫语句。
2. 测试。
3. 有需要的话，重复上述步骤。
4. 如果所有卫语句都引发相同的结果，可以使用合并条件表达式合并。

**范例**

下面的代码用于计算要支付给员工的工资，只有还在公司上班的员工才需要支付工资，所以这个函数需要检查两种“员工已经不在公司上班”的情况。

```javascript
function payAmount (employee) {
  let result
  if (employee.isSeparated) {
    result = {amount: 0, reasonCode: 'SEP'}
  } else {
    if (employee.isRetired) {
      result = {amount: 0, reasonCode: 'RET'}
    } else {
      // 计算账单的逻辑
      lorem.ipsum(dolor.ditAmet)
      consectetur(adipiscing).elit()
      sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua)
      ut.enim.ad(minim.veniam)
      result = someFinalComputation()
    }
  }
  return result
}
```

嵌套的条件逻辑让我们看不清代码真实的含义。只有当前两个条件表达式都不为真的时候，这段代码才真正开始它的主要工作。所以，卫语句能让代码更清晰地阐述自己的意图。

```javascript
function payAmount (employee) {
  if (employee.isSeparated) return {amount: 0, reasonCode: 'SEP'}
  if (employee.isRetired) return {amount: 0, reasonCode: 'RET'}
  // 计算账单的逻辑
  lorem.ipsum(dolor.ditAmet)
  consectetur(adipiscing).elit()
  sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua)
  ut.enim.ad(minim.veniam)
  return someFinalComputation()
}
```

**范例：讲条件反转**

我们常常可以将条件表达式反转，从而实现*以卫语句取代嵌套条件表达式*。

```javascript
function adjustedCapital(anInstrument) {
  let result = 0
  if (anInstrument.capital > 0) {
    if (anInstrument.capital > 0 && anInstrument.duration > 0) {
      result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor
    } 
  }
  return result
}
```

同样的，我逐一进行替换，不过这次在插入卫语句时，我需要将相应的条件反转过来：

```javascript
function adjustedCapital(anInstrument) {
  let result = 0
  if (anInstrument.capital <= 0) return result
  if (anInstrument.capital <= 0 || anInstrument.duration <= 0) return result
  result = (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor
  return result
}
```

两条语句引发的结果一样，所以我可以使用合并条件表达式将其合并

```javascript
if (anInstrument.capital <= 0 ||
    anInstrument.capital <= 0 || 
    anInstrument.duration <= 0) return result
```

此时`result`为一个可变变量，我可以彻底移除它避免承担两份责任。

```javascript
function adjustedCapital(anInstrument) {
  if (anInstrument.capital <= 0 ||
    anInstrument.capital <= 0 || 
    anInstrument.duration <= 0) return 0
  return (anInstrument.income / anInstrument.duration) * anInstrument.adjustmentFactor
}
```

### 以多态取代条件表达式

**动机**

很多时候，我发现可以将条件逻辑拆分到不同的场景（或者叫高阶用例），从而拆解复杂的条件逻辑额。这种拆分有时用条件逻辑本身的结构就足以表达，但是用类和多态能把逻辑的拆分表述地更清晰。

一个常见的场景是：我可以构造一组类型，每个类型处理各自的一种条件逻辑。例如，图书、音乐、食品的处理方式不同，这是因为它们分属不同类型的商品。

另一种情况是：有一个基础逻辑，在其上又有一些变体。基础逻辑可能是最常用的，也可能是最简单的。我可以把基础逻辑放进超类，这样我就可以首先理解这部分逻辑，展示不管各种变体，然后我可以把每种变体逻辑单独范进一个子类，其中的代码着重强调与基础逻辑的差异。

多态是面向对象编程的关键特性之一，跟其他一切有用的特性一样，它也很容易被滥用，但如果发现如前所述的复杂条件逻辑，多态是改善这种情况的有力工具。

**做法**

1. 如果现有的类尚不具备多态行为，就用工厂函数创建，令工厂函数返回恰当的对象实例。
2. 在调用方代码中使用工厂函数获得对象实例。
3. 将带有条件逻辑的函数移到超类中。
4. 任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整。
5. 重复上述过程，处理其他条件分支。
6. 在超类函数中保留默认情况的逻辑。或者，如果超类是抽象的，就把该函数声明为`abstract`，或在其中直接抛出异常，表明计算责任都在子类中。

**范例**

我们写了一小段程序来判断一群鸟飞得有多快，以及它们的羽毛是什么样的。

```javascript
function plumages(birds) {
  return new Map(birds.map(b => [b.name, plumage(b)]))
}
function speeds(birds) {
  return new Map(birds.map(b => [b.name, airSpeedVelocity(b)]))
}
function plumage(bird) {
  switch (bird.type) {
  case 'EuropeanSwallow':
    return 'average'
  case 'AfricanSwallow':
    return (bird.numberOfCoconuts > 2) ? 'tired' : 'average'
  case 'NorwegianVlueJParror': 
    return (bird.voltage > 100) ? 'scorched' : 'beautiful'
  default:
    return 'unknown'
  }
}

function airSpeedVelocity(bird) {
  case 'EuropeanSwallow':
    return 35
  case 'AfricanSwallow':
    return 40 - 2 * bird.numberOfCoconuts
  case 'NorwegianVlueJParror': 
    return (bird.isNailed) ? 0 : 10 + bird.voltage / 10
  default:
    return null
  }
}
```

有两个不同的操作，其行为都随着*鸟的类型*来变化，因此可以创建出对应的类，用多态来处理各类型特有的行为。

```javascript
function plumage(bird) {
  return new Bird(bired).plumage
}

function airSpeedVelocity(bird) {
  return new Bird(bird).airSpeedVelocity
}

class Bird {
  constructor(birdObject) {
    Object.assign(this, birdObject)
  }
  get plumage () {
    switch (bird.type) {
  	case 'EuropeanSwallow':
    	return 'average'
  	case 'AfricanSwallow':
    	return (bird.numberOfCoconuts > 2) ? 'tired' : 'average'
  	case 'NorwegianVlueJParror': 
    	return (bird.voltage > 100) ? 'scorched' : 'beautiful'
  	default:
    	return 'unknown'
  	}
  }
  get airSpeedVelocity () {
    case 'EuropeanSwallow':
      return 35
    case 'AfricanSwallow':
      return 40 - 2 * bird.numberOfCoconuts
    case 'NorwegianVlueJParror': 
      return (bird.isNailed) ? 0 : 10 + bird.voltage / 10
    default:
      return null
    }
  }
}
```

然后针对每种鸟创建一个子类，用一个工厂函数来实例化合适的子类对象

```javascript
function plumages(birds) {
  return new Map(birds.map(b => createBird(b)).map(bird => [bird.name, bird.plumage])))
}
function speeds(birds) {
  return new Map(birds.map(b => createBird(b)).map(bird => [bird.name, bird.airSpeedVelocity])))
}

function createBird(bird) {
 switch (bird.type) {
  	case 'EuropeanSwallow':
    	return new EuropeanSwallow(bird)
  	case 'AfricanSwallow':
    	return new AfricanSwallow(bird)
  	case 'NorwegianVlueJParror': 
    	return new NorwegianBlueParrot(bird)
  	default:
    	return new Bird(bird)
  	}
}

class Bird...
// 超类函数用来处理默认情况
get plumage() {
  return 'unknow'
}
get airSpeedVelocity() {
  return null
}

class EuropeanSwallow extends Bird {
  get plumage() {
    return 'average'
  }
  get airSpeedVelocity () {
    return 35
  }
}

class AfricanSwallow extends Bird {
  get plumage() {
    return (this.numberOfCoconuts > 2) ? 'tired' : 'average'
  }
  get airSpeedVelocity () {
    return 40 - 2 * bird.numberOfCoconuts
  }
}

class NorwegianVlueJParror extends Bird {
  get plumage() {
    return (this.voltage > 100) ? 'scorched' : 'beautiful'
  }
  get airSpeedVelocity () {
    return (bird.isNailed) ? 0 : 10 + bird.voltage / 10
  }
}
```

**范例：用多态处理变体逻辑**

前面例子中，‘鸟’的类型体系是一个清晰的泛化体系：超类是抽象的“鸟”，子类是各种具体的鸟，但这并不是事件中使用继承的唯一方式。实际上这种方式很可能不是最常用或最好的方式。另一种使用继承的情况是：我想表达某个对象与另一个对象大体相似，但又有一些不同之处。

下面有这样一个例子，有一家评级机构，要对远洋航船的航行进行投资凭借，这家评级机构会给出“A”或“B”两种评级，取决于多种风险和盈利潜力的因素。

```javascript
// 此函数将三个分数组合到一起，给出一次航行的综合评级
function rating(voyage, history) {
  const vpf = voyageProfitFactor(voyage, history)
  const vr = voyageRisk(voyage)
  const chr = captainHistoryRisk(voyage, history)
  if (vpf * 3 > (vr + chr * 2)) return "A"
  else return "B"
}

// 打出风险分数
function voyageRisk(voyage) {
  let result = 1
  if (voyage.length > 4) result += 2
  if (voyage.length > 8) result += voyage.length - 8
  if (['china', 'east-indies'].includes(voyage.zone)) result += 4
  return Math.max(result, 0)
}
// 打出风险因素
function captainHistoryRisk(voyage, history) {
  let result = 1
  if (history.length < 5) result += 4
  result += history.filter(v => v.profit < 0).length
  if (voyage.zone === 'china' && hasChina(history)) result -= 2
  return Math.max(result, 0)
}

function hasChina(history) {
  return history.some(v => 'china' === v.zone)
}
// 打出盈利潜力分数
function voyageProfitFactor(voyage, history) {
  let result = 2
  if (voyage.zone === 'china') result += 1
  if (voyage.zone === 'east-indies') result += 1
  if (voyage.zone === 'china' && hasChina(history)) {
    result += 3
    if (history.length > 10) result += 4
    if (voyage.length > 12) result += 1
    if (voyage.length > 18) result -= 1
  } else {
    if (history.length > 8) result += 1
    if (voyage.length > 14) result -= 1
  }
  return result
}

// 调用方代码
const voyage = {zone: 'west-indies', length: 10}
const history = [
  {zone: 'east-indies', profit: 5},
  {zone: 'west-indies', profit: 15},
  {zone: 'china', profit: -2},
  {zone: 'west-africa', profit: 7},
]

const myRating = rating(voyage, history)
```

我会用继承和多态将处理“中国因素”的逻辑从基础逻辑中分离出来。如果还要引入更多的特殊逻辑，这个重构就很有用——这些重复的“中国因素”会混淆视听，让基础逻辑难以理解。

```javascript
function rating(voyage, history) {
  return new Rating(voyage, history).value
}

class Rating {
  constructor(voyage, history) {
    this.voyage = voyage
    this.history = history
  }
  
  get value() {
    const vpf = thsi.voyageProfitFactor
    const vr = this.voyageRisk
    const chr = this.captainHistoryRisk
    if (vpf * 3 > (vr + chr * 2)) return "A"
    else return "B"
  }
  
  get voyageRisk() {
    let result = 1
    if (this.voyage.length > 4) result += 2
    if (this.voyage.length > 8) result += this.voyage.length - 8
    if (['china', 'east-indies'].includes(thisvoyage.zone)) result += 4
    return Math.max(result, 0)
  }
  
  get captainHistoryRisk() {
    let result = 1
    if (this.history.length < 5) result += 4
    result += this.history.filter(v => v.profit < 0).length
    if (this.voyage.zone === 'china' && this.hasChina(history)) result -= 2
    return Math.max(result, 0)
  }
  
  get voyageProfitFactor() {
    let result = 2
    if (this.voyage.zone === 'china') result += 1
    if (this.voyage.zone === 'east-indies') result += 1
    if (this.voyage.zone === 'china' && this.hasChina(history)) {
      result += 3
      if (this.history.length > 10) result += 4
      if (this.voyage.length > 12) result += 1
      if (this.voyage.length > 18) result -= 1
    } else {
      if (this.history.length > 8) result += 1
      if (this.voyage.length > 14) result -= 1
    }
    return result
  }
  
  get hasChinaHistory() {
    return thsi.history.some(v => 'china' === v.zone)
  }
}
```

于是我就有了一个类，用来安放基础逻辑。现在我需要另建一个空的子类，用来安放与超类不同的行为。

```javascript
// 新建一个工厂函数用于在需要时返回变体类
function createRating(voyage, history) {
  if (voyage.zone === 'china' && history.some(v => 'china' === v.zone))
    return new ExperiencedChinaRating(voyage, history)
  else return new Rating(voyage, history)
}

// 现在我要修改所有调用方代码，让它们使用该工厂函数，而不要直接调用构造函数。
function rating(voyage, history) {
  return createRating(voyage, history).value
}

class ExperiencedChinaRating extends Rating {
  // 在子类中覆写 captainHistoryRisk 同时在超类中去除相同逻辑
  get  captainHistoryRisk() {
    const result = super.captainHistoryRisk - 2
    return Math.max(result, 0)
  }
}
```

分离`voyageProfitFactor`函数中的变体行为要更麻烦一些，我不能直接从超类中删掉变体行为，因为在超类中还有另一条执行路径。我又不想把整个超类中的函数复制到子类中。

```javascript
class Rating...
get voyageAndHistoryLengthFactor() {
  let result = 0
  if (this.history.length > 8) result += 1
  if (this.voyage.length > 14) result -= 1
  return result
}

class ExperiencedChinaRating...
get voyageAndHistoryLengthFactor() {
  let result = 0
  result += 3
  if (this.history.length > 10) result += 4
  if (this.voyage.length > 12) result += 1
  if (this.voyage.length > 18) result -= 1
  return result
}
```

严格来说，重构到这里已经结束了，但是我还想处理这个丑陋的新函数。这样一个难看的函数只会妨碍，而不是帮助别人理解其中的逻辑。

函数名中的`and`表示其中包含了两件事，所以我觉得应该将他们分开，我会用**提炼函数**把*历史航行数*的相关逻辑提炼出来。

```javascript
class Rating...
get voyageAndHistoryLengthFactor() {
  let result = 0
  result += this.historyLengthFactor
  result += this.voyageLengthFactor
  return result
}
get historyLengthFactor() {
  return (this.history.length > 8) ? 1 : 0
}
get voyageLengthFactor() {
  return (this.voyage.length > 14) ? -1 : 0
}

class ExperiencedChinaRating...
get voyageAndHistoryLengthFactor() {
  let result = 0
  result += 3
  result += this.historyLengthFactor
  result += this.voyageLengthFactor
  return result
}
get historyLengthFactor() {
  return (this.history.length > 10) ? 1 : 0
}
get voyageLengthFactor() {
  let result = 0
  result += 3
  if (this.voyage.length > 12) result += 1
  if (this.voyage.length > 18) result -= 1
  return result
}
```

此时应该把超类中使用搬移语句到调用者

```javascript
class Rating...
get voyageProfitFactor() {
  let result = 2
  if (this.voyage.zone === 'china') result += 1
  if (this.voyage.zone === 'east-indies') result += 1
  result += this.historyLengthFactor
  result += this.voyageLengthFactor
  return result
}

class ExperiencedChinaRating...
// 将加三分加在最终结果上
get voyageProfitFactor () {
  return super.voyageProfitFactor + 3      
}
get voyageLengthFactor() {
  let result = 0
  // result += 3
  if (this.voyage.length > 12) result += 1
  if (this.voyage.length > 18) result -= 1
  return result
}
```

### 引入特例

**动机**

一种常见的重复代码是这种情况：一个数据结构的使用者都在检查某个特殊值，并且当这个特殊值出现时所做的处理都相同，如果我发现代码库中有多处以同样方式应对一个特殊值，我就会想把这个处理逻辑收容到一处

处理这种情况的一个好办法是使用“特例”模式：创建一个特例元素，用以表达对这种特例的公用行为的处理。

**做法**

我们从一个作为隆起的数据结构(或者类)开始，其中包含一个属性，该属性就是我们要重构的目标。容器的客户端每次使用这个属性时，都需要将其与某个特例值做比对。

1. 给重构目标添加检查特例的属性。令其返回`false`。
2. 创建一个特里对象，其中只有检查特例的属性，返回`ture`。
3. 对*与特例值做比对*的代码运用提炼函数，确保所有客户端都是用这个新函数，而不再直接做特例值的比对。
4. 将新的特里对象引入代码中，可以从函数调用中返回，也可以在变换函数中生成。
5. 测试。
6. 使用**函数组合类**或**函数组合成变换**，把通用的特例处理逻辑都搬移到新建的特里对象中。
7. 对特例比对函数使用**内联函数**，将其内联到仍然需要的地方。

**范例**

一家提供公共事业服务的公司将自己的服务安装在各个场所。

```javascript
class Site...
get customer() {return this._customer}

class Customer...
get name() {...}
get billingPlan() {...}
set billingPlan(arg) {...}
get paymentHistory() {...}
```

大多数情况下，一个场所会对应一个顾客，但有些场所没有与之对应的顾客，可能是因为之前的住户搬走了，而新来的住户我还不知道是谁。这种情况下，数据记录中的`customer`字段会被填充为字符串`unknown`。所以`site`对象的客户端必须有办法处理*顾客未知*的情况。下面是一些代码片段。

```javascript
// 客户端1
const aCustomer = site.customer
// ... lots of intervening code ...
let customerName
if (aCustoemr === 'unknown') custoemrName = 'occupant'
else customerName = aCustomer.name

// 客户端2
const plan = (aCustoemr === 'unknown') ?
  resistry.billingPlans.basic
  : aCustomer.billingPlan
  
// 客户端3
if (aCustoemr !== 'unknown') aCustomer.billingPlan = newPlan

// 客户端4
const weeksDelinquent = (aCustomer === 'unknown') ?
  0
  : aCustomer.paymentHistory.weeksDelinquentInLastYear
```

浏览整个代码库，我看到有很多使用`site`对象的客户端在处理*客户未知*的情况下，大多数使用了同样的应对方式。到处都在检查这种特例，这些现象告诉我：是时候使用**特例对象**模式了

我首先给`Customer`添加一个函数，用于指示*这个顾客是否未知*。

```javascript
class Customer...
get isUnknown() {return false}

// 然后我给”未知的顾客“专门创建一个类
// 注意这里没有声明为 Customer 的子类，在静态类型的编程语言中，需要声明为子类
class UnknownCustomer {
  get isUnknown() {return true}
}
```

但是改成这样我就需要将客户端所有期望得到`unknown`值的地方返回这个新的特例对象，并修改所有检查`unknown`值的地方，令其使用`isUnknown`函数。还好，遇到这种困境时，我会先对其使用*提炼函数*。

```javascript
function isUnknown(arg) {
  if (!(arg instanceof Customer) || (arg === 'unknown'))
    throw new Error(`investigate bad value: <${arg}>`)
  return (arg === 'unknown')
}
```

现在，凡是检查未知顾客的地方，都可以改用这个函数，我可以逐一修改这些地方，每次修改之后都可以执行测试。

```javascript
// 客户端1
let customerName
if (isUnknown(aCustomer)) custoemrName = 'occupant'
else customerName = aCustomer.name

// 客户端2
const plan = (isUnknown(aCustomer)) ?
  resistry.billingPlans.basic
  : aCustomer.billingPlan
  
// 客户端3
if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan

// 客户端4
const weeksDelinquent = isUnknown(aCustomer) ?
  0
  : aCustomer.paymentHistory.weeksDelinquentInLastYear
```

在所有调用出都改为使用`isUnknown`函数之后，就可以修改`Site`类，令其在顾客未知时返回`UnknownCustomer`对象。

```javascript
class Site...
get customer() {
  return (this._customer === 'unknown') ? new UnknownCustomer() : this._customer
}
```

此时我可以做一次全文搜索，确保没有任何地方使用`unknown`字符串了。

```javascript
function isUnknown(arg) {
  if (!(arg instanceof Customer) || arg instanceof UnknownCustomer))
    throw new Error(`investigate bad value: <${arg}>`)
  return arg.isUnknown
}
```

此时，我可以逐一查看客户端检查特例的代码，看它们处理特例的逻辑，并考虑是否能用*函数组合成类*将其替换成一个共同的、符合预期的值。此时有多处客户端代码用字符串`occupant`来作为未知顾客的名字。

```javascript
class  UnknownCustomer...
get name() {return 'occupant'}
// 处理代表‘计价套餐的 billingPlan 属性
// 特例对象是值对象，因此应该始终是不可变的
get billingPlan() {return registry.billingPlans.basic}
set billingPlan(arg) {...}

// 客户端1
const customerName = aCustomer.name

// 客户端2
aCustomer.billingPlan = newPlan
  
// 客户端3
const plan = aCustomer.billingPlan
```

最后一个例子更麻烦一些，因为特例对象需要返回另一个对象，后者又有其自有的属性。一般的原则是：如果特里对象需要返回关联对象，被返回的通常也是特例对象。所以，我需要创建一个代表‘空支付记录’的特例类`NullPaymentHistory`。

```javascript
class UnknownCustoemr...
get paymentHistory() {return new NullPaymentHistory()}
class NullPaymentHistory...
get weeksDelinquentInLastYear() {return 0}
// 客户端...
const weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear
```

假如此时有一处客户端代码未用`occupant`作为未知顾客的名字，那么我只能在客户端保留特里检查的逻辑。

```javascript
const name = aCustomer.isUnknown ? 'unknown occupant' : aCustomer.name
```

**范例：使用对象字面量**

我们在上面处理的其实是一些很简单的值，却要创建这样一个类，未免有点大动干戈。但在上面的例子中，我必须创建这样一个类，因为`Customer`类是允许使用者更新其内容的。但面对一个只读的数据结构，我就可以改用字面量对象。

还是前面这个例子，但是这次没有客户端对`Customer`对象做更新操作：

```javascript
class Site...
get customer() {return this._customer}

class Customer...
get name() {...}
get billingPlan() {...}
get billingPlan(arg) {...}
get paymentHistory() {...}

// 客户端1
const aCustomer = site.customer
// ... lots of intervening code ...
let customerName
if (aCustoemr === 'unknown') custoemrName = 'occupant'
else customerName = aCustomer.name

// 客户端2
const plan = (aCustoemr === 'unknown') ?
  resistry.billingPlans.basic
  : aCustomer.billingPlan
  
// 客户端3
if (aCustoemr !== 'unknown') aCustomer.billingPlan = newPlan

// 客户端4
const weeksDelinquent = (aCustomer === 'unknown') ?
  0
  : aCustomer.paymentHistory.weeksDelinquentInLastYear
```

和前面的例子一样，我现在`Customer`中添加`isUnknown`属性，并创建一个包含同名字段的特例对象那个。这次的区别在于，特例对象是一个字面量。

```javascript
class Customer...
get isUnknown() {return false}
// 顶层作用域
function createUnknownCustomer() {
 return { isUnknown: true }
}

// 之后对检查特例的条件逻辑运用提炼函数
function isUnknown(arg) {
  return (arg === 'unknown')
}

// 客户端1
let customerName
if (isUnknown(aCustomer)) custoemrName = 'occupant'
else customerName = aCustomer.name

// 客户端2
const plan = (isUnknown(aCustomer)) ?
  resistry.billingPlans.basic
  : aCustomer.billingPlan
  
// 客户端3
if (!isUnknown(aCustomer)) aCustomer.billingPlan = newPlan

// 客户端4
const weeksDelinquent = isUnknown(aCustomer) ?
  0
  : aCustomer.paymentHistory.weeksDelinquentInLastYear
```

之后修改`Site`类和做条件判断的`isUnknown`函数，开始使用特例对象。

```javascript
class Site...
get customer() {
  return (this._customer === 'unknown') ? createUnknownCustomer() : this._customer
}
// 顶层作用域
function isUnknown(arg) {
  return arg.isUnknown
}

// 之后把以标准方式应对特例的地方都替换成使用特例字面量的值。
function createUnknownCustomer() {
 return { 
   isUnknown: true,
   name: 'occupant',
   bilingPlan: registry.billingPlans.basic,
   paymentHistoty: {
     weeksDelinquentInLastYear: 0
   }
 }
}

// 客户端1
const customerName = aCustomer.name

// 客户端2
const plan = aCustomer.billingPlan

// 客户端3
const weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear
```

如果使用了这样的字面量，应该使用诸如`Object.freeze`的方法将其冻结，使其不可变。通常我还是喜欢用类多一点。

**范例：使用变换**

前面两个例子都涉及了一个类，其实本重构手法也同样适用于记录，只要增加一个变换步骤即可。

```javascript
{
  name: 'Acme Boston',
  location: 'Malden MA',
  // more
  customer: {
    name: 'Acme Industries',
    billingPlan: 'plan-451',
    paymentHistory: {
      weeksDelinquentInLastYear: 7
      // more
    },
    // more
  }
}

// 有时顾客名字未知，此时标记的方式与前面一样：将 customer 字段标记为字符串 unknown。
{
  name: 'Warehouse Unit 15',
  location: 'Malden MA',
  // more
  customer: "unknown"
}

// 客户端代码也类似，会检查未知顾客的情况
// 客户端1...
const rawSite = acquireSiteData()
const site = enrichSite(rawSite)
const aCustomer = site.customer
// ... lots of intervening code ...
let customerName
if (isUnknown(aCustomer)) customerName = 'occupant'
else customerName = aCustomer.name

// 客户端2
const plan = (isUnknown(aCustomer)) ?
      registry.billingPlans.basic
	  : aCustomer.billingPlan
// 客户端3
const weeksDelingquent = (isUnknown(aCustomer)) ?
      0
      : aCustomer.paymentHistory.weeksDelinquentInLastYear
```

开始对`Site`数据做增强，首先是给`customer`字段加上`isUnknown`属性。

```javascript
function enrichSite(aSite) {
  const result = _.cloneDeep(aSite)
  const unknownCustomer = { isUnknown: true }
  
  if (isUnknow(result.customer)) result.customer = unknownCustomer
  else result.customer.isUnknown = false
  return result
}

// 随后修改检查特例的条件逻辑，开始使用新的属性。
function isUnknown(aCustomer) {
  if (aCustomer === 'unknown') return true
  else return Customer.isUnknown
}
```

测试，确保一切正常，然后针对特例使用*函数组合成变换*

```javascript
function enrichSite(aSite) {
  const result = _.cloneDeep(aSite)
  const unknownCustomer = { 
    isUnknown: true,
    name: 'occupant',
    bilingPlan: registry.billingPlans.basic,
    paymentHistoty: {
      weeksDelinquentInLastYear: 0
    }
  }
  
  if (isUnknow(result.customer)) result.customer = unknownCustomer
  else result.customer.isUnknown = false
  return result
}

// 客户端1
const rawSite = acquireSiteData()
const site = enrichSite(rawSite)
const aCustomer = site.customer
// ... lots of intervening code ...
const customerName = aCustomer.name


// 客户端2
const plan = aCustomer.billingPlan

// 客户端3
const weeksDelinquent = aCustomer.paymentHistory.weeksDelinquentInLastYear
```

### 引入断言

**动机**

常常会有一段代码：只有某个条件为真时，该段代码才能正常运行。例如，平方根的计算只对正值才能进行，又比如，某个对象可能假设一组字段中至少有一个不等于`null`.

这样的假设通常你必须阅读整个算法才能看出。有时程序员会以注释写出这样的假设，而我要介绍的是一种更好的技术——使用断言明确标明这些假设。

断言是一个条件表达式，应该总是为真。如果它失败，表示程序员犯了错误。断言的失败不应该被系统任何地方捕捉。整个程序的行为在有没有断言出现的时候都应该完全一样。实际上，有些编程语言中的断言可以在编译期用一个开关完全禁用掉。

断言是一种很有价值的交流形式——它们告诉阅读者，程序在执行到这一点时，对当前状态做了何种假设。另外断言对调试也很有帮助。

**做法**

1. 如果你发现代码假设某个断言始终为真，就加入一个断言明确说明这种情况。应为断言不会对系统运行造成任何影响，所以“加入断言”永远应该是行为保持的。

**范例**

下面是一个简单例子：顾客(customer)会获得一个折扣率(discount rate)，可以用于所有其购买的商品。

```javascript
class Customer...
applyDiscount(aNumber) {
  return (this.discountRate)
    ? aNumber - (this.discountRate * aNumber)
    : aNumber
}
```

这里有一个假设：折扣率永远是正数。我可以用断言明确标识出这个假设。但在一个三元表达式中没办法很简单地插入断言，所以我首先要把这个表达式转换成`if-else`的形式，然后插入断言。

```javascript
class Customer...
applyDiscount(aNumber) {
  if (!this.discountRate) return aNumber
  else {
    assert(this.discountRate >= 0)
    return aNumber - (this.discountRate * aNumber)
  }
}

// 当然可以直接在设值函数中使用断言，这样能更快发现错误源头
set discountRate(aNumber) {
  assert(null === aNumber || aNumber >= 0)
  this._discountRate = aNumber
}
```

或许听来讽刺，只有当我认为断言绝对不会失败的时候，我才会使用断言。

## 重构API

模块和函数是软件的骨肉，而 API 则是将骨肉连接起来的关节。易于理解和使用的 API 非常重要，但同时也很难获得。随着对软件理解的加深，我会学到如何改进 API，这时我需要对 API 进行重构。

### 将查询函数和修改函数分离

**动机**

如果某个函数只是提供一个值，没有任何看得到的副作用，那么这是一个很有价值的东西。我可以任意调用这个函数，也可以把调用动作搬到调用函数的其他地方。这种函数的测试也更容易。

明确表现出*有副作用*和*无副作用*两种函数之间的差异，是个很好的想法。下面是一条好规则：任何有返回值的函数，都不应该有看得到的副作用——命令与查询分离。这里看得到的副作用的有一种常见的优化方法：将查询所得结果缓存于某个字段，这样一来后续的重复查询就可以大大加快速度。

如果遇到一个*既有返回值又有副作用*的函数，我会试着将查询动作从修改动作中分离出来。

**做法**

1. 复制整个函数，将其作为一个查询来命名。
2. 新建的查询函数中去掉所有造成副作用的语句。
3. 执行静态检查。
4. 查找所有调用原函数的地方。如果调用处用到了该函数的返回值，就将其改为调用新建的查询函数，并在下面马上调用一次原函数，每次修改之后都要测试。
5. 从原函数中去掉返回值。
6. 测试。

**范例**

有这样一个函数：它会遍历一份恶棍名单，检查一群人（people）是否混进了恶棍。如果发现了恶棍，该函数会返回恶棍的名字，并拉响警报。如果人群中有多名恶棍，该函数也只汇报找出的第一名恶棍。

```javascript
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === 'Don') {
      setOffAlarms()
      return 'Don'
    }
    if (p === 'John') {
      setOffAlarms()
      return 'John'
    }
  }
  return ''
}
```

首先我复制整个函数，用他的查询部分功能为其命名，然后在查询函数中去掉副作用。

```javascript
function findMiscreant(people) {
  for (const p of people) {
    if (p === 'Don') {
      return 'Don'
    }
    if (p === 'John') {
      return 'John'
    }
  }
  return ''
}

// 然后找到原函数的调用者，将其改为调用新建的查询函数，并在其后调用一次修改函数
const found = findMiscreant(people)
alertForMiscreant(people)
```

之后在原函数中去掉所有返回值

```javascript
function alertForMiscreant(people) {
  for (const p of people) {
    if (p === 'Don') {
      setOffAlarms()
      return
    }
    if (p === 'John') {
      setOffAlarms()
      return
    }
  }
  return
}

// 可以看到原函数和修改函数中有大量重复代码，此时可以使用替代算法，让修改函数使用查询函数
function alertForMiscreant (people) {
  if (findMiscreant(people) !== '') setOffAlarms()
}
```

### 函数参数化

**动机**

如果我发现两个函数逻辑非常相似，只有一些字面量的不容，可以将其合并成一个函数，一参数的形式传入不同的值，从而消除重复。这个重构可以使函数更有用，因为重构后的函数还可以用于处理其他的值。

**做法**

1. 从一组相似的函数中选择一个。
2. 运用*改变函数声明*，把需要作为参数传入的字面量添加到参数列表中。
3. 修改该函数所有的调用处，使其在调用时传入该字面量的值。
4. 测试。
5. 修改函数体，令其使用新传入的参数。每使用一个新参数都要测试。
6. 对于其他与之相似的函数，注意将其调用处改为调用已经参数化的函数。每次修改后都测试。

**范例**

下面是一个显而易见的例子：

```javascript
function tenPercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.1)
}
function fivePercentRaise(aPerson) {
  aPerson.salary = aPerson.salary.multiply(1.05)
}

// 很明显我可以用下面这个函数来替换上面的两个
function raise(aPerson, factor) {
  aPerson.salary = aPerson.salary.multiply(1 + factor)
}
```

下列代码情况可能更复杂一些

```javascript
function baseCharge(usage) {
  if (usage < 0) return usd(0)
  const amount = 
    bottomBand(usage) * 0.03
    + middleBand(usage) * 0.05
    + topBand(usage) * 0.07
  return usd(amount)
}

function bottomBand(usage) {
  return Math.min(usage, 100)
}

function middleBand(usage) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0
}
```

这几个函数中的逻辑明显很相似，但是不是相似到足以支撑一个参数化的计算‘计费档次’的函数？在类似处理“范围”的情况下，通常从位于中间的范围开始着手比较好。

```javascript
// 首先从 middleBand 函数来进行调整，将其加上两个参数并给它改名
function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, top) - bottom : 0
}

function baseCharge(usage) {
  if (usage < 0) return usd(0)
  const amount = 
    withinBand(usage, 0, 100) * 0.03
    + withinBand(usage， 100， 200) * 0.05
    + withinBand(usage, 200, infinity) * 0.07
  return usd(amount)
}
```

### 移除标记参数

**动机**

’标记参数‘是这样的一种参数：调用者用它来指示被调函数应该执行那一部分逻辑。比如下面这样一个函数：

```javascript
function bookConcert(aCustomer, isPremium) {
  if (isPremium) {
    // logic for premium booking
  } else {
    // logic for regular booking
  }
}

// 要预定一场高级音乐会，就得这样发起调用：
bookConcert(aCustomer, true)

// 标记参数也可能以枚举的形式出现：
bookConcert(aCustomer, CustomerType.PREMIUM)

// 或者是以字符串的形式出现
bookConcert(aCustomer, 'premium')
```

我不喜欢标记参数，因为它们让人难以理解到底有哪些函数可以调用、应该怎么调用。使用这样的函数，我还得弄清楚有哪些可用的值。布尔型的标记尤其糟糕，应为他们不能清晰地传达其含义。如果明确用一个函数来完成一项单独的任务，其含义会清晰的多。

```javascript
premiumBookConcert(aCustomer)
```

并非所有类似这样的参数都是标记参数，如果调用者传入的是程序中流动的数据，这样的参数不算标记参数：只有调用者直接传入字面量值，这才是标记参数。

**做法**

1. 针对参数的每一种可能值，新建一个明确函数。
2. 对于”用字面量值作为参数“的函数调用者，将其改为调用新建的明确函数。

**范例**

在浏览代码时，我发现多处代码在调用一个函数计算物流(shipment)的到货日期(delivery date)。一些调用代码类似这样：

```javascript
// 一些调用代码类似这样
aShipment.deliveryDate = deliveryDate(anOrder, true)

// 一些调用代码则是这样，可以看到那个布尔值根本不知道是干嘛的
aShipment.deliveryDate = deliveryDate(anOrder, false)

// deliveryDate 函数主题如下
function deliveryDate(anOrder, isRush) {
  if (isRush) {
    let deliveryTime
    if (['MA', 'CT'].includes(anOrder.deliveryState)) deliveryTime = 1
    else if (['NY', 'NH'].includes(anOrder.deliveryState)) deliveryTime = 2
    else deliveryTime = 3
    return anOrder.placedOn.plusDays(1 + deliveryTime)
  } else {
    let deliveryTime
    if (['MA', 'CT', 'NY'].includes(anOrder.deliveryState)) deliveryTime = 2
    else if (['ME', 'NH'].includes(anOrder.deliveryState)) deliveryTime = 3
    else deliveryTime = 4
    return anOrder.placedOn.plusDays(2 + deliveryTime)
  }
}
```

原来调用者用这个布尔型的字面量来判断应该运行哪个分支的代码——典型的标记参数。此处最好是用明确函数的形式明确说出调用者的意图。对于这个例子，我可以使用*分解条件表达式*得到如下代码：

```javascript
function deliveryDate(anOrder, isRush) {
  if (isRush) return rushDeliveryDate(anOrder)
  else return regulsrDeliveryDate(anOrder)
}

function rushDeliveryDate(anOrder) {
  let deliveryTime
  if (['MA', 'CT'].includes(anOrder.deliveryState)) deliveryTime = 1
  else if (['NY', 'NH'].includes(anOrder.deliveryState)) deliveryTime = 2
  else deliveryTime = 3
  return anOrder.placedOn.plusDays(1 + deliveryTime)
}

function regularDeliveryDate(anOrder) {
  let deliveryTime
  if (['MA', 'CT', 'NY'].includes(anOrder.deliveryState)) deliveryTime = 2
  else if (['ME', 'NH'].includes(anOrder.deliveryState)) deliveryTime = 3
  else deliveryTime = 4
  return anOrder.placedOn.plusDays(2 + deliveryTime)
}

// 上面是两个函数能够更好地表达调用者的意图，现在我可以调用调用方代码了，调用代码
aShipment.deliveryDate = deliveryDate(anOrder, true)

aShipment.deliveryDate = rushDeliveryDate(anOrder, false)
```

如果所有调用`deliveryDate`函数的处理都像下面这样，那么我不会有任何意见

```javascript
const isRush = determineIfRush(anOrder)
aShipment.deliveryDate = deliveryDate(anOrder, isRush)
```

直接拆分条件逻辑是实施本重构的好方法，但只有当”更具参数值做分发“的逻辑发生在函数最外层的时候，这一招才好用。函数内部也有可能以一种更纠结的方式使用标记参数，如下面这个版本的`deliveryDate`函数：

```javascript
function deliveryDate(anOrder, isRush) {
  let result
  let deliveryTime
  if (anOrder.deliveryState === 'MA' || anOrder.deliveryState === 'CT')
    deliveryTime = isRush ? 1 : 2
  else if (anOrder.deliveryState === 'NY' || anOrder.deliveryState === 'NH') {
    deliveryTime = 2
    if (anOrder.deliveryState === 'NH' && !isRush)
  } else if (isRush) {
    deliveryTime = 3
  }
  if (isRush) result = result.minusDays(1)
  return result
}
```

在这种情况下，想把围绕`isRush`的分发逻辑剥离到顶层，需要的工作量可能会很大，所以我选择退而求其次，在`deliveryDate`之上添加两个函数：

```javascript
function rushDeliveryDate (anOrder) {return deliveryDate(anOrder, true)}
function resularDeliveryDate(anOrder) {return deliveryDate(anOrder, false)}
```

这两个包装函数使用代码文本强行定义，同时我会限制原函数的可见性，让人一见便知不应直接使用这个函数。

### 保持对象完整

**动机**

如果我看见一个代码从一个记录结构中到处几个值，然后又把这几个值一起传递给一个函数，我会更愿意把则会那个记录传给这个函数，在函数内部到处所需的值。”传递整个记录“的方式能更好地应对变化。

也有是我不想采用本重构手法，因为我不想让被调函数依赖完整对象，尤其是两者不在同一个模块的时候。

从一个对象中抽取出几个值，单独对这几个值做某些逻辑操作，这是一种代码坏味道，通常标志着这段逻辑应该搬移到对象中。

**做法**

1. 新建一个新函数，给它以期望中的参数列表。
2. 在新函数体内调用旧函数，并把新参数映射到旧的参数列表。
3. 执行静态检查。
4. 逐一修改旧函数的调用者，令其使用新函数，每次修改之后执行测试。
5. 给所有调用处都修改过来之后，使用*内联函数*把旧函数内联到新函数体内。
6. 给新函数改名，从重构开始时的容易搜索的临时名字，改为使用就容易搜索的名字，同时修改所有调用处。

**范例**

我们想象一个室温监控系统，它负责记录房间每一天的最高温度和最低温度，然后将实际的温度范围与预先规定的温度控制计划相比较，如果当天温度不符合计划要求，就发出警告。

```javascript
// 调用方...
const low = aRoom.daysTempRange.low
const high = aRoom.daysTempRange.high
if (!aPlan.withinRange(low, high))
  alerts.push('room temperature went outside range')
  
class HeatingPlan...
withinRange(bottom, top) {
  return (bottom >= this._temperatureRange.low) && (top <= this._temperatureRange.high)
}
```

其实我不必把“温度范围”的信息拆开来单独传递，只需将整个范围对象传递给`withinRange`函数即可。

```javascript
// 首先我创建一个新函数调用现有的 withinRange 函数
class Heatingplan...
xxNEWwithinRange(aNumberRange) {
  return this.withinRange(aNumberRange.low, aNumerRange.high)
}

// 找到调用现有函数的地方，将其改为调用新函数
// const low = aRoom.daysTempRange.low
// const high = aRoom.daysTemRange.high
if (!aPlan.xxNEWwithinRange(aRoom.daysTempRange))
  alerts.push('room temperature went outside range')
```

之后使用内联函数将旧函数内联到新函数体内，同时将函数改名

```javascript
class HeatingPlan...
withinRange(aNumberRange) {
  return (aNumberRange.low >= this._temperatureRange.low) &&
  (aNumberRange.high <= this._temperatureRange.high)
}

// 调用方
if (!aPlan.withinRange(aRoom.daysTempRange))
  alerts.push('room temperature went outside range')
```

**范例：换个方式创建新函数**

在上面的示例中，我直接编写了新函数。大多数时候，这一步非常简单，也是创建新函数最容易的方式。不过有时还会用到另一种方式：可以完全通过重构手法的组合来得到新函数。

```javascript
// 调用方...
const low = aRoom.daysTempRange.low
const high = aRoom.daysTempRange.high
if (!aPlan.withinRange(low, high))
  alerts.push('room temperature went outside range')
```

我要先对代码做一些整理，以便使用*提炼函数*来创建新韩淑。目前的调用者代码还不具备可提炼的函数雏形，不过我可以先做几次*提炼变量*，使其轮廓显现出来。

```
// 调用方...
const low = aRoom.daysTempRange.low
const high = aRoom.daysTempRange.high
// 提炼变量
const isWithinRange = aPlan.withinRange(low, high)
if (!isWithinRange)
  alerts.push('room temperature went outside range')
// 提炼输入参数
const tempRange = aRoom.daysTempRange
const low = tempRange.low
const high = tempRange.high
```

之后使用*提炼函数*创建新函数

```javascript
// 调用方...
const tempRange = aRoom.daysTempRange
const isWithinRange = xxNEWwithinRange(aPlan, tempRange)
if (!isWithinRange)
  alerts.push('room temperature went outside range')

function xxNEWwithinRange(aPlan, temRange) {
  const low = tempRange.low
  const high = tempRange.high
  const isWithinRange = aPlan.withinRange(low, high)
  return isWithinRange
}

// 由于旧函数属于另一个上下文 HeatingPlan 类，可以把新函数搬移过去
class HeatingPlan...
xxNEWwithinRange...
```

这种方式的好处在于：它完全是由其他重构手法组合而成。如果我使用的开发工具支持可靠的提炼和内联操作，用这种方式进行本重构会特别流畅。

### 以查询取代参数

**动机**

函数的参数列表应该总结该函数的可变性，标示处函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数列表应该避免重复，并且参数列表越短越容易理解。

如果调用函数时传入了一个值，二这个值由函数自己来获得也是同样的容易，这就是重复。这个本不必要的参数会增加调用者的难度，因为它不得不找出正确的参数值。

不适用*一查询取代参数*最常见的原因是，移除参数可能会给函数体增加不必要的依赖关系——迫使函数访问某个程序元素，而我原本不想让函数了解这个元素的存在。

如果想要去除的参数值只需要向另一个参数查询就能得到，这是使用*以查询取代参数*最安全的场景。

**做法**

1. 如果有必要，使用*提炼函数*将参数的计算过程提炼到一个独立的函数中。
2. 将函数体内引用该参数的地方改为调用新建的函数，每次修改后执行测试。
3. 将全部替换完成后，使用*改变函数声明*将该参数去掉。

**范例**

考虑下列代码

```javascript
class Order...
get finalPrice() {
  const basePrice = this.quantity * this.itemPrice
  let discountLevel
  if (this.quantity > 100) discountLevel = 2
  else discountLevel = 1
  return this.discountedPrice(basePrice, discountLevel)
}

discountedPrice(basePrice, discountLevel) {
  switch(discountLevel) {
    case 1: return basePrice * 0.95
    case 2: return basePrice * 0.9
  }
}
```

此时可以用*以查询取代临时变量*将`discountLevel`提取出来。

```javascript
class Order..
get finalPrice() {
  const basePrice = this.quantity * this.itemPrice
  return this.discountedPrice(basePrice, this.discountLevel)
}

get discountLevel() {
  return (this.quantity > 100) ? 2 : 1
}
// 再把 discountedPrice 函数中用到这个参数的地方全都改为直接调用 discountLevel 函数
discountedPrice(basePrice, discountLevel) {
  switch(this.discountLevel) {
    case 1: return basePrice * 0.95
    case 2: return basePrice * 0.9
  }
}
```

然后把该参数从函数声明中移除

```javascript
class Order..
get finalPrice() {
  const basePrice = this.quantity * this.itemPrice
  return this.discountedPrice(basePrice)
}

discountedPrice(basePrice) {
  switch(this.discountLevel) {
    case 1: return basePrice * 0.95
    case 2: return basePrice * 0.9
  }
}
```

###  以参数取代查询

**动机**

在浏览函数实现时，我有时会发现一些令人不快的引用关系，例如，引用一个全局变量，或是引用另一个我想要移除的元素。为了解决这些令人不快的引用，我需要将其替换为函数参数，从而将处理引用关系的责任转交给函数的调用者。

使用本重构的情况大多源于我想要改变代码的依赖关系——为了让函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数。

如果一个函数具有相同的擦拭农户调用总是给出同样的结果，我们就说这个函数具有引用透明性。而如果一个函数使用了另一个元素，而后者不具有引用透明性，那么包含该元素的函数也就失去了引用透明性。此时只要把‘不具有引用透明性的元素‘变成参数引入，函数就能重获引用透明性。

有一个常见的模式是：在负责逻辑处的模块中只有纯函数，其外再包裹处理I/O和其他可变元素的逻辑代码。

**做法**

1. 对执行查询操作的代码使用*提炼变量*，将其从函数体中分离出来。
2. 现在函数体代码已经不再执行查询操作，对这部分代码使用提炼函数。
3. 对原来的函数使用*内联函数*。
4. 对新函数改名，改回原来函数的名字。

**范例**

有一个温度控制系统，用户可以从一个温控终端(thermostat)指定温度，但指定的目标温度必须在温度控制计划(heating plan)允许范围内。

```javascript
class HeatingPlan...
get targetTemperature() {
  if (thermostat.selectedTemperature > this._max) return this._max
  else if (thermostat.selectedTemperature < this._min return this._min
  else return thermostat.selectedTemperature
}

// 调用方...
if (thePlan.targetTemperature > thermostat.currentTemperature) setToHeat()
else if (thePlan.targetTemperature < thermostat.currentTemperature) setToCool()
else setOff()
```

此时我担心`targetTemperature`依赖于全局的`thermostat`对象。我可以把这个对象提供的信息作为参数传入。

```javascript
// 首先提炼参数后提炼函数
class HeatingPaln...
get targetTemperature() {
  return this.xxNEWtargetTemperature(thermostat.selectedTemperature)
}

xxNEWtargetTemperature (selectedTemperature) {
 if (selectedTemperature > this._max) return this._max
 else if (selectedTemperature < this._min) return this._min
 else return selectedTemperature
}

// 之后把调用该函数的地方改为使用新函数
// 调用方
if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) > thermostat.currentTemperature) setToHeat()
else if (thePlan.xxNEWtargetTemperature(thermostat.selectedTemperature) < thermostat.currentTemperature) setToCool()
else setOff()
```

之后删除旧函数并将新函数名的前缀去掉即可

### 移除设值函数

**动机**

如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数。这样一来，该字段就只能在构造函数中赋值，我“不想让它被修改”的意图就会更加清晰。

有两种情况需要讨论，一种情况是，有些人喜欢始终通过访问函数来读写字段值，包括在构造函数内也是如此。这会导致构造函数成为设置函数的唯一使用者。

另一种情况是对象是由客户端通过创建脚本构造出来，而不是只有一次简单的构造函数调用。所谓“创建脚本”，首先是调用构造函数，然后就是一系列设值函数的调用，共同完成新对象的构造。在创建脚本执行完成之后，这个新生对象的部分乃至全部字段就不应该再被修改。

**做法**

1. 如果构造函数尚无法得到想要设入字段的值，就是用*改变函数声明*将这个值以参数形式传入构造函数。在构造函数中调用设值函数，对字段设值。
2. 一处所有在构造函数之外对设值函数的调用，改为使用新的构造函数，每次修改之后就要测试。
3. 使用*内联函数*消去设值函数，如果可能的话，把字段变为不可变。
4. 测试。

**范例**

我有一个`person`类

```javascript
class Person...
get name() {return this._name}
set name(arg) {this._name = arg}
get id() {return this._id}
set id(arg) {this._id = arg}

// 目前我会这样创建新对象
const martin = new Person()
martin.name = 'martin'
margin.id = '1234'
```

对象创建之后，`name`字段可能会改变，但`id`字段不会。为了更清晰地表达这个设计意图，我希望移除对应`id`字段的设值函数。

```javascript
class Person...
constructor(id) {
  this.id = id
}
get name() {return this._name}
set name(arg) {this._name = arg}
get id() {return this._id}
set id(arg) {this._id = arg}

// 目前我会这样创建新对象
const martin = new Person('1234')
martin.name = 'martin'
```

### 以工厂函数取代构造函数

**动机**

很对面向对象语言都有特别的构造函数，专门用于对象的初始化。需要新建一个对象时，客户端通常会调用构造函数。但与一般的函数相比，构造函数又有一些丑陋的局限性，比如，`Java`的构造函数只能返回当前所调用类的实例。

工厂函数就不受这些限制。工厂函数的实现内部可以调用构造函数，但也可以换成别的方式实现。

**做法**

1. 新建一个工厂函数，让它调用现有的构造函数。
2. 将调用构造函数的代码改为调用工厂函数。
3. 每修改一处，就执行测试。
4. 尽量缩小构造函数的可见范围。

**范例**

又是那个员工薪资系统，以`employee`类表示“员工”

```javascript
class Employee...
constructor (name, typeCode) {
  this._name = name
  this._typeCode = typeCode
}

get name() {return this._name}
get type() {
  return Employee.legalTypeCodes[this._typeCode]
}
static get legalTypeCodes() {
  return {'E': "Engeer", "M": "Manager", "S": "Salesman"}
}

// 使用它的代码有这样的：
candidate = new Employee(document.name, documnet.empType)

// 也有这样的
const leadEngineer = new Employee(document.leadEngineer, 'E')
```

第一步是创建工厂函数，其中把对象创建的责任直接委派给构造函数

```javascript
function createEmployee(name, typeCode) {
  return new Employee(name, typeCode)
}

// 第一处调用
candidate = createEmployee(document.name, documnet.empType)

// 第二处调用
const leadEngineer = createEmployee(document.leadEngineer, 'E')
```

但是这里以字符串字面量形式传入类型吗，一般来说都是坏味道，所以我更愿意再新建一个工厂函数，把“员工类别”的信息嵌在函数里体现。

```javascript
// 调用方...
const leadEngineer = createEngineer(document.leadEngineer)
function createEngineer(name) {
  return new Employee(name, 'E')
}
```

### 以命令取代函数

**动机**

函数，不管是独立函数，还是以方法形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的方法，这样的对象我称之为"命令对象"，会简称“命令”。这种对象大多只服务于单一函数，获得对该函数的请求，执行该函数，这就是这种对象存在的意义。

与普通函数相比，命令对象提供了更大的控制灵活性和更强的表达能力。除了函数调用本身，命令对象还可以支持附加的操作，比如撤销操作。我可以通过命令对象提供的方法来设值命令的参数值，从而支持更丰富的生命周期观临崩离。我可以借助继承和钩子对函数行为加以定制。

但是命令对象的灵活性也是以复杂性作为代价的。所以只有当我特别需要命令对象提供的某种能力而普通函数无法提供这种能力时，我才会考虑使用命令对象。

**做法**

1. 为想要包装的函数传概念一个空的类，根据该函数的名字为其命名。
2. 使用*搬移函数*把函数移到空的类里。
3. 可以考虑给每个参数创建一个字段，并在构造函数中添加对应的参数。

**范例**

JS 语言有很多缺点，丹巴函数作为一等公民对待，是它最正确的设计决策之一。在不具备这种能力的编程语言中，我经常要费力为很常见的任务创建命令对象，JS 则省去了这些麻烦。不过，即便在 JS 中，有时也需要用到命令对象。

一个典型的应用场景就是拆解复杂的函数，以便我理解和修改。要想真正展示这个重构手法的价值，我需要一个长而复杂的函数，所以这里展示的函数其实很短，下面的函数用于给一份保险申请评分。

```javascript
function score(candidate, medicalExam, scoringGuide) {
  let result = 0
  let healthLevel = 0
  let highMedicalRiskFlag = false
  
  if (medicalExam.isSmoke) {
    healthLevel += 10
    highMedicalRiskFlag = true
  }
  
  let certificationGrade = 'regular'
  if (scoringGuide.stateWithLowCertification(candidate.originState)) {
    certificationGrade = 'low'
    result -= 5
  }
  
  // lots of code like this
  result == Math.max(healthLevel - 5, 0)
  return result
}
```

我首先创建一个空的类，用*搬移函数*把上述函数搬移到这个类里去

```javascript
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer().execure(candidate, medicalExam, scoringGuide)
}

class Scorer {
  execure(candidate, medicalExam, scoringGuide) {
    let result = 0
    let healthLevel = 0
    let highMedicalRiskFlag = false
  
    if (medicalExam.isSmoke) {
      healthLevel += 10
      highMedicalRiskFlag = true
    }
  
    let certificationGrade = 'regular'
    if (scoringGuide.stateWithLowCertification(candidate.originState)) {
      certificationGrade = 'low'
      result -= 5
    }
  
    // lots of code like this
    result == Math.max(healthLevel - 5, 0)
    return result
  }
}
```

大多数时候，我更愿意在命令对象的构造函数中传入参数，而不让`execute`函数接收参数。在这样一个简单的拆解场景中，这一点带来的影响不大，但如果我要处理的命令需要更复杂的参数设置周期或大量定制，上述做法就会带来更多便利：多个命令类可以分别从各自的构造函数中获得各自不同的参数，然后又可以拍成队列挨个执行，因为它们的`execure`函数签名一样。

```javascript
function score(candidate, medicalExam, scoringGuide) {
  return new Scorer(candidate, medicalExam, scoringGuide).execute()
}

class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate
    this._medicalExam = medicalExam
    this._scoringGuide = scoringGuide
  }
  execute(medicalExam, scoringGuide) {
    let result = 0
    let healthLevel = 0
    let highMedicalRiskFlag = false
  
    if (this._medicalExam.isSmoke) {
      healthLevel += 10
      highMedicalRiskFlag = true
    }
  
    let certificationGrade = 'regular'
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
      certificationGrade = 'low'
      result -= 5
    }
  
    // lots of code like this
    result == Math.max(healthLevel - 5, 0)
    return result
  }
}
```

以命令取代函数的重构到此就结束了，不过之所以要做这个重构，是为了拆解复杂的函数，所以我还是大致展示一下如何拆解。下一步是把所有局部变量都变成字段。

```javascript
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate
    this._medicalExam = medicalExam
    this._scoringGuide = scoringGuide
  }
  execute(medicalExam, scoringGuide) {
    this._result = 0
    this._healthLevel = 0
    this._highMedicalRiskFlag = false
  
    if (this._medicalExam.isSmoke) {
      this._healthLevel += 10
      this._highMedicalRiskFlag = true
    }
  
    this._certificationGrade = 'regular'
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
      this._certificationGrade = 'low'
      this._result -= 5
    }
  
    // lots of code like this
    this._result == Math.max(healthLevel - 5, 0)
    return this._result
  }
}
```

之后使用*提炼函数*等手法来进行重构

```javascript
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate
    this._medicalExam = medicalExam
    this._scoringGuide = scoringGuide
  }
  execute(medicalExam, scoringGuide) {
    this._result = 0
    this._healthLevel = 0
    this._highMedicalRiskFlag = false
  	
  	this.scoreSmoking()
  
    this._certificationGrade = 'regular'
    if (this._scoringGuide.stateWithLowCertification(this._candidate.originState)) {
      this._certificationGrade = 'low'
      this._result -= 5
    }
  
    // lots of code like this
    this._result == Math.max(healthLevel - 5, 0)
    return this._result
  }
  
  scoreSmoking() {
    if (this._medicalExam.isSmoke) {
      this._healthLevel += 10
      this._highMedicalRiskFlag = true
    }
  }
}
```

### 以函数取代命令

**动机**

命令对象为处理复杂计算提供了强大的机制。借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态，但这种强大是有代价的，大多数时候，我只是想调用一个函数，让它完成自己的工作就好。

**做法**

1. 运用*提炼函数*把创建并执行命令对象的代码提炼到一个函数中。
2. 对命令对象在执行阶段用到的哈纳树，逐一使用内联函数。
3. 使用*改变函数声明*，把构造函数的参数转移到执行函数。
4. 对于所有字段，在执行函数中找到引用它的地方，并改为使用参数。每次修改后进行测试。
5. 把调用构造函数和调用执行函数两步都内联到调用方。
6. 测试。
7. 用移除死代码把命令类消去。

**范例**

假设我有一个很小的命令对象

```javascript
class ChargeCalculator {
  constructor(customer, usage, provider) {
    this._customer = customer
    this._usage = usage
    this._provider = provider
  }
  
  get baseCharge() {
    return this._customer.baseRage * this._usage
  }
  
  get charge () {
    return this.baseCharge + this._provider.connectionCharge
  }
}

// 调用方...
monthCharge = new ChargeCalculator(customer, usage, provider).charge
```

首先我用*提炼函数*把命令对象的创建和调用过程包装到一个函数中

```JavaScript
// 调用方...
monthCharge = charge(customer, usage, provider)
// 顶层作用域
function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge
}
```

将所有逻辑处理集中到一个函数

```javascript
class ChargeCalculator...
charge(customer, usage, provider) {
  const baseCharge = this._customer.baseRage * this._usage
  return baseCharge + this._provider.connectionCharge
}

function charge(customer, usage, provider) {
  return new ChargeCalculator(customer, usage, provider).charge(customer, usage, provider)
}
```

之后将`charge`函数改为使用传入的参数。

```
class ChargeCalculator...
charge(customer, usage, provider) {
  const baseCharge = customer.baseRage * usage
  return baseCharge + provider.connectionCharge
}
```

之后删除搬空的类即可

## 处理继承关系

继承关系十分使用，却也经常被误用，而且常等你用上一段时间，遇见了痛点，才能察觉误用所在。

### 函数上移

**动机**

避免重复代码是很重要的。重复的两个函数现在也许能够正常工作，但假以时日却只会成为滋生 bug 的温床。如果某个函数在各个子类中的函数体都相同，这是最显而易见的*函数上移*场合。当然，情况并不总是如此明显。

*函数上移*过程中最麻烦的一点就是，被提升的函数可能会引用只出现于子类而不出现与超类的特性。此时，我就得使用*字段上移*和*函数上移*先将这些特性提升到超类。

**做法**

1. 检查待提升函数，确定它们完全一致。
2. 检查函数体内引用的所有函数调用和字段都能从超类中调用到。
3. 如果待提升函数的签名不同，使用*改变函数声明*将那些签名都修改为你想要在超类中使用的签名。
4. 在超类中新建一个函数，将一个待提升函数的代码复制到其中。
5. 执行静态检查。
6. 移除一个待提升的子类函数。
7. 测试。
8. 逐一移除待提升的子类函数，直到只剩下超类中的函数为止。

**范例**

我手上有两个子类，他们之中各有一个函数做了相同的事情。

```javascript
class Employee extends Party...
get annualCost() {
  return this.monthlyCost * 12
}

class Department extends Party...
get totalAnnualCost () {
  return this.monthlyCost * 12
}
```

两个函数各有不同的名字，因第一步是用*改变函数声明*统一它们的函数名

```javascript
class Department...
get annualCost() {
  return this.monthlyCost * 12
}

// 之后从其中一个子类将 annualCost 函数复制到超类并移除子类上的 annualCost
class Party...
get annualCost() {
  return this.monthlyCost * 12
}
```

但是如果是其他语言，没有自动提供`this.monthlyCost`，此时需要明确传达出‘继承`party`类的子类需要提供一个`monthlyCost`实现这个信息，也有很大价值。其中一种好的传达方式是添加一个陷阱函数

```javascript
class Party...
get monthlyCost () {
  throw new SubclassResponsibilityError()
}
```

### 字段上移

**动机**

如果各子类是分别开发的，或者是在重构过程中组合起来的，你常会发现它们拥有重复特性，特别是字段更容易重复。

*字段上移*基本上是引用*构造函数上移*的必然结果。

**做法**

1. 针对待提升的字段，检查它们的所有使用点，确认它们以相同方式使用。
2. 如果这些字段的名称不同，先使用*变量改名*为它们取个相同名字。
3. 在超类中新建一个字段。
4. 移除子类中的字段。
5. 测试。

### 构造函数本体上移

**动机**

构造函数是很奇妙的东西。它们不是普通函数，使用它们比使用普通函数受到更多的限制。

如果重构过程过于复杂，我会考虑转而使用*以工厂函数取代构造函数*。

**做法**

1. 如果超类还不存在构造函数，首先为其定义一个。确保让子类调用超类的构造函数。
2. 使用*移动语句*将子类中的构造函数中的公共语句移动到超类的构造函数调用语句之后。
3. 逐一移除子类间的公共代码，将其提升至超类构造函数中。对于公共代码中引用到的变量，将其作为参数传递给超类中的构造函数。
4. 测试。
5. 如果存在无法简单提升至超类的公共代码，先应用*提炼函数*，再利用*函数上移*提升之。

**范例**

以下列’雇员‘的例子开始

```javascript
class Party{}

class Employee extends Party {
  constructor(name, id, monthlyCost) {
    super()
    this._id = id
    this._name = name
    this._monthlyCost = monthlyCost
  }
  // rest of class...
}

class Department extends Party {
  constructor(name, staff) {
    super()
    this._name = name
    this._staff = staff
  }
  // rest of class...
}
```

我们看到对`name`字段的赋值为公共代码。直接将`name`字段提升至超类然后子类使用`super(name)`调用即可。

但有时也需要将共用行为的初始化提升至超类，这是问题就来了。

```javascript
class Employee...
constructor(name) {...}
get isPrivileged() {...}
assignCar() {...}

class Manager extends Employee...
constructor(name, grade) {
  super(name)
  this._grade = grade
  // 每个子类都有的行为
  if (this.isPrivileged) this.assignCar()
}

 get isPrivileged() {
   return this._grade > 4
 }
```

在这种情况下，可以使用*提炼函数*后使用*函数上移*

```javascript
class Employee...
finishConstruction() {
  if (this.isPrivileged) this.assignCar()
}

class Manager...
constructor(name, grade) {
  super(name)
  this._grade = grade
  // 每个子类都有的行为
  this.finishConstruction()
}
```

### 函数下移

**动机**

如果超类中的某个函数只与一个(或少数几个)子类有关，那么最好将其从超类中挪走，放到真正关心它的子类上去。

**做法**

1. 将超类中的3函数本体复制到每一个需要此函数的子类中。
2. 删除超类中的函数。
3. 测试。
4. 将函数从所有不需要它的那些子类中删除。
5. 测试。

### 字段下移

**动机**

如果某个字段只被一个或小部分子类用到，就将其搬移到需要该字段的子类中。

**做法**

1. 在所有需要该字段的子类中声明该字段。
2. 将该字段从超类中去除。
3. 测试。
4. 将该字段从所有不需要它的那些子类中删掉。
5. 测试。

### 以子类取代类型码

**动机**

软件系统经常要表现“相似但又不同的东西”，比如员工可以按职位分类，订单可以按优先级分类。表现分类关系的第一种工具是类型码字段——更具具体的编程语言，可能实现为枚举、符号、字符串或数字。类型码的取值经常来自给系统提供数据的外部服务。

大多数时候，有这样的类型码就足够了。但有些时候，我可以再往前一步，引入子类。继承有两个诱人之处。首先，可以用多态来处理条件逻辑。另外，有些字段或函数只对特定的类型码取值才有意义。

在使用*以子类取代类型码*时，我需要考虑一个问题：因嘎嘎i直接处理携带类型码的这个类，还是应该处理类型码本身呢？举个例子，我是应该让“工程师”成为“员工”的子类，还是应该在“员工”类包含“员工类别”属性，从后者继承出“工程师”和“经理”等子类型呢？直接的子类继承（前一种方案）比较简单，但职位类别就布恩那个用在其他场合了。

**做法**

1. 自封装类型码字段。
2. 任选一个类型码取值，为其创建一个子类。覆写类型码类的字面量值。
3. 创建一个选择器逻辑，把类型码参数映射到新的子类。
4. 测试。
5. 针对每个类型码取值，重复上述“创建子类、添加选择器逻辑”的过程。每次修改后执行测试。
6. 去除类型码字段。
7. 测试。
8. 使用*函数下移*和*以多态取代条件表达式*处理原本访问了类型码的函数。全部处理完后，就可以移除类型码的访问函数。

**范例**

下面有个员工管理系统的例子

```javascript
class Employee...
constructor(name, type) {
  this.validateType(type)
  this._name = name
  this._type = type
}
validateType(arg) {
  if (!['engineer', 'manager', 'salesman'].includes(arg))
   throw new Error(`Employee cannot be of type ${arg}`)
}
toString() {return `${this._name} (${this._type})`}
```

第一步是用*封装变量*将类型码自封装起来

```javascript
class Employee...
get type() {return this._type}
toString() {return `${this._name} (${this._type})`}
```

我打算采用直接继承的方案，也就是继承`Employee`类。

```javascript
class Engineer extends Employee {
  get type() {return 'engineer'}
}

class Manager extends Employee {
  get type() {return 'manager'}
}

class Salesman extends Employee {
  get type() {return 'salesman'}
}

// 我可以新建一个工厂函数以便安放选择器逻辑
function createEmployee(name, type) {
  switch(type) {
    case 'engineer': return new Engineer(name, type)
    case 'manager': return new Manager(name, type)
    case 'salesman': return new Salesman(name, type)
  }
  return new Employee(name, type)
}

// 修改完成后，我就可以去掉类型码字段机器在超类中的取值函数
class Employee...
constructor(name, type) {
  this.validateType(type)
  this._name = name
  // this._type = type
}
// get type() {return this._type}
toString() {return `${this._name} (${this._type})`}
```

之后去除`validateType`函数，因为它和分发逻辑做的是一回事。再把构造函数中的类型参数去除。

```javascript
class Employee...
constructor(name) {
  // this.validateType(type)
  this._name = name
}

function createEmployee(name) {
  switch(type) {
    case 'engineer': return new Engineer(name)
    case 'manager': return new Manager(name)
    case 'salesman': return new Salesman(name)
    default: throw new Error(`Employee cannot be of type ${type}`)
  }
  return new Employee(name, type)
}
```

之后再把子类中获取类型码的访问函数——`get type`函数全部去除。

**范例：使用间接继承**

还是前面两个例子，我们回到最起初的状态，不过这次我已经有了“全职员工”和“兼职员工”两个子类，所以不饿能再根据员工类别代码创建子类了。另外我可能需要允许员工类别动态调整，这也会导致布恩那个直接使用直接继承的方案。

```javascript
class Employee...
constructor(name, type) {
  this.validateType(type)
  this._name = name
  this._type = type
}
validateType(arg) {
  if (!['engineer', 'manager', 'salesman'].includes(arg))
   throw new Error(`Employee cannot be of type ${arg}`)
}
get type() {return this._type}
set type(arg) {this._type = arg}

get capitalizedType() {
  return this._type.charAt(0).toUpperCase() + this._type.substr(1).toLowerCase()
}
toString() {return `${this._name} (${this.capitalizedType})`}
```

这次的`toString`函数要更复杂一些，以便稍后展示用

首先，我用*以对象取代基本类型*包装类型码

```javascript
class EmployeeType {
  constructor(aString) {
    this._value = aString
  }
  toString() {return this._value}
}

class Employee...
get typeString() {return this._type.toString()}
```

之后使用*以子类取代类型码*的老套路，把员工类别代码变成子类

```javascript
class Employee...
set type(arg) {this._type = Employee.createEmployeeType(arg)}
static createEmployeeType(aString) {
  case 'engineer': return new Emgineer()
  case 'manager': return new Manager()
  case 'salesman': return new Salesman()
  default: throw new Error(`Employee cannot be of type ${aString}`)
}

class EmployeeType {}
class Engineer extends EmployeeType {
  toString() {return 'engineer'}
}
class Manager extends EmployeeType {
  toString() {return 'manager'}
}
class Salesman extends EmployeeType {
  toString() {return 'Salesman'}
}
```

如果重构到此为止的话，空的`EmployeeType`类可以去掉。但我更愿意留着它，用来明确表达各个子类之间的关系，同时也方便把其他行为搬移进去。

### 移除子类

**动机**

子类很有用，它们为数据结构的多样和行为的多态提供支持，他们是针对差异编程的好工具。但随着软件的演化，子类所支持的变化可能会被搬移到别处，甚至完全去除，这是子类就失去了价值。

**做法**

1. 以*工厂函数取代构造函数*，把子类的构造函数包装到超类的工厂函数中。
2. 如果有任何代码检查子类的类型。先用*提炼函数*把类型检查逻辑包装起来，然后用*搬移函数*将其搬到超类。每次修改后执行测试。
3. 新建一个字段，用于表示子类的类型。
4. 将原本针对子类的类型做判断的函数改为使用新建的类型字段。
5. 删除子类。
6. 测试。

**范例**

一开始，代码中遗留了两个子类

```javascript
class Person...
constructor(name) {
  this._name = name
}
get name() {return this._name}
get genderCode() {return 'X'}
// snip

class Male extends Person {
  get genderCode() {return 'M'}
}

class Female extends Person {
  get genderCode() {return 'F'}
}

// 客户端...
const numberOfMales = people.filter(p => p instanceof Male).length
```

如果子类就干这点事，那真没必要存在。当想要改变某个东西的表现形式时，我会将当下的表现形式封装起来，从而尽量减少对客户端代码的影响。对于“创建子类对象”而言，封装的方式就是*以工厂函数取代构造函数*。在这里，实现工厂有两种方式。

最直接的方式是为每个构造函数分别创建一个工厂函数

```javascript
function createPerson(name) {
  return new Person(name)
}

function createMale(name) {
  return new Male(name)
}

function createFemale(name) {
  return new Female(name)
}
```

虽然这是最直接的选择，但这样的对象经常是从输入源加载出来，直接根据性别代码创建对象。

```javascript
function loadFromInput(data) {
  const result = []
  data.forEach(aRecord => {
    let p
    switch (aRecord.gender) {
      case 'M': p = new Male(aRecord.name); break
      case 'F': p = new Female(aRecord.name); break
      default: p = new Person(aRecord.name); break
    }
    result.push(p)
  })
  return result
}
```

所以这里更好的办法是用*提炼函数*把*选择哪个类来实例化*的逻辑提炼成工程函数。

```javascript
function createPerson(aRecord) {
  switch (aRecord.gender) {
    case 'M': return new Male(aRecord.name); break
    case 'F': return new Female(aRecord.name); break
    default: return new Person(aRecord.name); break
  }
}

function loadFromInput(data) {
  const result = []
  data.map(aRecord => createPerson(aRecord))
  return result
}
```

代码中还有一处用到`instanceof`运算符——这从来不是什么好味道。我用*提炼函数*把这个类型检查逻辑提炼出来。

```javascript
// 客户端...
const numberOfMales = people.filter(p => isMale(p)).length
function isMale(aPerson) {return aPerson instanceof Male}
```

此时可以用搬移函数将其搬移到`Person`类

```javascript
class Person...
get isMale() {return this instanceof Male}
// 客户端...
const numberOfMales = people.filter(p => p.isMale).length
```

重构到这一步，所有子类相关的内容都已经安全地包装再超类和工厂函数中。

消灾，添加一个字段来表示子类之间的差异。既然有来自别处的一个类型代码，直接用它也无妨。

```javascript
class Person...
constructor(name, genderCode) {
  this._name = name
  this._genderCode = genderCode || 'X'
}
get genderCode() {return this._genderCode}
```

在初始化时先将其设置为默认值。另外，虽然大所属人可以归类为男性和女性，但确实有些人不是这两种性别中的一种，忽视这些人的存在，是一个常见的建模错误。

```javascript
function createPerson(aRecord) {
  switch (aRecord.gender) {
    case 'M': return new Person(aRecord.name, 'M'); break
    case 'F': return new Person(aRecord.name, 'F'); break
    default: return new Person(aRecord.name, 'M'); break
  }
}

class Person...
constructor(name, genderCode) {
  this._name = name
  // this._genderCode = genderCode || 'X'
}
```

### 提炼超类

**动机**

如果看见两个类再做相似的事，可以利用基本的继承机制把它们的相似之处提炼到超类。很多技术作家在谈到面向对象时，认为继承必须预先仔细计划，应该更具“真实世界”的分类结构建立对象模型。但很多时候，合理的继承方式是在程序演化过程中才浮现出来的。

另一种选择就是*提炼类*。这两种方案之间的选择，其实就是继承和委托之间的选择，总之目的就是把重复代码收拢一处。

**做法**

1. 为原本的类新建一个空白的超类。
2. 测试。
3. 逐一将子类的共同元素上移到超类。
4. 检查留在子类中的函数，看它们是否还有共同成分。如果有，可以将其提炼出来，再搬到超类。
5. 检查所有使用原本的类的客户端代码，考虑将其调整为使用超类的接口。

**范例**

下面两个类，仔细考虑之下，是有一些共同之处的

```javascript
class Employee {
 constructor(name, id, monthlyCost) {
   this._id = id
   this._name = name
   this._monthlyCost = monthlyCost
 }
 get monthlyCost() {return this._monthlyCost}
 get name() {return this._name}
 get id() {return this._id}
 
 get annualCost() {
   return this.monthlyCost * 12
 }
}

class Department {
  constructor(name, staff) {
   this._name = name
   this._staff = staff
 }
 get staff() {return this._staff}
 get name() {return this._name}
 get totalMonthlyCost () {
   return this.staff
     .map(e => e.monthlyCost)
     .reduce((sum, cost) => sum + cost)
 }
 get headCount () {
   return this.staff.length
 }
 get totalAnnualCost () {
   return this.totalMontylyCost * 12
 }
}
```

首先创建一个超类，让原来的两个类来继承它

```javascript
class Party {}
class Employee extends Party {...}
class Department extends Party {...}
```

先搬移字段，再搬移函数

```javascript
class Party...
constructor (name) {
  this._name = name
}
get name () {return this._name}
// 两个子类的 monthlyCost 和 totalMonthlyCost 意图一致，可以合并为一个函数
get annualCost () {return this.monthlyCost * 12}
 
class Employee..
constructor(name, id, monthlyCost) {
  super(name)
  // ...
}

class Department..
constructor(name, id, monthlyCost) {
  super(name)
  // ...
}
```

### 折叠继承体系

**动机**

随着继承体系的演化，我有时会发现一个类与其超类已经没多大差别，此时我就会把超类和子类合并起来。

**做法**

1. 选择想要移除的类：是超类还是子类？
2. 把所有元素移到同一个类中。
3. 调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类。
4. 移除我们的目标。
5. 测试。

### 以委托取代子类

**动机**

如果一个对象的行为有明显的类别之分，继承是很自然的表达方式。但继承也有其短板，最明显的是，继承这张牌只能打一次。导致行为不同的原因可能有很多种，但继承只能用于处理一个方向上的变化。比如说，我可能希望“人”的行为根据“年龄段”的不同，并且根据“收入水平”不同。使用继承的话，子类可以是“年轻人”和“老人”，也可以是“富人”和“穷人”，但不能采用两种继承方式。

更大的问题在于，继承给类之间引入了非常紧密的关系，在超类上做任何修改，都很有可能破坏子类。

这两个问题用委托都能解决，对于不同的变化原因，我可以委托给不同的类。与继承关系相比，使用委托关系时接口更清晰、耦合更少，因此，继承关系遇到问题时运用*以委托取代子类*是常见的情况。

有一条流行的原则：“对象组合优于类继承”。但这并不表示“继承有害”，继承是一种很有价值的机制，大部分时候能达到效果，不会带来问题。所以我会从继承剋之，如果开始继承出现问题，再转而使用委托。

**做法**

1. 如果构造函数有多个调用者，首先*以工厂函数取代构造函数*把构造函数包装起来。
2. 创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，并且经常以参数形式接受一个指回超类的引用。
3. 在超类中添加一个字段，用于安放委托对象。
4. 修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例。
5. 选择一个子类中的函数，将移入委托类。
6. 使用*搬移函数*手法搬移上述函数，不要删除类中的委托代码。
7. 如果被搬移的原函数还在子类之外被调用了，就把留在源类中的委托代码从子类移到超类，并在委托代码之前加上卫语句，检查委托对象存在。如果子类之外已经没有其他调用者，就是用*移除死代码*去掉已经没人使用的委托代码。
8. 测试。
9. 重复上述过程，直到子类中所有函数都搬移到委托类。
10. 找到所有调用子类构造函数的地方，逐一将其改为使用超类的构造函数。
11. 测试。
12. 运用*移除死代码*去掉子类。

**范例**

下面这类用于处理演出`show`和预定`booking`

```javascript
class Booking...
constructor (show, date) {
  this._show = show
  this._date = date
}
get hasTalkback() {
  return this._show.hasOwnProperty('talkback') && !this.isPeakDay
}
get basePrice() {
  let result = this._show.price
  if (this.isPeakDay) result += Math.round(result * 0.15)
  return result
}

// 有一个子类，专门用于与订购高级 premium 票，这个子类要考虑各种附加服务 extra
class PremiumBooking extends Booking...
constructor (show, date, extras) {
  super(show, date)
  this._extras = extras
}
// PremiumBooking 类在超类的基础上做了好些改变。在这种“针对差异编程”的风格中，子类常会覆写超类的方法
// 先来看一处简单的覆写
get hasTalkback() {
  return this._show.hasOwnProperty('talkback')
}
// 定价逻辑也是相似到逻辑，不过 PremiumBooking 调用了超类中的方法。
get basePrice () {
  return Math.round(super.basePrice + this._extras.premiumFee)
}
// 最后一个例子是 Premium 提供了一个超类中没有的行为
get hasDinner () {
  return this._extras.hasOwnProperty('dinner') && !this.isPeakDay
}
```

继承在这个例子中工作良好，即使不了解子类，我同样也可以理解超类的逻辑。子类只描述自己与超类的差异。

但它也并非如此完美。超类的一些结构旨在特定的子类存在时才有意义——有些函数的组织方式完全就是为了覆写特定类型的行为。所以尽管大部分时候我可以修改超类而不必理解子类，但如果不可以不关注子类的存在，在修改超类时偶尔有可能会破坏子类。

那么既然情况还不算坏，为什么我想*以委托取代子类*来做出改变呢？因为继承只能使用一次，如果我有别的原因想使用继承，并且这个新的原因别“高级预定”更有必要，就需要更换一种方式类处理高级预定。另外，我可能需要动态地把普通预定升级成高级预定，例如提供`aBooking.bePremium()`这样一个函数。有时我可以新建一个对象(就好像通过 HTTP请求 从服务器端加载全新的数据结构)，从而避免“对象本身升级”的问题。但有时我需要修改数据本身的结构，而不重建整个数据结构。如果一个`Booking`对象被很多地方引用，也很难将其整个替换掉。此时，就有必要允许在“普通预定”和“高级预定”之间来回转换。

当这样的需求累积到一定程度时，我就该使用*以委托取代子类*了。现在客户端直接调用两个类的构造函数类创建不同的预定。

```javascript
// 进行普通预定的客户端
aBooking = new Booking(show, date)
// 进行高级预定的客户端
aBooking = new PremiumBooking(show, date, extras)
```

去除子类会改变对象创建的方式，所以我先要*以工厂函数取代构造函数*把构造函数封装起来。

```javascript
// 顶层作用域...
function createBooking(show, date) {
  return new Booking(show, date)
}
function createPremiumBooking(show, date, extras) {
  return new PremiumBooking(show, date, extras)
}

aBooking = createBooking(show, date)
aBooking = createPremium(show, date, extras)
```

新建一个委托类。这个类的构造函数参数由两部分：首先是指向`Booking`对象的反向引用，随后是只有之类才需要的哪些数据。我需要传入反向引用，是因为子类的几个函数需要访问超类中的数据。有继承关系的时候，访问这些数据很容易；而在委托关系中，就得通过反向引用来访问。

```javascript
class PremiumBookingDelegate...
constructor(hostBooking, extras) {
  this._host = hostBooking
  this._extras = extras
}
```

现在可以把新建的委托对象与`Booking`对象关联起来。在“创建高级预定”的工厂函数中修改即可。

```javascript
function createPremiumBooking(show, date, extras) {
  const result = new PremiumBooking (show, date, extras)
  result._bePremium(extras)
  return result
}

class Booking...
// _bePremium 函数以下划线开头，表示这个函数不应该被当作 Booking 类的公共接口。当然，如果最终我们希望允许普通预定转换成高级预定，这个函数也可以成为公共接口
_bePremium(extras) {
  this._premiumDelegate = new PremiumBookingDelegate(this, extras)
}
```

结构设置好了，现在该动手搬移行为了，我首先考虑`hasTalkback`函数简单的覆写逻辑。现在的代码如下

```javascript
class Booking...
get hasTalkback() {
  return this._show.hasOwnProperty('talkback') && !this.isPeakDay
}

class PremiumBooking...
get hasTalkBack() {
  return this._show.hasOwnProperty('talkback')
}
```

接接下来把子类中的函数搬移到委托类中。原本访问超类中的数据的代码，现在要改为调用`_host`对象。

```javascript
class PremiumBookingDelegate...
get hasTalkback () {
  return this._host._show.hasOwnProperty('talkback')
}

// 调用点有代理对象就用代理对象
class PremiumBooking...
// get hasTalkback() {
//  return this._premiumDelegate.hasTalkback
// }

class Booking...
get hasTalkback() {
  return (this._premiumDelegate)
    ? this._premiumDelegate.hasTalkback
    : this._show.hasOwnProperty('talkback') && !this.isPeakDay
}
```

下一个要处理的是`basePrice`函数

```javascript
class Booking...
get basePrice() {
  let result = this._show.price
  if (this.isPeakDay) result += Math.round(result * 0.15)
  return result
}

class PremiumBooking...
get basePrice() {
  return Math.round(super.basePrice + this._extras.premiumFee)
}
```

情况大致相同，但是子类调用了超类中的同名函数。把子类的代码移到委托类时，需要继续调用超类的逻辑——但我不能直接调用`this._host.basePrice`，这会导致无穷递归。

有两个办法处理这个问题。一种办法是用*提炼函数*把“基本价格”的计算逻辑提炼出来，从而把分发逻辑和价格计算逻辑拆开。（剩下的操作就和前面一样）

```javascript
class Booking...
get basePrice() {
  return (this._premiumDelegate)
    ? this._premiumDelegate.basePrice
    : this._privateBasePrice
}
get _privateBasePrice() {
  let result = this._show.price
  if (this.isPeakDay) result += Math.round(result * 0.15)
  return result
}
class PremiumBookingDelegate...
get basePrice() {
  return Math.round(this._host._privateBasePrice + this._extras.premuimFee)
}
```

另一个方法是，重新定义委托对象中的函数，使其成为基础函数的扩展

```javascript
class Booking...
get basePrice() {
  let result = this._show.price
  if (this.isPeakDay) result += Math.round(result * 0.15)
  return (this._premiumDelegate)
    ? this._premiumDelegate.extendBasePrice(result)
    : result
}

class PremiumBOokingDelegate...
extendBasePrice(base) {
  return Math.round(base + this._extras.premiumFee)
}
```

**范例：取代继承体系**

前面的例子展示了如何*已委托取代子类*去除单个子类。还可以用这个重构手法去除整个继承体系。

```javascript
function createBird(data) {
  switch (data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallow(data)
    case 'AfricanSwallow':
      return new AfricanSwallow(data)
    case 'NorwegianBlueParrot':
      return new NorwegianBlueParrot(data)
    default: 
      return new Bird(data)
  }
}

class Bird {
  constructor(data) {
    this._name = data.name
    this._plumage = data.plumage
  }
  get name () {return this._name}
  get plumage() {
  return this._plumage || 'average'
  }
  get airSpeedVelocity() {return null}
}

class EuropeanSwallow extends Bird {
  get airSpeedVelocity() {return 35}
}

class AfricanSwallow extends Bird {
  constructor(data) {
    super(data)
    this._numberOfCoconuts = data.numberOfCoconuts
  }
  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts
  }
}

class NorwgianBLueParrot extends Bird {
  constructor (data) {
    super(data)
    this._voltage = data.voltage
    this._isNailed = data.isNailed
  }
  get plumage() {
    if (this._voltage > 100) return 'scorched'
    else return this._plumage || 'beautiful'
  }
  get airSpeedVelocity() {
    return (this._isNailed) ? 0: 10 + this._woltage / 10
  }
}
```

上面这个关于鸟`bird`的系统很快有一个大的变化：这些鸟是“野生的`wild`”，有些鸟是“家养的`captive`”，两者之间的行为会有很大差异。这种差异可以建模为`Bird`类的两个子类：`WildBird`和`CaptiveBird`。但继承只能使用一次，所以如果想用子类来表现”野生“和”家养“的差异，就得先去掉关于”不同品种”的继承关系。

在涉及多个子类时，我回一次处理一个子类，先从简单的开始——这里最简单的是`EuropeanSwallow`（欧洲燕）。我先给它建一个空的委托类。

```javascript
class EuropeanSwallowDelegate {

}
```

委托类中展示还没有传入任何数据或反向引用。在这个例子中，我会在需要时引入这些参数。

现在需要决定如何初始化委托字段。由于构造函数接受的唯一参数`data`包含了所有信息，我决定在构造函数中初始化委托字段。考虑到有多个委托对象要添加，我会建一个函数，其中更具类型码`data.type`来选择适当的委托对象。

```javascript
class Bird...
constructor (data) {
  this._name = data.name;
  this._plumage = data.plumage
  this._speciesDelegate = this.selectSpeciesDelegate(data)
}

selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate()
    default: return null
  }
}
```

结构设置完毕，可以用*搬移函数*把`EuropeanSwallow`的`airSpeedVelocity`函数搬到委托函数中。

```javascript
class EuropeanSwallowDelegate...
get airSpeedVelocity() {return 35}

// 修改超类的 airSpeedVelocity 函数，如果发现有委托对象存在，旧调用之
class Bird...
get airSpeedVelocity() {
  return this._speciesDelegate ? this._speciesDelegate.airSpeedVelocity : null
}

// class EuropeanSwallow...
// get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity}

function createBird(data) {
  switch (data.type) {
    //case 'EuropeanSwallow':
    //  return new EuropeanSwallow(data)
    case 'AfricanSwallow':
      return new AfricanSwallow(data)
    case 'NorwegianBlueParrot':
      return new NorwegianBlueParrot(data)
    default: 
      return new Bird(data)
  }
}
```

接下来处理`AfricanSwallow`子类。为它创建一个委托类，这次委托类的构造函数需要传入`data`参数。

```javascript
class AfricanSwallowDelegate...
constructor(data) {
  this._numberOfCoconuts = data.numberOfCoconuts
}
get airSpeedVelocity() {
  return 40 - 2 * this._numberOfCoconuts
}

class Bird...
selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate()
    case 'AfricanSwallow':
      return new AfricanSwallowDelegate(data)
    default: return null
  }
}

// class AfricanSwallow extends Bird {
//  ...
// }

function createBird(data) {
  switch (data.type) {
    //case 'EuropeanSwallow':
    //  return new EuropeanSwallow(data)
    //case 'AfricanSwallow':
    //  return new AfricanSwallow(data)
    case 'NorwegianBlueParrot':
      return new NorwegianBlueParrot(data)
    default: 
      return new Bird(data)
  }
}
```

接下来是`NorwegianBlueParrot`子类。步骤和前面一样

```javascript
class NorwegianBlueParrotDelegate...
constructor(data) {
  this._voltage = data.voltage
  this._isNailed = data.isNailed
}
get airSpeedVelocity() {
  return (this._isNailed) ? 0 : 10 + this._voltage / 10
}

class Bird...
selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate()
    case 'AfricanSwallow':
      return new AfricanSwallowDelegate(data)
    case 'NorwegianBlueParrot':
      return new NorwegianBlueParrot(data)
    default: return null
  }
}
```

但`NorwegianBlueParrot`还覆写了`plumage`属性，首先我还是用*搬移函数*把`plumage`函数搬移到委托类中，之后修改构造函数，放入`Bird`对象的反向引用。

```javascript
class NorwegianBlueParrot..
get plumage() {
  return this._speciesDelegate.plumage
}

class NorwegianBlueParrotDelegate...
constructor(data, bird) {
  this._bird = bird
  this._voltage = data.voltage
  this._isNailed = data.isNailed
}
get plumage() {
  if (this._voltage > 100) return 'scorched'
  else return this._bird._plumage || 'beautiful'
}

class Bird...
selectSpeciesDelegate(data) {
  switch(data.type) {
    // ...
    case 'NorwegianBlueParrot':
      return new NorwegianBlueParrot(data, this)
    default: return null
  }
}
```

麻烦之处在于如何去掉子类中的`plumage`函数。此时可以采用继承——用*提炼超类*从各个代理类中提炼出一个共同继承的超类。

```javascript
class SpeciesDelegate {
  constructor(data, bird) {
    this._bird = bird
  }
  get plumage () {
    return this._bird._plumage || 'average'
  }
  get airSpeedVelocity() {return null}
}

class EuropeanSwallowDelegate extends SpeciesDelegate {
  get airSpeedVelocity() {return 35}
}

class AfricanSwallowDelegate extends SpeciesDelegate {
  constructor(data) {
    this._numberOfCoconuts = data.numberOfCoconuts
  }
  get airSpeedVelocity() {
    return 40 - 2 * this._numberOfCoconuts
  }
}

class NorwegianBlueParrotDelegate extends SpeciesDelegate {
  constructor(data, bird) {
    this._bird = bird
    this._voltage = data.voltage
    this._isNailed = data.isNailed
  }
  get airSpeedVelocity() {
    return (this.isNailed) ? 0 : 10 + this._voltage / 10
  }
  get plumage() {
    if (this._voltage > 100) return 'scorched'
    else return this._bird._plumage || 'beautiful'
  }
}


function createBird(data) {
  return new Bird(data)
}

class Bird...
constructor(data) {
  this._name = data.name
  this._plumage = data.plumage
  this._speciesDelegate = this.selectSpeciesDelegate(data)
}
get name() {return this._name}
get plumage() {return this._speciesDelegate.plumage}
get airSpeedVelocity() {return this._speciesDelegate.airSpeedVelocity}

selectSpeciesDelegate(data) {
  switch(data.type) {
    case 'EuropeanSwallow':
      return new EuropeanSwallowDelegate()
    case 'AfricanSwallow':
      return new AfricanSwallowDelegate(data)
    case 'NorwegianBlueParrot':
      return new NorwegianBlueParrot(data)
    default: return new SpeciesDelegate(data, this)
  }
}
// rest of Bird code...
```

在这个例子中，我用一系列委托类取代了原来的多个子类，与原来非常相似的继承结构被转移到`SpeciesDelegate`下面。除了给`Bird`类重新被继承的机会，同时新的继承体系范围更收拢了，只涉及各个品种不同的数据和行为，各个瓶中相同的代码则全部留在了`Bird`类中，他未来的子类也将得益于这些公共的行为。

### 以委托取代超类

**动机**

在面向对象程序中，通过继承来复用现有功能，是一种既强大又便捷的手段。我只要继承一个已有的类，覆写一些功能，再添加一些功能，就能达成目的。但继承也有可能造成困扰和混乱。

在对象技术发展早期，有一个经典的误用继承的例子：让栈`stack`继承列表`list`。这个想法的出发点是想复用类的数据存储和操作能力。但这个继承关系有问题：列表类的所有操作都会出现在栈类的接口上，然而其中大部分操作对一个栈来说并不适用，这就是一个用得上*以委托取代超类*手法的例子——如果超类的一些函数对子类并不适用，就说明我不应该通过继承来获得超类的功能。

比如一个车模类，其中有些属性我可能想用来表示真正的汽车，然而汽车终究不是模型，所以此时如果把继承关系将部分职能委托给另一个对象，这些混乱和错误本事可以轻松避免的。使用委托关系更能清晰地表达"这是另一个东西，我只是需要用到其中携带的一些功能"，

**做法**

1. 在子类中新建一个字段，使其使用超类的一个对象，并将这个委托引用初始化为超类的新实例。
2. 针对超类的每个函数，在子类中创建一个转发函数，将调用请求转发给委托引用。每转发一块完整逻辑，都要执行测试。
3. 当所有超类函数都被转发函数覆写后，就可以去掉继承关系。

**范例**

我最近给一个古城里存放上古卷轴`scroll`的图书馆做了咨询。他们给卷轴的信息编制了一份目录`catalog`，每份卷轴都有一个ID号，并记录了卷轴的标题`title`和一些列标签`tag`。

```javascript
class CatalogItem...
constructor(id, title, tags) {
  this._id = id
  this._title = title
  this._tags = tags
}

get id() {return this._id}
get title() {return this._title}
hasTag(arg) {return this._tags.includes(arg)}

// 这些卷轴需要日常清扫，因此代表卷轴的 scroll 类继承了代表目录项的 CatalogItem 类，并扩展出与“需要清扫”相关的数据
class Scroll extends CatalogItem...
constructor(id, title, tags, dateLastCleaned) {
  super(id, title, tags)
  this._lastCleaned = dateLastCleaned
}

needsCleaning(targetDate) {
  const threshold = this.hasTag('revered') ? 700 : 1500
  return this.daysSinceLastCleaning(targetDate) > threshold
}

daysSinceLastCleaning(targetDate) {
  return this._lastCleaned.until(targetDate, ChronoUnit.DAYS)
}
```

这是一个常见的建模错误，真是存在的卷走和只存在于纸面上的目录项，是完全不同的两种东西。我希望改变这两个类的关系。

首先在`Scroll`类中创建一个属性，令其指向一个新建的`CatalogItem`实例。

```javascript
class Scroll extends CatalogItem...
constructor(id, title, tags, dateLastCleaned) {
  super(id, title, tag)
  this._catalogItem = new CatalogItem(id, title, tags)
  this._lastCleaned = dateLastCleaned
}

// 对于子类中用到所有属于超类的函数，需要逐一为它们创建转发函数
class Scroll...
get id() {return this._catalogItem.id}
get title() {return this._catalogItem.title}
hasTag(aString) {return thsi._catalogItem.hasTag(aString)}
```

之后去除`Scroll`与`CatalogItem`之间的继承关系

```javascript
class Scroll {
  constructor(id, title, tags, dateLastCleaned) {
  // super(id, title, tag)
  this._catalogItem = new CatalogItem(id, title, tags)
  this._lastCleaned = dateLastCleaned
}
```

前面的重构把`CatalogItem`变成了`scroll`的一个组件：每个`Scroll`对象包含一个独一无二的`CatalogItem`对象。在使用本重构的很多情况下，这样处理就足够了，但这个例子中，更好的建模方式应该是：关于灰鳞病的一个目录项，对应于图书馆中的6份卷轴，应为这6分卷轴都是同一个标题。这实际上是要运用*将值对象改为引用对象*。

但在原本的继承结构中，`Scroll`类使用了`CatalogItem`类的`id`字段来保存自己的ID，但此时我应该使用`Scroll`类自己的`id`字段。

```javascript
class Scroll {
  constructor(id, title, tags, dateLastCleaned) {
  this._id = id
  this._catalogItem = new CatalogItem(null, title, tags)
  this._lastCleaned = dateLastCleaned
}

get id() {return this._id}
```

用`null`作为ID值创建目录项，这种操作一般而言应该触发警告了，所以等我重构完成，多个卷轴会指向一个共享的目录项，而后者也会有合适的ID，此时把整个目录对象及目录项的ID都作为参数传给`Scroll`的构造函数。

```javascript
class Scroll...
// Scroll 的构造函数已经不再需要传入 title 和 tags 这两个参数了
constructor (id, dateLastCleaned, catalogID, catalog) {
  this._id = id
  // 用传入的 catalogID 来查找对应的 CatalogItem 对象，并引用这个对象（而不是引用这个对象）
  this._catalogItem = catalog.get(catalogID)
  this._lastCleaned = dateLastCleaned
}
```

end