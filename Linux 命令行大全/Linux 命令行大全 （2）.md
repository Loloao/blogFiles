# Linux 命令行大全 （2）

常见任务和主要工具

## 软件包管理

决定 Linux 发行版本最重要的因素是软件包系统和支持该发行版本社区的活力。软件包管理是一种在系统上安装、维护软件的方法。虽然所有主流的 Linux 发行版本都提供了强大而复杂的维持系统运行的图形化见面操作主程序，但学习命令行程序同样重要

### 软件包系统

不同的 Linux 发行版用当是不同的软件包系统，并且原则上，适用于一种发行版的软件包与其他版本是不兼容的。大多数版本采用的还是下表中所列的两个软件包系统

Debian 类（.deb 技术）：Debian、Ubuntu、Xandros、Linspire

Red Hat 类（.rpm 技术）：Fedora、CentOS、Red Hat Enterprise Linux，openSUSE、Mandriva、PCLinuxOS

### 软件包系统工作方式

Linux 系统所有软件都可在网上找到，并且多数是一软件包文件的形式由发行商提供，其余以可手动安装的源代码形式存在

**软件包文件**

包文件是组成软件包系统的基本软件单元，它是由组成软件包的文件压缩而成的文件集。许多软件包中还包含了安装软件包前后执行配置任务的安装脚本

包文件通常由软件维护者创建，改为护着通常（并不总是）是发行商的职员。包维护者从上游供应商获得软件源代码，然后进行编译，并创建包的元数据及其他必须的安装脚本

**库**
如今多数软件包均由发行商或感兴趣的第三方创建。LInux 用户可以从其所使用的 Linux 版本的中心库中获得软件包

在软件开发生命周期的不容阶段，一个发行版本可能会维护多个不同仓库

**依赖关系**

几乎没有任何一个程序是独立的。与之相反，程序之间相互依赖彼此完成既定工作。一些共有的操作，比如输入/输出操作，就是有多个程序共享的例程执行。这些例程存储在共享库里面，共享库里面的文件为国歌程序提供必要的服务。现代软件包管理系统都提供依赖性解决策略，从而确保用户安装了软件包的同时也安装了其所有的依赖关系

**高级和低级软件包工具**
软件包管理系统通常包含两类工具——执行如安装、删除软件包文件等任务的低级工具和进行元数据搜索及提供依赖性解决的高级工具。本章主要介绍 Debian 类型的系统所提供的软件包工具和最近的 Red-Hat 系列产品使用的工具

### 常见软件包管理任务

命令行软件包管理工具可以完成许多操作，下面我们介绍一些常见的，有一点要说明，低级工具也支持软件包文件的创建，但不在本书的讨论范围

**在库里面查找软件包**

通过使用高级工具来搜索库元数据时，我们可以根据包文件名或其描述来查找该包

Debian 系统：`apt-get update` `apt-cache search search_string`

Red Hat 系统：`yum search search_string`

例如，在 Red Hat 系统的 yum 库中搜索 emacs 文本编辑器的代码如下

`yum search emacs`

**安装库中的软件包**

高级工具允许从库中下载、安装软件包，同时安装所有的依赖包

Debian 系统：`apt-get update` `apt-get install package_name`

Red Hat 系统：`yum install package_name`

例如，在 Debian 系统安装 apt 元数据库中的 emacs 文本编辑器的代码如下

`apt-get update` `apt-get install emacs`

**安装软件包文件中的软件包**

如果软件包文件并不是从库源中下载的，那么我们就可用低级工具直接安装

Debian 系统：`dpkg --install package_file`

Red Hat 系统：`rpm -i package_file`

**删除软件包**

卸载软件包既可利用高级工具也可利用低级工具，高级工具命令如下

Debian 系统：`apt-get remove package_name`

Red Hat 系统：`yum erase package_name`

**更新软件包**

最常见的软件包管理任务是保持系统安装最新的软件包

Debian 系统：`apt-get update` `apt-get upgrade`

Red Hat 系统：`yum update`

**更新软件包文件中的软件包**

如果软件包的更新版本已从非库源中下载，那么我就可以用下表命令进行安装更新取代原版本

Debian 系统：`dpkg --install package_file`

Red Hat 系统：`rpm -U package_file`

**列出已安装的软件包列表**

Debian 系统：`dpkg --list`

Red Hat 系统：`rpm -qa`

**判断软件是否安装**

Debian 系统：`dpkg --status package_name`

Red Hat 系统：`rpm -q package_name`

**显示已安装软件包的相关信息**

Debian 系统：`apt-cache show package_name`

Red Hat 系统：`yum info package_name`

**查看某具体文件由哪个软件包安装得到**

Debian 系统：`dpkg --search file_name`

Red Hat 系统：`rpm -qf file_name`

## 存储介质

对于诸如硬盘之类的物理存储器、网络存储器以及像 RAID 和 LVM 之类的虚拟存储器，Linux 都有惊人的处理能力

### 挂载、卸载存储设备

多数情况下，设备只要连接上系统就能运作。但是，像服务器这类的非图形界面的的操作系统通常都有一些机制的存储需求和复杂的配置要求，所以在这类系统中管理存储设备很大程度上还是靠手动操作

管理存储设备搜先要做的就是将该设备添加到文件系统树中，从而允许操作系统可以操作该设备，这个过程称之为挂在。这与 MS-DOS、Windows 不同，它们对于每个设备都有独立的树

**查看已挂载的文件系统列表**

`mount`命令用于文件系统挂载，不带任何参数输入该命令会调出目前已经挂载过的文件系统列表，文件地格式是：*device* on *mont_point* type *filesystem_type* (options)

获取设备名后，便可以写在该设备，然后将其挂载在文件系统树的另外一个节点上。进行此操作，必须首先获得超级用户权限，使用`unmount`命令卸载

`unmount device`

> 为什么卸载如此重要？
>
> free 命令会输出关于存储器使用情况的一些数据，buffer(缓存)就包括在其中，计算机系统是以运行得尽可能快为原则设计的，阻碍计算机运行速度的一大因素就是低速设备。计算机可以把尊卑发给低速设备的数据先发送给缓冲区，从而计算机能尽快返回去处理其他进程
>
> 卸载设备能够确保缓存中的所有剩余数据全部写入设备，从而设备能被安全移除

**确定设备名称**

如果读者使用的系统不能自动挂载可移动设备，那么下面介绍的方法来命名插入系统的可移动设备。首先，对`/var/log/messages`文件进行实时查看

`sudo tail -f /var/log/messages`

接着插入可移动设备，再插入瞬间，内核就能检测到设备

之后注意用`[]`包裹的设备名，直接用`sudo mount /dev/sdb1 /mnt/flash`即可挂载到闪存节点

### 创建新的文件系统

将一个使用 FAT32 文件系统的闪存驱动器重新格式化为 Linux 本地文件系统，需要两个步骤：1. 在对现有分区不满意的情况下创建一个新的分区布局；2. 在驱动器上创建一个新的空文件系统

*下面是一个格式化闪存驱动器的例子*

**使用 fdisk 命令进行磁盘分区**

`fdisk`命令实现用户与磁盘设备（比如硬盘驱动器和闪存驱动器）进行较低层次的直接交互。该工具可以用来编辑、删除以及创建设备分区。使用闪存前，我们必须首先将其卸载，然后在启动 fdisk 程序

`sudo umount /dev/sdb1` `sudo fdisk /dev/sdb`

程序启动后，会出现如下提示信息：

`Command (m for help):`

输入`m`会出现程序菜单，接着按下`p`打印显示设备分区列表，之后我们需要将分区类型改为新的分区 ID 也就是 Linux 分区，按下`l`显示所有可能分区类型的对照表。之后输入`t`和新的 ID 就完成了分区 ID 的修改，之后我们就该向设备写入修改后的分区表，然后退出，输入`w`

**用 mkfs 命令创建新的文件系统**

分区编辑已完成，我们便可以在内存上创建新的文件系统。`mkfs`命令可以用来创建各种类型的文件系统，比如我们想要创建 ext3 文件系统

`sudo mkfs -t ext3 /dev/sdb`

### 测试、修复和文件系统

系统每次启动时，挂载文件系统前都会惯例性地检查文件系统的完整性，此检查过程是由fsck（filesystem check 的缩写）程序完成的，ftab 文件的每个条目末尾的数字正是对应设备的检查优先级。

除了检查文件系统的完整性外，fsck 还能修复损坏的文件系统，修复程度取决于损坏程度。对于类 UNIX 系统，已修复文件会放在系统根目录下的`lost + found`目录中

下面的命令可以用来检查闪存

`sudo fsck /dev/sdb1`

> 在 UNIX 文化中 fsck 是 fuck 的代替写法

### 格式化软盘

首先对软盘进行一个低级格式化操作，然后创建一个文件系统

`sudo fdformat /dev/fd0`后`sudo mkfs -t msdos /dev/fd0`

### 直接从/向设备转移数据

虽然，我们通常认为电脑上的数据都是以文件的形式存储的，但也有可能会认为数据以"原始"形式存储。以磁盘驱动器为例，它包含了许多被操作系统当作目录或文件的数据“块”。如果可以简单地把磁盘驱动器当作一个大数据块集，那么我们就可以执行一些有用任务，诸如克隆设备等

dd 程序可以完成这样的任务，该命令将数据块从一个地方复制到另一个地方，由于历史原因，该命令使用句法比较独特

`dd if=input_file of=output_file [bs=block_size [count=blocks]]`

假定现有两个容量一样的U盘，并且我们希望将第一个U盘里的内容准确完全地复制到第二个U盘里面

`dd if=/dev/sdb of=/dev/sdc`

或者，如果只有i的一个盘连接到电脑上，那么我们可以将其内容先复制到一个普通的文件里以备后续储存或复制

`dd if=/dev/sdb of=flash_drive.img`

> dd 是由 data definition 两个单词缩写而来，千万不要把指定的设备名输入错

### 创建 CD-ROM 映像

向 CD-ROM 写入数据包括两个步骤：拆功能键一个 ISO 映像文件，也就是 CD-ROM 文件系统映像；其次，将此映像文件写入到 CD-ROM 介质中

**创建一个 CD-ROM 文件映像副本**

`dd if=/dev/cdrom of=ubuntu.iso`

该方法适用于数据类 DVD，但不适用于音频 DVD，因为音频 DVD 并不适用文件系统实现存储。对于音频 CD，可以使用`cdrdao`命令

**从文件集合中创建映像文件**

enisoimage 程序通常用于创建包含一个文件目录的 ISO 映像文件。首先我们创建一个目录，该目录包含了我们希望加进映像文件里的文件，然后运行 enisoimage 程序创建映像文件。

`genisoimage -o cd-rom -R -J ~/cd-rom-files`

### 向 CD-ROM 写入映像文件

映像文件创建好后，下一步是将其刻录进光学介质中。下面我们所讨论的大部分命令都是用于 CD-ROM 和 DVD 介质

**直接挂载 ISO 映像文件**

当 ISO 映像文件仍在硬盘上时，我们可以把它当作已存在于光学介质中，并且有一个敲门可以实现该映像文件的挂载就是通过增加`-o loop`选项来挂载，如此便可以把映像文件当作设备一样挂载在文件系统树上了

`mkdir /mnt/iso_image` `mount -t iso9660 -o loop image.iso /mnt/iso_image`

在上面例子中，我们创建了一个叫做`/mnt/iso_image`挂载节点并将`image.iso`映像文件挂载在该节点上。映像文件挂载成功后，就可以把它当作真实的 CD-ROM 或 DVD

**擦除可读写 CD-ROM**

可擦写 CD-ROM 在重用之前需要被擦除或清空，我们可以通过`wodim`命令指定光盘刻录机操作对象的设别名以及所要执行的擦除类型来完成，`wodim`程序提供多种擦除类型，最基本的就是 fast 类型

`wodim dev=/dev/cdrw blank=fast`

**写入映像文件**

同样我们使用`wodim`命令写入映像文件，通过指定写入的光介质刻录设备的名字以及映像文件的名字来完成

`wodim dev=/dev/cdrw image.iso`

### 附加认证

通常，确认所下载的 ISO 映像文件是否完整大有必要，多数情况下，ISO 映像文件的发行商提供一个校验和文件，检验和是通过一种奇异的数学计算得到而以数字形式表示的计算值，它代表了目标文件的内容。示例如下

`md5sum image.iso`

得出校验和后与供应商提供的`md5sum`校验和数知进行比较验证

## 网络

在网络连接方面，Linux 可以说是万能的。Linux 工具可以建立各种网络系统及应用，包括防火墙、路由器、域名服务器、NAS 盒等

### 检查、检测网络

即使你不是系统管理员，经常检查网络的性能和运行情况也是很有必要的

**ping——向网络主机发送特殊数据包**

最基本的网络连接命令就是`ping`命令。它会向指定的网络足迹发送特殊网络数据包`IMCP ECHO_REQUEST`。多数网络设备收到该数据包后会收到回应，通过此法即可验证网络链接是否正常

> 有时从安全角度出发，通常会配置部分网络通信设备以忽略这些数据包，防火墙经常被设置为阻碍IMCP通信

例如我使用`ping`命令验证是否可以登陆网站`http://www.linuxcoommand.org/`：

`ping linuxcommand.org`

一旦程序启动，`ping`命令就会以既定的时间间隔（默认1s）传送数据包知道该命令被中断

**traceroute——跟踪数据包的传输路径**

`traceroute`程序会显示文件通过网络从本地系统传输到指定主机过程中所有停靠点的列表。

`traceroute slashdot.org`

**netstat——检查网络设置及相关统计数据**

`netstat`程序可以用于查看不同的网络设置及数据。通过使用丰富的参数选项，我们可以查看网络启动过程的许多特性。比如，使用`-ie`选项，我们可以检查系统中的网络接口信息。

`netstat -ie`

输出信息会显示系统的网络端口，对网络进行日常诊断，关键是看能够在每个接口信息第四行的开头找到`UP`这个词以及能否在第二行的`inet addr`字段找到有效的 IP 地址。第四行的`UP`代表该网络接口已启用，而对于使用动态主机配置协议的系统（DHCP），`int addr`字段里的有效 IP 地址则说明了 DHCP 正在工作

使用`-r`选项将显示内核的网络路由表，此表显示了网络之间传送数据包时网络的配置情况

要了解整个参数列表可以查看`netstat`的 man 手册页

### 通过网络传输文件

只有掌握了如何通过网络转移文件，才会明白网络的作用之大

**ftp——采用 FTP（文件传输协议）传输文件**

`ftp`是 Linux 比较经典的命令之一，由`File Transfer Protocol` 协议缩写而来。大多数 Web 浏览器都支持`ftp`命令

`ftp`程序比 Web 浏览器出现的早，它用来与 FTP 服务器进行通信，所谓 FTP 服务器就是那些包含共网络上传、下载文件的机器

FTP 并不安全，因为它以铭文的方式传送账户名以及密码。这意味着这些信息并没有加密，任何一个接触网络的人都能看到他们。所以几乎所有使用 FTP 协议进行的网络文件传输都由匿名 FTP 服务器处理，匿名服务器允许任何人使用`anonymous`登录名以及无意义的密码登录

`ftp fileserver`

**lftp——更好的 ftp（文件传输协议）**

ftp 并不是唯一的命令行 FTP 客户端。事实上，有很多这样的命令行，其中一个好用又受欢迎的一个是`lftp`，它与`ftp`功能类似但却还有很多额外的便利功能。

**wget——非交互式网络下载工具**

`wget`是另一个用于文件下载的命令行程序，该命令既可以用于网站下载内容也可用于从 FTP 站点下载，单个文件、多个文件甚至整个网站都可以被下载

`wget http://linuxcommand.org/index.php`

`wget`命令的许多参数选项支持递归下载、后台文件下载以及继续下载部分被下载的文件等操作

### 与远程主机的安全通信

在多年以前，所有信息都是以明文传输的，所以它们并不适用于互联网时代

**ssh——安全登录远程计算机**

为了解决明文传输的问题，一个叫 SSH（Secure Shell 的缩写）的新协议应运而生。SSH 协议解决了与远程主机进行安全通信的两个基本问题：第一，该协议能验证远程主机的身份是否真实，从而避免中间人攻击；第二，该协议将本机与远程主机之间的通信内容全部加密

SSH 协议包括两个部分：一个是运行在远程主机上的 SSH 服务端，用来监听端口 22 上可能过来的连接请求；另一个是本地系统上的 SSH 客户端，用来与远程服务器进行通信

多数 Linux 发行版都采用 BSD 项目的 openSSH（SSH 的免费开源实现）方法实现 SSH。有些发行版本提供服务器端和客户端，但有些只提供客户端（如 ubuntu）

`ssh`命令作为 SSH 客户端程序用于建立与远程 SSH 服务器之间的通信

`ssh remote-sys`

之后可以输入账号密码使用服务器的远程 shell

`ssh`命令除了能开启远程系统上的 shell 会话外，还能再远程系统上执行单个简单命令，比如`free`命令并将结果直接输出到本地系统上

`ssh remote-sys free`

该特性可以有更有趣的用途，比如在远程系统上执行`ls`命令后直接将运行结果输出到本地系统的文件中

`ssh remote-sys 'ls *' > dirlist.txt`

此处使用单引号是因为我们不希望本该在远程主机上进行的路径扩展在本地系统上进行，如果我们还希望执行结果能够直接输出在远程系统中，就该把重定向符号和文件名一起置于单引号中

`ssh remote-sys 'ls * > dirlist.txt'`

> ssh 的隧道技术
>
> 通过 SSH 与远程主机建立连接后，一个本地与远程系统之间的加密隧道就被建立了。通常，该隧道用于将在本地系统输入的命令安全地传送给远程系统并将结果安全地传送回来。除了这样的功能意外，SSH 协议还可建立某种虚拟专用网络（VPN，Virtual Private Network）

**scp 和 sftp——安全传输文件**

OpenSSH 软件包包含了两使用 SSH 加密隧道进行网络间文件复制的程序，`scp（secure copy 的缩写）`就是其中之一，它与`cp`命令之间最大的差别在于`scp`命令的源或目的地路径前面多个远程主机名和冒号。

`scp remote-sys:document.txt .`

与 ssh 命令一样，如果不是用本地系统的用户名登陆远程系统，那么就需在远程主机名前添加将要登陆的远程系统的账户名

`scp bob@remote-sys:document.txt .`

`sftp`是`ftp`程序的安全版本，只是`sftp`是用SSH加密隧道传输信息而不是以明文方式传输，而且它并不需要远程主机上运行 FTP 服务器，仅仅需要 SSH 服务器。这就意味着任何与 SSH 客户端连接的远程机器都可以当作 FTP 服务器使用

`sftp remote-sys` => `ls` => `lcd Desktop` => `get ubuntu-8.04-desktop-i386.iso`

## 文件搜索

### locate——较简单的方式查找文件

`locate`命令通过快速搜索数据库，以寻找路径名与给定子字符串相匹配的文件，同时输出所有匹配结果，例如，假定查找名称以`zip`字符串开头的程序，由于查找的是程序文件，所以可以认为包含所查找的程序的目录名应以`bin/`结尾

`locate bin/zip`

`locate`程序将搜索该路径名数据库，并输出文件名包含`bin/zip`的所有文件

locate 程序已经使用了很多事件，因此出现了多种衍生体。`slocate`和`mlocate`通常是由名为i`locate`的符号链接访问，不同版本的`locate`有一些相同的选项设置，而有些版本则包括正则表达式匹配和通配符支持等。可通过`locate`的 man 手册确定系统安装的是哪个版本的`locate`

>locate 的搜索数据库从何而来
>
>locate 的搜索数据库由另外一个叫做 updatedb 的程序创建，通常该程序作为一个 cron 任务定期执行，多数装有 locate 命令的系统每天执行一次 updatedb 命令，所以 locate 命令查找不到非常新的文件，解决方法就是切换为超级用户，在提示框下手动运行 updatedb 程序

### find——较复杂的方式查找文件

`locate`程序查找文件仅仅是一句文件名，而`find`程序则是一句文件的各种属性在既定的目录（及其子目录）里查找

`find ~`

上面命令会给出当前系统主目录下的文件列表清单

`find`命令的美妙之处就是可以用来搜索符合特定要求的文件，它通过综合应用`test`选项、`action`选项以及`option`选项实现高级文件搜索，下面先来介绍`test`选项

**test 选项**

假定我们想要查找的是目录文件，我们可以添加下面的`test`选项

`find ~ -type d | wc -l`

添加`test`参数`type d`可以将搜索范围限制为目录，而下面例子中使用`-type f`则表示只对普通文件进行搜索

`find ~ -type f | wc -l`

下面列出了`find`命令支持的常见文件类型

`b`：块设备文件

`c`：字符设备文件

`d`：目录

`f`：普通文件

`l`：符号链接

另外我们还可以通过添加其他的`test`项参数实现一句文件大小和文件名的搜索。如下命令行就是用来查找所有符合`*.JPG`通配符格式以及大小超过`1MB`的普通文件

`find ~ -type f -name "*.JPG" -size +1M | wc -l`

注意这里将通配符扩在双引号中是为了避免 shell 路径名扩展，另外添加的`-size +1M` `test`选项，前面的加号表示查找的文件大小比给定的数值`1M`大，减号为小，没有符号为完全相等，末尾的`M`是`MB`的简写，下面列出了每个字母与特定计量单位的对应关系

`b`：512字节的块

`c`：字节

`w`：两个字节的字

`k`：KB（每单位包含1024字节）

`M`：MB（每单位包含1048,576字节）

`k`：GB（每单位包含1,073,741,824字节）

`find`命令支持多种`test`参数，想要了解可以查看`find`的 man 手册页，注意`+`和`-`的用法适用于所有用到数值参数的情况

**操作符**

即使拥有`find`命令提供的所有`test`参数，我们仍然会需要一个更好的工具来描述`test`参数之间的逻辑关系，我们可以用下面的命令行来确定某目录下是否所有的文件和子目录都有安全的访问权限

`find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700\)`

下表是`find`命令的逻辑操作符

`-and`：查找使该操作符两边的检验条件都是针对匹配文件，有时直接缩写成`-a`，如果两个检测条件之间没有显式的显示操作符，`and`就是默认的逻辑关系

`-or`：查找该操作符任何一边的检测条件为真的匹配文件，有时直接缩写成`-o`

`-not`：查找该操作符后面的检测条件为假的匹配文件，有时直接缩写成`-!`

`()`：由于扰乱默认的执行顺序，括号字符在 shell 环境中有特殊意义，所以需要用引号括起来或是用反斜杠作为`find`的参数传递

另外如果有两个被逻辑操作符分开的表达式，中间的操作符会决定第二个表达式是否执行，而这一心智将直接影响下一步`actions`选项的动作行为

**action 选项**

`find`命令允许直接对搜索结果执行动作

*预定义动作*

`-delete`删除匹配文件，在使用此操作符时最好先用`-print`操作确认搜索结果

`-ls`对匹配文件执行`ls`操作，以标准格式输出其文件名以及所要求的其他信息

`-print`将匹配的文件的全路径以标准形式输出，没指定任何具体操作时，该操作是默认操作

`-quit`一旦匹配就退出

更全面的选项可以参考`find`的 man 手册

比如使用`find`命令删除满足条件的文件

`fine ~ -type f -name '*.BAK' -delete`

*用户自定义操作*

除了已有的预定义操作命令，同样也可以任意调用用户想要执行的操作命令。传统的方法就是像以下命令行使用`-exec`操作

`-exec command {}`

上面格式中的 command 表示要执行的操作命令名，`{}`表示当前路径，二分号作为必须的分隔符表示命令结束，使用`-exec rm '{}' ';'`由于括号和分号字符在 shell 环境下有特殊含义，所以需要用引号引起来或用转义符隔开

当然，交互式地执行用户自定义操作也不是不可能。通过使用`-ok`操作取代原来的`-exec`操作，每一次指定命令执行之前都会询问用户

`find ~ -type f -name 'foo*' -ok ls -l '{}' ';'`

*提高效率*

当使用`-exec`操作时，每次查早到匹配文件后都会调用一次指定命令。但有时用户更希望只调用一次命令就完成对所有匹配文件的操作。

将上面命令改成下面的命令行

`find ~ -type f -name 'foo*' -ok ls -l '{}' +`

我们能得到相同的结果，但是系统整体只执行一次`ls`命令

同样我们可以使用`xargs`命令获得相同的效果，`xargs`处理标准输入信息并将其转变为某指定命令的输入参数列表，结合前面的实例，我们可以这样使用`xargs`命令

`find ~ -type f -name 'foo*' -print | xargs ls -l`

该命令行中，`find`命令的执行结果直接作为`xargs`输入，`xargs`反过来将其转换成了`ls`命令的输入参数列表，最后执行`ls`操作

> 虽然一个命令行中可允许输入的参数有很多，但这并不表示可以无限输入。如果命令行中包含的输入参数太多而超过了系统支持的最大长度，xargs 只会尽可能对最大数量的参数执行执行操作，在 xargs 命令后添加 --show-limits 选项，即可知道命令行最大能承受的参数数量

**option 选项**

`option`选项用于控制`find`命令的搜索范围

`-depth`：引导 find 程序处理目录前先处理目录内文件，当指定 -delete 操作时，该参数选项会自动调用

`-maxdepth levels`：当执行测试条件行为时，设置 find 程序陷入目录数的最大级别数

`-mindepth levels`：当执行测试条件行为时，设置 find 程序陷入目录数的最小级别数

`-mount`：引导 find 不去遍历挂载在其他文件系统上的目录

`-noleaf`：指导 find 程序不要基于*正在搜索类 UNIX 文件系统*的假设来优化它的搜索，当扫描`DOS/Windows 文件系统和CD`时，会用到该选项

## 归档和备份

维护系统数据安全是计算机系统管理者的基本任务之一，及时创建系统文件的备份文件是维护系统数据安全的一种常用方法

### 文件压缩

在计算领域的发展历史中，人们一直在努力实现以最小可利用空间存储最多的数据，其中可以用空间包括内存、存储设备或网络带宽，数据压缩是一个移除数据冗余信息的过程

**gzip——文件压缩与解压缩**

`gzip`命令用于压缩一个或更多文件，执行命令后，原文件会被其压缩文件取代，与之相反，`gunzip`命令则将压缩文件还原为原文件

`gzip`有很多选项，下表列出了一些

`-c`：将输出内容写道标准输出端口并且保持原有文件，也可用`--stdout`或是`--to-stdout`替代

`-d`：解压缩，加上此选项相当于`gunzip`，也可用`--decompress`或是`-uncompress`替代

`-f`：强制压缩，可以使用`--force`替代

`-h`：显示有用信息，可用`--help`替代

`-l`：列出所有压缩文件的压缩统计，可用`--list`代替-

`-r`：如果该命令行的操作参数中有一个或多个是目录，那么递归压缩包含在目录终端文件，也可用`--recursive`代替

`-t`：检验压缩文件的完整性，也可用`--test`代替

`-v`：在压缩时显示详细信息，也可用`--verbose`代替

`-number`：设定压缩级别。`number`是`1（速度最快，压缩比最小） ~ 9（速度最慢，压缩比最大）`范围中的一个整数。当然`1~9`的数值也可分别描述为`--fast`和`--best`。`gzip`默认的压缩级别是`6`

如果只是希望查看某个压缩文本文件的内容，可以直接输入下面的命令行

`gunzip -c foo.txt | less` 

`zcat`的功能与`cat`命令相同，只是它的操作对象是压缩文件

`zcat foo.txt.gz | less`与上面命令的功能相同

> 同样也有`zless`命令，与`less`的管道功能相同

**bzip2——牺牲速度以换取高质量的数据压缩**

`bzip2`程序与`gzip`命令功能相仿，但是用不同的压缩算法。该算法具有高至零点数据压缩能力，但降低了压缩速度。多数情况下，其用法与`gzip`类似，只是用`bzip2`压缩后的文件以`.bz2`为后缀

`bzip2 foo.txt` => `bunzip2 foo.txt.bz2`

`bzip2`还有专门的`bzip2recover`命令用于恢复顺坏的`.bz2`文件

### 文件归档

归档是与压缩操作配合使用的一个常用文件管理任务，归档是一个聚集众多文件并将它们组合为一个大文件的过程，它通常作为系统备份的一部分。

**tar——磁带归档工具**

`tar`命令是类UNIX系统中用于归档文件的经典工具。`tar`是`tape archive`的缩写，所以该命令最初始的作用就是磁带备份。大家经常看到的以`.tar`和`.tgz`结尾的文件就是分别用`tar`命令归档和`gzip`归档的文件。`tar`归档文件可以由许多独立的文件、一个或多个目录层次或两者的混合组合而成，用法如下

`tar mode[options] pathname...`

其中`mode`是指下列模式中的一种(全部模式请看 man 手册)

`c`：创建文件和/或目录列表的归档文件

`x`：从归档文件中提取文件

`t`：在归档文件末尾追加指定路径名

`r`：列出归档文件的内容

`tar`命令还可以利用标准输入输出。

`find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz`

先用`find`命令搜索得到匹配文件列表，然后将匹配文件再送至`tar`命令处理。如果文件名前面明确指定有连字符`-`，那就意味着这是标准输入输出的文件（使用`-`代表标准`输入/输出`的管理，其他区多程序也都采用）。`--files-from`选项则指定了`tar`命令从文件中而不是从命令行中读取文件路径名列表。最后，`tar`命令归档后的文件再送至`gzip`进行压缩，由此得到压缩文件`playgrond.tgz`。

但现代 GNU 版本的`tar`命令则提供`gzip + z`选项和`bzip2 + j`直接实现这一功能

`find playground -name 'file-A' | tar czf playground.tgz -T -`

如果想要创建一个`bzip2`压缩的归档文件，可以这么做

`find playground -name 'file-A' | tar cjf playground.tbz -T -`

利用`tar`命令再系统之间传输网络文件，是`tar`另外一个利用标准输入输出的有趣用法

`cd remote-stuff` => `ssh remote-sys 'tar cf - Documents' | tar xf -`

上例中，名为`Documents`的目录从`remote-sys`的远程系统复制到本地系统上的`remote-stuff`的文件目录里

**zip——打包压缩文件**

`zip`程序既是文件压缩工具也是文件归档工具。然而，Linux 系统中，`gzip`才是主要的压缩指令，。Linux 用户主要使用`zip`程序与 windows 系统交换文件，而不是将其用于压缩或是归档文件。

`zip`最基本调用方式如下

`zip options zipfile file...`

创建一个`playground`的`zip`归档文件，可以输入下面的命令行

`zip -r playground.zip playground`

如果不加`-r`选项递归的话，只会保留`playground`这个目录而不包括目录中内容。虽然程序会自动默认添加后缀`.zip`，但为了以示清晰，最好还是在命令行中添加文件后缀

在 zip 归档文件创建的过程中，zip 通常会显示每个新添归档文件的状态。zip 使用两种归档方式向归档文件中添加文件。第一，不对文件进行压缩直接存储；第二，缩小文件大小，即对文件进行压缩后存储。紧随存储方法之后显示的数值表示对是实现的压缩比。

使用`unzip`，我们可以直接提取 zip 文件中的内容

`unzip ../playground.zip`

另外如果指定的归档文件已经存在，那么 zip 仅仅只会更新而不会取而代之。这意味着原来存在的归档文件会保留下来，指示增加了一些新文件，原有匹配文件被替换

通过给`unzip`指定提取的文件名，我们可以选择性地从 zip 归档文件中提取文件

使用`-l`选项，`unzip`只会列出文件内容而不会从中提取文件。如果没有指定任何文件，`unzip`将会提取归档文件中的所有文件，可以增加`-v`得到更详细的列表。当提取文件与已存在文件存在冲突时会提示用户是否执行替换操作

与`tar`命令类似，`zip`命令也可以利用标准输入输出，我们也可以用`-@`选项将多个文件送至 zip 进行压缩

`find playground -name 'file-A' | zip -@ file-A.zip`

`zip`同样可以将结果送至标准输出，但只有极少的命令能够利用其输出结果。`unzip`命令不支持标准输入。

`ls -l /etc/ | zip ls-etc.zip -`

zip 会默认末尾的连字符代表输入带文件是标准输入

当指定`-p`选项后，`unzip`命令会将其输出结果以标准形式输出

`unzip -p ls-etc.zip | less`

更全面的用法请看 man 手册页

### 同步文件和目录

将一个或多个目录与本地系统或是远程系统上其他的目录保持同步，是维护系统备份文件的常用方法。

**rsync——远程文件、目录的同步**

针对类 UNIX 系统，完成这一同步任务最合适的工具当属`rsync`，该协议允许`rsync`命令快速检测到本地和远程系统上两个目录之间的不同，从而以最少数量的复制动作以完成两目录之间的同步。因此，`rsync`命令与其他复制命令相比，显得既快又经济

`rsync`命令调用方式如下：

`rsync options source destination`

这里的`source`和`destination`是下列选项之一：

- 一个本地文件或目录
- 一个远程文件或目录，形式为`[user@]host:path`
- 一个远程`rsync`服务器，由`rsync://[user@]host:[:port]/path`指定

请注意，`source`和`destination`中必须有一个本地文件，因为`rsync`不支持远程系统与远程系统之间的复制

















