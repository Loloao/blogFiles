# Linux 命令行大全

## shell 是什么

当谈到命令行时，我们实际上指的是`shell`。`shell`是一个接受由键盘输入的命令，并将其传递给操作系统来执行的程序。

当使用图形用户界面时，需要另一种叫终端访问器的程序与`shell`进行交互。

如果`shell`提示符的最后一个字符是`#`，而不是`$`，那么终端会话将享有超级用户特权。这就疑问这要么我们是以根用户身份登录，要么我们选择的总段仿真器可以提供超级用户特权。

* 如果紧按鼠标左键选中一些文本并拖动鼠标（或双击选中一个词），按下鼠标的中间按键可以将选中的文本粘贴到光标所在的位置。
* date 显示时间。
* cal 显示日历
* df 查看磁盘驱动器当前的可用空间
* free 显示可用内存
* exit 结束终端会话

## 导航

我们首先需要学习的是如何在 `Linux`系统中导航文件系统

**理解文件系统树**

类`UNIX`操作系统也是以称之为分层目录结构的方式来组织文件的。这意味着文件是在树形结构的目录中进行组织的。文件系统的第一个目录叫做根目录，它包含了文件和子目录。子目录包含了更多的文件和子目录。在类`UNIX`文件系统中，无论多少驱动器或存储设备与计算器相连，通常只有一个文件系统树。

用户所处的目录叫做当前工作目录。使用`pwd`（打印工作目录）命令可以显示当前工作目录。第一次登陆系统时，当前工作目录被设置成主目录。

* `ls`可以列出当前工作目录的文件和目录。
* `cd`命令可以改变工作目录：只需输入`cd`命令，然后再输入目标工作目录的路径名即可。
* `.`表示工作目录。
* `..`表示工作目录的父目录。
* `cd`将工作目录改为主目录
* `cd-`将工作目录改为先前的工作目录。
* `cd-username`将工作目录改为`username`的主目录。例如，`cd~bob`将目录改为用户`bob`的主目录。

> * 以`.`开头的文件名是隐藏的。这仅说明`ls`不会列出这些文件，除非输入`ls-a`。
> * 与`UNIX`一样，在`Linux`中，文件名与命令是区分大小写的。
> * 与其他一些操作系统一样，`Linux`没有文件扩展名的改变。我们可以按照自己的喜好随意给文件命名，尽管类`UNIX`操作系统不使用文件扩展名来决定文件内容或用途，但一些应用程序却这么做了。
> * `Linux`支持长文件名，文件名包含了嵌入的空格和标点符号。但是在创建文件名的过程中，仅句号、连字符和下划线是可以使用的。文件名中不要嵌入空格。

## Linux 系统

* `ls /a /user`可以查看多个目录下的内容。
* `ls -l`可以将输入以长格式显示。

**选项和参数**

下面，让我们了解一下大部分命令是如何工作的。通常，命令后面会有一个或多个选项，带有不同选项的命令其功能也不一样。此外，命令后面还会跟有一个或多个参数，这些参数是命令作用的对象，所以大部分命令看起来如下所示：
`command -option arguments`

大部分命令是在单个字符前加上连字符，如`-l`，但是很多命令也支持在单字前加两个连字符的长选项。而且，很多命令也允许多个短选项串在一起使用。在下面的例子中，`ls`命令包含了两个选项，`l`选项产生长格式的输出，而`t`选项表示以文件修改时间的先后将结果进行排序

`ls -lt`

加上长选项`- -reverse`，则结果会以相反的顺序输出。`ls`常用选项如下

> -a --all 列出所有文件，包括以点号开头的文件
>
> -d --directory 可查看目录的详细信息
>
> -F --classify 选项会在每个所列出的名字后面加上类型指示符（例如，如果名字是目录名，则会加上一个斜杠）
>
> -h --human-readable 以长格式列出，以人们可读的方式而不是字节数来显示文件大小，使用长格式显示结果。
>
> -l 使用长格式显示结果。
>
> -r --reverse 相反的顺序显示结果。
>
> -S 按文件大小对结果排序。
>
> -t 按修改时间排序。

`-l`命令使得`ls`命令以长格式显示其结果。这种格式 包含大量信息。

**less 和 file **

`file`命令可以确定文件类型，打印出文件内容的简短说明。事实上，在类`UNIX`系统中，有个普遍的观念是“所有东西都是一个文件”。

`less`命令是一种查看文本文件的程序。很多文件都含有人们可以阅读的文本。`less`程序为我们查看文件提供了方便。

>有很多方式可以在计算机中表达信息。所有的方式都涉及在信息与一些数字之间确立一种关系，而这些数字可以用来表达关系。
>
>有些表示方法比较复杂，有些简单，其中最早也是最简单的是`ASCII`文本。文本是字符与数字之间的简单的一对一映射，这与文字处理器文档中的文本是不一样的，比如`word`。

`less`命令的使用方式如下

`less filename`

一旦运行起来，`less`程序允许我们前后滚动文件。比如想要查看定义了系统用户账户的文件，可输入下列命令

`less /etc/passwd`

一旦`less`程序运行起来，我们就可以查看文件内容。如果文件不知一夜，可以上下滚动文件。按`Q`键可以推出`less`程序。

>G 跳转到文本文件的末尾
>
>1G 或 g 跳转到文本文件的开头
>
>n 向前寻找下一个出现的字符串，这个字符串是之前所指定查找的
>
>h 显示帮助屏幕
>
>q 退出 less

**快速浏览**

当我们浏览文件系统时，不要担心将文件系统的布局弄得混乱不堪。普通用户不再具有管理文件系统的权限，那是系统管理员的工作。如果一条命令无法执行某些功能，那么继续选择其他命令。下面是一些探索到的目录。

>/ 根目录
>
>/ bin 包含系统启动和运行所必须的二进制文件，包含 Linux 内核、最初的 RAM 磁盘映像（系统启动时，驱动程序会用到），以及自动加载程序
>
>/ boot 有趣的文件：1. /boot/grub/grub.conf 或 menu.lst，用来配置启动加载程序。2. /boot/vmlinuz, Linux 内核
>
>/ dev 这是一个包含设备节点的特殊目录。“把一切当成文件”也适用于设备。内核将它能够识别的所有设备存放在这个目录里。
>
>/ etc 包含了所有系统层面的配置文件，同时也包含了一系列 shell 脚本，系统每次启动时，这些 shell 脚本都会打开每个系统服务。该目录中包含的内容都应该是可读的文本文件
>
>/ home 在通常的配置中，每个用户搜会在 /home 目录中拥有一个属于自己的目录。普通用户只能在自己的主目录中创建文件
>
>/ lib 包含核心系统程序使用的共享库文件。这与 Windows 系统中的 DLL 类似
>
>/ lost + found 每个 Linux 文件系统的格式化分区或设备，例如 ext3 文件系统，都会有这个目录，当文件系统崩溃时，该目录用于恢复分区。
>
>/ media 在现代 Linux 系统中，/media 目录包含可移除媒体设备的挂载点，比如 USB 驱动、CD-ROM 等。这些设备在插入计算机后，会自动挂载到这个目录节点下。
>
>/mnt 在早期的 Linux 系统中， /mnt 目录包含手动挂载的可移除设备的挂接点。
>
>/opt /opt 目录用来安装其他可选的软件。主要用来可能安装在系统中的商业软件。
>
>/proc  它不是存储在硬盘中的真正的文件系统，而是一个 Linux 内核维护的虚拟文件系统。它包含的文件是内核的窥视孔。该文件是可读的，从中可以看到内核是如何监管计算机的。
>
>/root root 账户的主目录
>
>/sbin 该目录放置系统二进制文件。这些系统执行重要的系统任务，这些人物通常是为超级用户预留的。
>
>/tmp 供用户存放各类程序创建的临时文件的目录，某系配置使得每次系统重启时都会清空该目录。
>
>/ usr 可能是 Linux 系统中的最大目录树。它包含普通用户使用的所有程序和相关文件。
>
>/usr/bin 放置了一些 Linux 发行版安装的可执行文件。该目录通常会存储成千上万个程序。
>
>/usr/local 这个目录并非是系统发行版自带，但却打算让系统使用的程序的安装目录，有源代码编译好的程序通常安装在 /usr/local/bin 中，只有系统管理员向其中添加内容。
>
>/usr/sbin 包含更多的系统管理程序。
>
>/usr/share 包含了 /usr/bin 中程序所使用的所有全部共享数据。这包括默认配置文件、图标、屏幕背景、音频文件等。
>
>/usr/share/doc 安装在系统中大部分程序包包含一些文档文件。文档文件是按软件包来组织分类的
>
>/var 除了/tmp 和 /home 目录之外，目前看到的目录相对来说都是静态的。而那些可能改变的数据存储在 /var 目录树里。各种数据库、假脱机文件、用户邮件等都存储在这里。
>
>/var/log 此目录包含的日志文件记录了各种系统活动，在一些系统里，必须是超级用户才能查看日志文件。

**符号链接**

假如说有个文件版本会更新版本，我们可以为它创建一个符号链接，而如果文件版本更新，新版本有程序错误，只需删除新版本的符号链接，重新创建指向旧版本的符号链接即可。

## 操作文件与目录

坦率地讲，使用图形文件管理器来执行一些文件操作会容易得多，那为什恶魔要使用这些命令行操作呢？

原因就在于命令行程序就有强大的功能和灵活的操作。虽然对于图形文件管理器可以轻松实现简单的文件操作，但对于复杂的任务，使用命令行程序更容易完成。

**通配符**

 由于`shell`需要经常使用文件名，因此它提供了一些特殊字符来帮助你快速指定一组文件名。这些特殊字符成为通配符。通配符允许用户一句字符模式选择文件名。

*通配符*

>\* 匹配任意多个字符
>
>? 匹配任意单个字符
>
>[characters] 匹配任一属于字符集中的字符
>
>[!characters] 匹配任一不属于字符集中的字符
>
>[[:class:]] 匹配任一属于指定字符类中的字符

*常用字符类*

>[:alnum:] 任一字母或数字
>
>[:alpha:] 任一字母
>
>[:digit] 任一数字
>
>[:lower:] 任一小写字母
>
>[:up[per:]  任一大写字母

通配符的使用使得为文件名构建复杂的筛选标准成为可能。下面列出一些通配符模式及其匹配内容的示例

* \* 所有文件
* g* 以 g 开头任一文件
* b*.txt 以 b 开头，中间有任意多个字符，并以`.txt`结尾的任一文件
* `Data???`以`Data`开头，后面跟3个字符的任一文件
* `[abc]*`以`abc`中的任一开头的任一文件
* `BACKUP.[0-9][0-9][0-9]`以`BACKUP`开头，后面紧跟3个数字的任一文件
* `[[:upper:]]*`以大写字母开头的任一文件
* `[![:digit:]]*`不以数字开头的任一文件
* `[[:lower:]123]`以小写字母或数字1、2、3中的任一结尾的任一文件

我们最好使用字符类来进行筛选，以`[A-Z][a-z]`形式的字符范围表示法可能会产生非预期的结果

* `mkdir dir1`可创建单个目录，`mkdir dir1 dir2 dir3`可创建多个目录

* `cp item1 item2`复制单个文件或目录，`cp item... directory`复制多个文件或目录进一个目录中

  * `-a, --archive`复制文件和目录及其属性，包括所有权和权限
  * `-i --interactive`在覆盖一个已存在文件前，提示用户进行确认。如果没有指定该选项，`cp`会默认覆盖文件
  * `-r --recursive`递归地复制目录及其内容，复制目录时需要这个选项
  * `-u --update`将文件从一个目录复制进另一个目录时，只会复制那些目标目录中不存在的文件或是目标目录相应文件的更新文件。
  * `-v --verbose`复制文件时，显示信息性消息
  * `cp file1 file2`如果`file2`存在，则会被`file1`内容覆盖，如果`file2`不存在，则创建`file2`
  * `cp -i file1 file2`同上，区别在于会通知用户确认
  * `cp file1 file2 dir1`将`file1`和`file2`复制到目录`dir1`里。`dir1`已存在。
  * `cp -r dir1 dir2`将`dir1`的内容复制进`dir2`，如果`dir2`不存在，则创建`dir2`

* `mv`命令与`cp`命令基本相似，它可以执行文件移动和文件重命名操作。`mv item1 item2`，`mv item... directory`，`mv`命令的很多选项与`cp`命令是共享的，具体参考`cp`

* `rm`用来移除文件和目录，`rm item...`其中`item`是一个或多个文件（或目录）的名称。

  >类 UNIX 操作系统并不包含还原删除操作的命令，一旦使用 rm 命令，就彻底删除了。rm 命令与通配符在一起要特别小心，可以先用 ls 命令预先对通配符进行测试，浙江显示预删除的文件。

  * `-i --interactive`在删除一个已存在文件前，提示用户进行确认。如果没有指定该选项，`cp`会默认覆盖文件
  * `-r --recursive`递归地删除目录及其内容，复制目录时需要这个选项
  * `-f --force`忽略不存在的文件并无需提示确认。该选项会覆盖`--interactive`选项
  * `-v --verbose`删除文件时显示信息性消息
  * `rm -rf`当`file1`或`dir1`不存在时，`rm`仍会继续执行，且不提示用户

* `ln`命令可用来创建硬链接或是符号链接。它的符号有两种，`ln file link`用来创建硬链接，`ln -s item link`用来创建符号链接，这里的`item`可以是文件也可以是目录

**硬链接**

硬链接是最初`UNIX`来创建连接到方式，符号链接较之更为先进。默认情况下，每个文件有一个硬链接，该硬链接会给文件起名字。当创建一个硬链接的时候，也为这个文件创建了一个额外的目录条目。硬链接有两条重要的局限性。

* 硬链接不能引用自身文件系统之外的文件。也就是说，连接不能引用与该链接不在同一磁盘分区的文件。
* 硬链接无法引用目录

硬链接与文件本身没有什么不同，删除了这个链接，这个文件依旧存在（也就是说，该空间没有释放），除非该文件的所有链接都被删除了。

可以想象文件是由两部分组成的，包含文件内容的数据部分和包含文件名的名称部分。创建硬链接时，实际上是创建了额外的名称，这些名称都指向同一数据部分。

`ls -li`中的`-i`可以显示硬链接和文件开头具有相同的索引号。

**符号链接**

符号链接是为了克服硬链接的局限性而创建的。符号链接是通过创建一个特殊类型的文件来起作用的，该文件包含了指向引用文件或目录的文本指针，就这点来看，符号链接与`Windows`系统下的快捷方式非常相似。

符号链接指向的文件与符号链接自身几乎没有区别。例如，将一些东西写进符号链接里，那么这些东西同样也写进了引用文件。当删除一个符号链接时，删除的知是符号链接而没有删除文件本身，如果先删除文件，那么这个链接就成为坏链接。在在很多实现命令中，`ls`命令会用不同颜色来显示坏链接，比如红色。

创建符号链接时，同时也创建一个文本来描述目标文件在哪里与符号链接有关联。

`ln -s ../fun dir1/fun-sym`其中前一个是表示相对于软链接的路径，第二个是表示软链接放在哪。

创建符号链接时，也可以使用绝对路径名。同时也可以引用目录。

## 命令的使用

一条命令无外乎以下4种情况。

* 可执行程序。可执行程序就像在`/usr/bin`目录里看到的所有文件一样。在程序类别中，程序可以编译为二进制文件，比如 C，C++ 语言编写的程序，也可以是 shell、Perl、Python、Ruby等脚本语言编写的程序。
* shell 内置命令。`bash`支持许多在内部称之为`shell builtin`的内置命令。例如`cd`命令就是`shell`内置命令指令。
* shell 函数。`shell`函数是合并到环境变量中的小型`shell`脚本。
* alias 命令。我们可以在其他命令的基础上定义自己的命令。

能够准确地识别我们使用的命令是上面的哪一种是很有用的，Linux 提供了两个方法来识别命令类型。

* `type`命令是一个`shell`内置命令，可根据指定的命令名显示`shell`将要执行的命令类型。格式如下

  `type command`

* 有时系统可能安装了一个可执行程序的多个版本，这种现象在大型服务器中很常见。使用`which`命令可以确定一个给定可执行文件的准确位置

  `which ls`，`which`命令只适用于可执行程序，而不适用于内置命令和命令别命（真正可执行程序的替代物）。

bash 为每个`shell`内置命令提供了一个内置的帮助工具。输入`help`，然后输入`shell`内置命令的名称就可使用该帮助工具。

`help cd`

很多可执行程序都支持`--help`选项，它描述了命令支持的语法和选项。

大多数供命令行使用的可执行文件，提供一个称之为`manual`或是`man page`的正式文档。干文档可以用一种成为`man`的特殊分页程序来查看，用法如下：

`man program`，其中`program`是需要查看的命令名称。，大多数 Linux 系统中，`man`命令调用`less`命令来显示手册文档，所以，当显示手册文档时，你熟悉的所有`less`命令都奏效。

`apropos`显示合适的命令，我们可能会搜索参考手册列表，才进行基于某个搜索条目的匹配。尽管有些粗糙，但这种方法有时还是很有用的。

`whatis`显示命令的简要描述，显示匹配具体关键字的手册页的名字和一行描述。

`info`显示程序的`info`条目，`info`页面可通过`info`阅读器来显示。`info`页面使用超链接，这与网页结构很相似。`info`程序读取`info`文件，该文件是树形结构，分为各个单独的节点，每个节点包含一个主题。`info`文件包含的超链接可以实现节点间的跳转。通过前置星号可以识别超链接，将光标放在超链接上并按`Enter`键，可以激活它。

* `?`显示命令帮助
* `n`显示下一个节点
* `p`显示上一个节点
* `u`显示目前显示节点的如节点
* `ENTER`进入光标所指的超链接
* `q`退出

系统中安装的很多软件包都有自己的文档文件，它们存放在`/usr/share/doc`目录中，大部分文档是以纯文本格式来存储的，因此可以用`less`命令来查看，有些是`HTML`文件的，可以用Web浏览器来查看。如果是以`.gz`结尾的压缩文件，以`zless`这种特殊的`less`版本来查看压缩的文本文件的内容。

**使用别命创建自己的命令**

我们可以使用`alias`命令来创建自己的命令，我们可以使用分号来分割多条命令，就可以将多条命令输入在一行。其中工作方式如下：

`command1;command2;command3...`

注意`alias`命令的使用如下，注意在使用前应该使用`type`查看该命令是否使用过：

`alias name='string'`

删除别命可以使用`unalias`

### 重定向

`I/O`是输入/输出的缩写。这个功能可以把命令行的输入重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中。如果我们将多个命令行关联起来，将形成非常强大的命令——管道。

**标准输入、标准输出和标准错误**

到目前为止，我们使用过的很多程序生成了不同种类的输出。这些输出常包含两种类型。一种是程序运行的结果，即该程序生成的数据；另一种是状态和错误信息，表示程序当前的运行情况。比如输入`ls`命令，屏幕上将显示它的运行结果以及它的相关错误信息。

与`UNIX`“一切都是文件”的思想一致，类似`ls`的程序实际上把他们的运行结果发送到了一个称为标准输出（standard output，通常表示为 stdout）的特殊文件中，他们的状态信息发送到了另一个称为标准错误（standard error，表示为 stderr）的文件中。默认情况下，标准输出和标准错误都将被来年街道屏幕上并且不会保存在磁盘文件中。

另外，许多程序从一个被称为标准输入（standard input，表示为 stdin）的设备来得到输入。默认情况下，标准输入连接到键盘。

`I/O`重定向功能可以改变输出内容发送到目的地，也可以改变输入内容的来源地。通常来说，输出的内容显示在屏幕，输入内容来自键盘。但是用`I/O`重定向功能可以改变这一惯例。

**标准输出重定向**

使用重定向操作符`>`后面接文件名可以把标准输出重定向到另一个文件中，而不是显示在屏幕中。比如我们可以按照下面的形式把`ls`命令的输出保存到`ls-output.txt`文件中

`ls -l /usr/bin > ls-output.txt`

此时我们把目录名称换为一个不存在的目录

`ls -l /bin/usr > ls-output.txt`

此时会显示错误信息，这个错误信息会直接显示在屏幕上而不会保存在`ls-output.txt`文件中，因为`ls`程序并不会把错误信息发送到标准输出文件中，而是把错误信息发送到标准错误文件中。而这个输出文件内容会被清空，因为`ls`命令没有输出任何命令。

如果我们要删除一个文件内容或创建一个空文件，可以采用这种方式

`> ls-output.txt`

我们如何能够不从文件的首位置覆盖文件，而是从文件的尾部开始添加输出内容呢？我们可以使用重定向符`>>`来实现，比如

`ls -l /usr/bin >> ls-output.txt`

如果这个文件不存在，它会与`>`一样创建这个文件。

**标准错误重定向**

标准错误的重定向并不能简单实用要给专用的重定向符来实现，要实现标准错误的重定向，不得不提到它的文件描述符。一个程序可以把生成的输出内容发送到任意文件流中，如果把这些文件流中的前三个分别对应标准输入文件、标准输出文件和标准错误文件，那么`shell`将在内部用文件描述符分别索引他们为0、1和2。由于标准错误等同于文件描述符2，所以可以使用这种表示法来重定向标准错误。

`ls -l /bin/user 2> ls-error.txt`

**将标准输出和标准错误重定向到一个文件中**

很多情况下，我们会希望把一个命令的所有输出内容都放在同一个独立文件中。为此，我们必须同时重定向标准输出和标准错误。有两种方法可以满足要求，第一种是传统的方法，在旧版本的 shell 中使用

`ls -l /bin/usr > ls-output.txt 2>&1`

使用这个方法，将执行两个重定向操作，第首先重定向到标准输出到`ls-output.txt`中，然后使用标记符`2>&1`把文件描述符2（标准错误）重定向到文件符1（标准输出）中。

> 这种重定向操作的顺序非常重要。标准错误的重定向操作通常发生在标准输出重定向操作之后，否则他将不起作用。

最近的 bash 版本提供了效率更高的第二种方法。

`ls -l /bin/usr &> ls-output.txt`

这个例子中，使用`&>`就把标准输出和标准错误都重定向到了`ls-output.txt`文件中。

**处理不想要的输出**

有时命令执行后我们并不希望得到输出，而是想把这个输出丢弃，尤其是在输出错误和状态信息的情况下更为需要。系统提供了一种方法，即把输出重定向到一个成为`/dev/null`的特殊文件中来实现它。这个文件被称为位桶(bit bucket)

`ls -l /bin/usr 2> /dev/null`

**标准输入重定向**

**cat——合并文件**

`cat`命令读取一个或多个文件，并把它们复制到标准输出文件中，格式如下

`cat [file...]`

大多数情况下，你可以认为`cat`命令和`DOS`中的`TYPE`命令类似。使用它显示文件而不需要分页，例如

`cat ls-output.txt`

上面的命令将显示`ls-output.txt`文件中的内容。`cat`经常用来显示短的文本文件，由于`cat`可以接收多个文件作为输入参数，所以它也可以用来把文件连接在一起。假设我们下载了一个很大的文件，它已被拆分成多个部分，现在我们想要把各部分连接在一起，并还原为原来的文件，如果这些文件命名为：movie.mpeg.001 movie.mpeg.002...movie.mpeg.099

我们可以使用下面的命令来将它们重新连接在一起

`cat movie.mpeg.0* > movie.mpeg`

通配符一般是按顺序来扩展的，因此这些参数将按正确的顺序来排列。假如只输入`cat`没有给定任何参数，踏进从标准输入读取内容，由于标准输入默认是连接到键盘，所以它实际上是等待着从键盘输入到内容。输入`Ctrl-D`告知`cat`命令他已经达到了标准输入的文件尾。

如果我们想要创建短的文本文件内容可以像下面这样用

`cat > lazy_dog.txt`

之后按下`Ctrl-D`结束输入，我们还可以尝试下标准输入的重定向

`cat < lazy_doy.txt`

此时命令行可以打印出文件内容。

### 管道

命令从输入到读取数据，并将数据发送到标准输出的能力，是使用了名为管道的`shell`特性。使用管道操作符`|`可以把一个命令的标准输入传送到另一个命令的标准输入中。

`command1 | command2`

**过滤器**

管道功能经常用来对数据执行复杂的操作。也可以把多条命令合在一起构成一个管道。这种方式中用到的命令通常被称为过滤器`filter`，过滤器接受输入，按照某种方式对输入进行改变，然后再输出它。第一个要用到的命令是`sort`。假设要把`/bin`和`usr/bin`目录下的所有可执行程序合并成一个列表，并按照顺序排列，最后再查看这个列表。

`ls /bin /usr/bin | sort | less`

**uniq——报告或忽略文件中重复的行**

`uniq`命令和`sort`命令结合使用。`uniq`可以接受来自于标准输入或一个单一文件名参数对应的已排好序的数据列表(可以查看`uniq`命令的`man`页面获取详细的信息)。默认情况下，该命令删除列表中的所有重复行，因此，在管道中添加`uniq`命令，可以确保所有列表都没有重复行(即在`/bin`和`/usr/bin`目录下都出现的相同名字的任意程序)。

`ls /bin /usr/bin | sort | uniq | less`

如果想要查看重复行的列表，可以在`uniq`命令后添加`-d`命令。

**wc——打印行数、字数和字节数**

`wc`（word count）命令用来显示文件中包含的行数、字数和字节数。比如：

`wc ls-output.txt`

`-l`参数限制命令只报告行数。

**grep——打印匹配行**

`grep`是一个功能强大的程序，它用来在文件中查找匹配文本，其使用方法如下

`grep pattern [file...]`

`grep`能够匹配的模式内容是非常复杂的。

`-i`表示忽略大小写，`-v`使`grep`只输出和模式不匹配的行。

**head/tail——打印文件的开头部分/结尾部分**

默认情况下，`head`命令只输出开头十行，`tail`命令则输出文件的最后十行。`-n`选项可以调节输出的行数

`head -n 5 ls-output.txt`

`tail`中有一个选项用来查看文件，该选项在观察正在被写入的日志文件的进展状态时很有用，下面的例子中，我们将观察`/var/log`目录下的`messages`文件。因为`/var/log/messages`文件可能包含安全信息，在一些`Linux`发行版中需要超级用户的权限才能执行该操作

`tail -f /var/log/messages`

**tee——从 stdin 读取数据，并同时输出到 stdout 和文件**

`tee`程序读取标准输入，再把读到的内容复制到标准输出和一个或更多的文件中去。当在某个中间处理阶段来捕获一个管道中的内容时会很有用。

`ls /usr/bin | tee ls.txt | grep zip`

## 透过 shell 看世界

在本章，我们将会介绍 shell 的几个有趣而复杂的特性，但是我们只是用一条新命令来处理

`echo: 显示一行文本`

### 扩展

每次输入命令行按下`Enter`键时，bash 搜会在执行命令之前对文本进行多重处理。前面已经见过一个简单的字符序列（比如 *）在 shell 中被识别为多种意思的几个例子。产生这个结果的处理过程称为扩展（expansion）。有了扩展功能，在输入内容后，这些内容将会在 shell 对其执行之前被扩展成其他内容。

`echo`是 shell 的一个内置命令，他执行的任务非常简单，即把文本参数内容打印到标准输出。

`echo this is a test`

这个例子相当简单，传递给`echo`的任何参数都将显示出来

`echo *`

它不会返回`*`，而是会被shell扩展成其他内容，在这个例子中扩展为当前工作目录下的所有文件名，因此，只能看到`*`扩展后的结果。

**路径名扩展**

通过通配符来实现扩展到机制称为路径名扩展，试试在前面章节使用过的一些技术，将会发现它们实际上就是扩展

`echo D*`, `echo *s`,`echo [[:upper:]]*`,`echo /usr/*/share`

> **隐藏文件的路径名扩展**
>
> 文件名以一个`.`开头的文件都将被隐藏。所以类似`echo *`这样的扩展并不能显示隐藏的文件。
>
> `echo .*`似乎是可行的，但是`.`和`..`也将出现在结果中，它们包括当前工作目录以及父目录
>
> 在这种情况下，可以使用`ls -d .[!.]?*`来进行更精确的匹配

**波浪线扩展**

如果把`~`用在一个单词的开头，那么他警备扩展为指定用户的主目录名，如果没有指定用户命名，则扩展为当前用户的主目录

`echo ~` => `/home/me`

如果有用户`foo`这个用户

`echo ~foo` => `/home/foo`

**算数扩展**

shell 支持通过扩展来运行算术表达式，这允许我们把 shell 提示符当作计算器使用

`echo $((2 + 2))` => `4`

算术扩展符使用如下格式

`$((expression))`

其中，`expression`是指包含树枝和算术操作符的算术表达式。

算术扩展只支持整数（全是数字，没有小数），但是可以执行很多不同的运算。下面列出了支持的操作符

`+`,`-`,`*`,`/`,`%`,`**`(取幂)

空格在算术表达式中是没有意义的，而且表达式是可以嵌套的。

`echo $(($((5**2)) * 3))` => `75`

可以使用一对括号来组合多个子表达式

`echo $(((5 ** 2) * 3))` => `75`

**花括号扩展**

你可以按照花括号里的模式创建多种文本字符串

`echo Front-{A,B,C}-Back` => `Front-A-Back Front-B-Back Front-C-Back`

花括号扩展到模式信息可以包含一个称为前导字符开头部分和一个称为附言的结尾部分。花括号表达式本身可包含一系列逗号分隔的字符串，也可以包含一系列整数或单个字符。这里的模式信息不能包含内嵌的空白

`echo _{1..5}` => `_1 _2 _3 _4 _5`

花括号支持嵌套

`echo a{A{1, 2}, B{3, 4}}b` => `aA1b aA2b aB3b aB4b`

花括号一般用于创建一系列的文本或目录，比如一个很大的图片集，需要通过以年月格式命名的目录

**参数扩展**

参数扩展用在 shell 脚本中比直接用在命令行中更为有用，它的许多特性于系统存储小块数据以及给每个小块数据命名性能有关

`echo $USER` => `me`

**命令替换**

命令替换可以把一个命令的输出作为一个扩展模式使用

`echo $(ls)` 

我最喜欢的一种用法如下

`ls -l $(which cp)`

这里，把`which cp`命令的运行结果作为`ls`命令的一个参数，因此我们无需知道 cp 程序所在的完整路径就能获得 cp 程序对应的列表。这个功能也可用于整个管道中

`flie $(ls /usr/bin/* | grep zip)`

在早期的 shell 中存在命令替换的另一种语法格式，bash 也支持这种格式，它用反引号代替美元符号和括号

`ls -l 'which cp'`

@##引用

我们已经知道 shell 有多种方式可以执行扩展，现在我们来学习如何控制扩展

`echo The total is $100.00` => `The total is 00.00`

因为`$1`是一个未定义的变量，所以参数扩展把`$1`的值替换为空字符串。shell 提供了一种称为引用的机制，用来有选择性地避免不想要的扩展

**双引号**

如果把文本放在双引号中，那么 shell 使用的所有特殊字符都将失去它们的特殊含义，而被看成普通字符。字符`$`,`\`,`,`除外。这就意味着单数扩展、算术扩展和命令替换依旧有效。比如有一个以空格分隔的文件名，使用引用就可以避免被当成连个独立的参数使用。

`ls -l "two words.txt"`

请记住，算术扩展，参数扩展和命令替换在双引号中依然有效。

`echo "$USER $((2+2)) $(cal)"`

**单引号**

如果我们希望一直所有扩展，那么应该使用单引号。

**转义字符**

有时候我们只是想要引用单个字符，这种情况我们可以通过在该字符前加上反斜杠`\`来实现，转义字符也常用来消除文件名中某个字符的特殊含义，包括`$`，`!`，`&`，空格等

如果想要显示反斜杠字符串，可以通过使用两个反斜杠`\\`来实现。

## 高级键盘技巧

事实上，省事是命令行最希望达到的目标之一。命令行的另一个目标是，用户在执行任务时无需离开键盘使用鼠标。

### 编辑命令行

bash 使用了一个名为 Readline 的库来实现命令行的编辑。

**光标移动**

* `Ctrl-A`移动光标到行首
* `Ctrl-E`移动光标到行尾
* `Ctrl-F`光标向前移动一个字符；和右箭头键作用一样
* `Ctrl-B`光标向后移动一格字符；和左箭头键作用一样
* `Alt-F`光标向前移动一个字
* `Alt-B`光标向后移动一个字
* `Ctrl-L`清屏并把光标移到左上角；`clear`可以完成相同工作

**修改文本**

* `Ctrl-D`删除光标处的字符
* `Ctrl-T`使光标处的字符和它面前的字符对调位置
* `Alt-T`使光标处的子和它前面的字对调位置
* `Alt-L`把光标到字尾的字符转成小写形式
* `Alt-U`把光标到字尾的字符转成大写形式

**剪切和粘贴文本**

Readline 文档中使用术语`killing`和`yanking`来指代通常所说的剪切和粘贴。

* `Ctrl-K`剪切从光标到行尾的文本
* `Ctrl-U`剪切从光标到行首的文本
* `Alt-D`剪切从光标到当前词尾的文本
* `Alt-Backspace`剪切从光标到词头的文本。如果光标在一个单词的开头，则剪切前一个单词
* `Ctrl-Y`把`kill-ring`缓冲区中的文本粘贴到光标位置

>在 bash 帮助文档的“READLINE”部分可以查看 Readline 文档，在这里你可以看到元键(meta key)这个术语。它对应于现代键盘的`Alt`键，不过也并不总是这样。如果你仍然在使用终端，则按下和释放`Esc`键和长按住`Alt`键的效果是相同的。

### 自动补齐功能

shell 的一种称为“自动补齐”的机制为用户提供了很大的帮助。在输入命令时，按`Tab`键将触发自动补齐功能。

要让自动补齐功能生效，要保证输入的内容不摸棱两可，即必须是确定性的。自动补齐可以针对变量（如果单词以`$`开头）、用户名（如果单词以`~`开头）、命令（如果单词是命令行的第一个单词）和主机名（如果单词以`@`开头）起作用。注意到自动补齐只对`/etc/hosts`目录下的主机名生效

有一些控制和元键序列与自动补齐功能相关联

* `Alt-$`显示所有可能的补齐列表。在大鼠系统中，通过按两次`tab`键也可实现
* `Alt-*`插入所有可能的匹配项。当要用到一个以上的匹配项时，将比较有用

除了这些，其他的组合键可以在`bash man`页面的`READLINE`部分获取更多内容列表

通过`set | less`可以查看当前系统支持的自动补齐脚本。

### 使用历史命令

bash 会保存使用过命令的历史记录。这些命令的历史记录列表保存在用户主目录的`.bash_history`文件中

**搜索历史命令**

任何情况下，我们都可以通过如下命令查看历史记录的内容列表

`history | less`

bash 会默认保存用户最经使用过的 500 个命令，假设我们想找到用来列出`/usr/bin`目录下内容的命令，我们可以这样做

`history | grep /usr/bin`

假设得到的搜索结果中有一行包含如下内容

`88 ls -l /usr/bin > ls-output.txt`

其中`88`是这个命令行在历史纪录列表中所处的行号我们可以通过历史记录扩展来立即使用它

`!88`

bash 将把`!88`扩展为历史列表中第88行的内容。bash 也支持以递增方式搜索历史记录。随着输入字符数的增加，bash 会相应地改变搜索范围。按下`Ctrl-R`键，接着输入你要查早的内容，可以开始递增式的搜索。当找到要炸找到的内容时，按下`Enter`键白澳式执行此命令，而按`Ctrl-J`将把搜索的呢日共从历史记录中复制到当前命令行。当要查找下一个匹配项时，再次按下`Ctrl-R`键。

列出了一些用来手动操作历史记录的组合键

* `Ctrl-P`移动到前一条历史记录。相当于向上箭头键。

* `Ctrl-N`移动到前一条历史记录。相当于向下箭头键。

* `Alt-<`移动到历史纪录列表的开始处

* `Alt->`移动到历史纪录列表的结尾处

* `Ctrl-R`逆向递增式搜索。送当前命令行向前递增搜索

* `Alt-P`逆向非递增式搜索。按下这个组合键，接着输入待搜索的字符串，在按`Enter`键后，搜索才真正开始执行

  Alt-N`向前非递增式搜索

* `Ctrl-O`执行历史记录列表的当前项，执行完跳到下一项。若要把历史纪录的一系列命令重新执行一遍，使用该组合键就很方便

**历史记录扩展**

除了使用`!`意外，还有其他的扩展特性，当使用`! string`和`!? string`时，请务必小心谨慎，除非对命令列表非常确信。

还可以查阅 bash 帮助页面的`HISTORY EXPANSION`部分获取更多细节。

* `!!`重复执行最后一个执行的命令。按向上箭头键和`Enter`键可实现相同功能
* `!number`第`number`行的命令
* `! string`重复最近的以`string`开头的命令
* `!? string`重复最近的包含`string`的历史记录

## 权限

传统的UNIX操作系统与那些传统的MS-DOS操作系统不同，区别在于它们不仅是多重任务处理系统，还是多用户系统。

这意味着同一时间内可以有多个用户使用同一台计算机，虽然一套标准的计算机可能只包含一个键盘和一台显示器，但是它仍然可以同时被一个以上的用户使用。如果计算机连接到一个网络或互联网中，远程用户可以通过 ssh 登录并操作这台计算机。

### 所有者、组成员和其他所有用户

在 UNIX 安全模型中，一个用户可以拥有`own`文件和目录。当一个用户拥有一个文件或目录时，它将对该文件或目录的访问权限拥有控制权。反过来，用户又归属于一个群组`group`，该群组有一个或多个用户组成，组中用户对文件和目录的访问权限由其所有者授予。除了可以搜娱群组访问权限之外，文件所有者也可以授予所有用户一些访问权限。使用`id`命令可以获得用户身份标识的相关信息。

`id` => `uid=500(me) gid=500(me) groups=500(me)`

查看`id`命令的输出结果。在创建用户账户的时候，用户将被分配一个称为用户ID或`uid`的号码。为了符合人们的使用习惯，用户ID与用户名一一映射。同时用户将被分配一个有效组ID或被称为`gid`而且该用户也可归属于其他群组。

前面的结果在`Fedora`系统中，在其它系统中输出结果可能有点不同。

#### 读取、写入和执行

对文件和目录的访问权限是按照读访问、写访问以及执行访问来定义的。

当我们查看`ls`命令的输出结果时，可以得到一些线索

`ls -l foo.txt` => `-rw-rw-r-- 1 me me 0 2012-03-03-06 14:52 foo.txt`

列在输出结果的前10个字符表示的是文件属性。

* `-`文件类型
* `rw-`所有者权限
* `rw-`组权限
* `r--`其他用户权限

文件类型

* `-`普通文件
* `d`目录文件
* `l`符号链接
* `c`字符设备文件，表示以字节流形式处理数据的设备，如终端或调制解调器
* `b`块设备文件，表示以数据块方式处理数据的文件

文件属性中剩下的九个字符成为文件模式，分别表示文件所有者、文件所属群组以及其他所有用户对该文件的读取、写入和执行权限。

分别设置`r`、`w`和`x`的模式属性将会对文件和目录带来不同的影响

* `r`*文件*允许打开和读取文件，*目录*如果设置了执行权限，那么允许列出目录内容
* `w`*文件*允许写入或阶段文件，如果也设置了执行权限，那么目录中的文件允许被创建、被删除和被重命名，*目录*该权限不允许重命名或删除文件。是否能重命名和删除文件由目录权限决定
* `x`允许把文件当作程序来执行。用脚本写的程序文件必须被设置为刻度

下面是一个文件属性设置的例子

 **chmod——更改文件模式**

我们可以使用`chmod`命令来更改文件或目录到模式(权限)。需要注意的是只有文件所有者和超级用户才可以更改文件或目录的模式。`chmod`命令支持两种不同的改变文件模式的方式——八进制数字表示法和符号表示法。

*八进制表示法*是指使用八进制数字来设置所期望的权限模式。

| 八进制 | 二进制 | 文件模式 |
| ------ | ------ | -------- |
| 0      | 000    | ---      |
| 1      | 001    | --x      |
| 2      | 010    | -w-      |
| 3      | 011    | -wx      |
| 4      | 100    | r--      |
| 5      | 101    | r-x      |
| 6      | 110    | rw-      |
| 7      | 111    | rwx      |

通过使用3位八进制数字，我们可以设置文件所有者、组成员和其他所有用户的文件模式

`chmod 600 foo.txt`

上面命令设置文件所有者具有读写权限，取消组用户和其他所有用户的所有权限。其实常用的也就7、6、5、4、0

*符号表示法*

`chmod`命令支持一种符号表示法来指定文件模式。该符号表示法分为三部分：更改会影响谁、要执行那个操作以及要设置那种权限

* `u`,`user`的简写，表示文件或目录的所有者
* `g`文件所属群组
* `o`,`others`的简写，表示其他所有用户
* `a`,`all`的简写，是`u`，`g`和`o`三者的组合

如果没有指定字符，则假定使用`all`。操作符`+`表示增加一种权限，`-`表示删除一种权限，`=`表示只有指定的权限可用，其他所有权限被删除

权限由字符`r`，`w`和`x`来指定

* `u+x`为文件所有者添加可执行权限
* `u-x`删除文件所有者的可执行权限
* `+x`为文件所有者、所属群组和其他所有用户添加可执行权限，等价于`a+x`
* ...

符号表示法的优点在于允许设置单个属性而不影响其他任何属性

**通过GUI设置文件模式**

右击文件或目录图标都会弹出一个属性对话框

**umask——设置默认权限**

`umask`命令控制着创建文件时指定给文件的默认权限。它使用八进制表示法来表示从文件模式属性中删除一个位掩码

`umask 0002` + `ls -l foo.txt`

其中`0002`是文件属性，掩码的二进制数值中每个出现`1`的位置，其对应的属性都被取消。

在创建文件前使用`umask`来设置文件权限，如果不带任何参数可以直接使用`umask`来查看默认创建文件权限。

大多数情况下，你并不需要修改掩码值，默认掩码值就很好了，在一些高安全级别环境下，需要控制掩码值。

#### 更改身份

在很多时候，我们会发现可以拥有另一个用户的身份很有必要。我们经常会需要获得超级用户的特权来执行一些管理任务，但是也可以编程另一个普通用户来执行这些任务。有三种方法来转换身份

* 注销系统并以其他用户的身份重新登录系统
* 使用`su`命令
* 使用`sudo`命令

这里第一种方法明显不如其他两种方法来得方便。在 shell 会话状态下，使用`su`命令将允许你假定为另一个用户的身份，既可以以这个用户的ID来启动一个新的shell会话，也可以以这个

用户的身份发布一个命令。使用`sudo`命令将允许管理者创建一个称为`/etc/sudoer`的配置文件，并且定义给一些特定的命令，这些命令只有被赋予为假定身份的特定用户才允许执行。

**su——以其他用户和组ID的身份来运行 shell**

`su`命令用来以另一个用户的身份来启动 shell。该命令的一般形式如下：

`su [-[l]] [user]`

如果包含`-l`选项，那么得到的 shell 绘画界面僵尸用于指定用户的登录 shell 界面。这就意味着该指定用户的运行环境将被加载，而且其工作目录也将更改为该指定用户的主目录。如果没有指定用户，那么默认假定为超级用户。`-l`可以缩写为`-`，这一形式经常被使用

`su -`

输入`su`命令后，系统会提示输入该超级用户的密码。如果密码输入正确将会出现新的 shell 提示符，该提示符表示该 shell 将拥有超级用户的特权（提示符的末尾字符是`#`，而不是`$`），而且当前工作目录现在也是用于超级用户的主目录（通常情况下为`/root`）。在试用结束时，输入`exit`，将返回到之前的 shell 环境。

我们也可以使用`su`命令执行单个命令，而不需要开启一个新的交互式命令界面

`su -c 'command'`

是哟个这种格式，单个命令行将被传递到一个新的 shell 环境下执行。这里需要用单引号把命令行引起来。它会在新的 shell 环境下执行

**sudo——以另一个用户的身份执行命令**
`sudo`命令在很多方面都类似于`su`命令，管理者可以通过配置`sudo`命令，使系统以一种可控的方式，允许一个普通用户以一个不同的用户身份执行命令。使用`sudo`命令时，用户只需要输入自己的密码来进行认证。

一旦认证通过，指定的命令就将被执行。`su`命令和`sudo`命令的一个重要区别在于`sudo`命令并不需要启动一个新的 shell 环境，所以使用 shell 命令时不需要使用单引号。

想知道`sudo`命令可以授予哪些权限，可以使用`-l`来查看

`sudo -l`

在第一次使用了`sudo`命令之后，系统会信任用户几分钟，此时可以不用输入`sudo`命令操作

**chown——更改文件所有者和所属群组**

这个命令需要超级用户的权限。格式如下：

`chown [ower][:[group]] file ...`

`chown` 命令更改的是文件所有者还是文件所属群组，或者对两者都更改取决于该命令的第一个参数

| 参数      | 结果                                                         |
| --------- | ------------------------------------------------------------ |
| bob       | 把文件所有者从当前所有者改为用户 bob                         |
| bob:users | 把文件所有者从当前所有者改为用户bob，并且把文件所属群组改为 users 群组 |
| :admins   | 把文件所属群组改为 admins 组，文件所有者不变                 |
| bob:      | 把文件所有者从当前所有者改为用户bob，并且把文件所属群组改为 bob 登陆系统所属的组 |

**chgrp——更改文件所属群组**

该命令除了限制多一点之外，和`chown`命令的使用方式几乎相同

## 进程

现代操作系统通常都支持多任务处理。多重任务处理是指系统通过快速切换运行中的程序来实现多任务的同时执行。Linux 内核通过使用进程来管理多重任务。

有时计算机运行速度会变得很慢，此时可以使用命令行来查看程序当前运行情况以及终止运行异常的进程的一些工具

### 进程如何工作

系统启动时，内核先把它的一些程序初始化为进程，然后运行一个称为`init`的程序。此程序将依次运行一系列称为脚本初始化的 shell 脚本，这些脚本将会启动所有系统服务。其中很多服务都是通过守护程序来实现。而后台程序只是呆在后台做它们自己的事。

一个程序的运行可以触发其他程序的运行，在进程系统中这种情况被表述为父进程创建子进程。

内核会保存每个进程的信息以便确保任务有序进行。比如每个进程将被分配一个称为进程ID的号码。进程ID是按递增的顺序来分配，`init`进程的PID始终为 ·。和文件系统类似，进程·系统中也存在所有者、用户ID、有效用户ID等。

**使用ps命令查看进程信息**

最简单的格式如下

`ps`

返回的数据格式中，`TTY`代表了进程的控制终端。`TIME`字段表示了进程消耗的CPU时间总和。

如果在`ps`命令后面添加一个选项，我们将得到更大的视图界面

`ps x`

它将告知`ps`命令的所有进程，而不需要关注它们是由哪个总段所控制的，`TTY`中的`?`表示没有控制终端，把`ps`命令作为`less`命令的输入方法通常横贯用，它可以更方便地查看显示结果。输出结果中添加了一个命名为`STAT`的新列。它是`state`的缩写，显示的是进程的当前状态。

| 状态 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| R    | 运行状态。进程正在进行或准备进行                             |
| S    | 睡眠状态。进程不再运行，而是在等待某个事件发生，如键盘输入或收到网络报文 |
| D    | 不可中断的睡眠状态。进程在等待I/O操作，如硬盘驱动            |
| T    | 暂停状态。                                                   |
| Z    | 无效或“僵尸”进程。子进程被终止但还没有被父进程彻底释放       |
| <    | 高优先级进程                                                 |
| N    | 低优先级进程，只有在高优先级进程使用完处理器后才能够使用处理器的时间 |

另一个常用的选项组合是`aux`，它将输出更多的信息，它会显示属于每个用户的进程信息，使用这些选项时不带前置连字符将使得命令以`BSD 模式`运行。具体的列信息如下。

| 标题  | 含义                                                     |
| ----- | -------------------------------------------------------- |
| USER  | 用户ID。表示该进程所有者                                 |
| %CPU  | CPU 使用百分比                                           |
| %MEM  | 内存使用百分比                                           |
| VSZ   | 虚拟耗用内存大小                                         |
| RSS   | 实际使用内存大小，即物理内存大小，以KB为单位             |
| START | 进程开始的时间，如果数值超过24个小时，那么将使用日期表示 |

**使用top命令动态查看进程信息**

虽然`PS`命令可以显示有关机器运行情况的很多信息，但是它提供的只是在`PS`命令被执行时刻机器状态的一个快照。要查看机器运行情况的动态视图可以使用`top`命令

`top`

`top`程序将按照进程活动的顺序，以列表的形式持续更新显示系统进程的当前信息（每3秒更新一次）。它用于查看系统“最高”进程的运行情况。显示内容包括两部分上名师系统总体状态信息。下面显示的是按cpu活动时间排序的进程情况表。

### 控制进程

**中断进程**

`ctrl + c`但不是所有命令行程序可以使用这种方法来实现中断。

**使进程在后台运行**

假设我们想要shell提示符返回，但又不终止程序，那么就可以通过让该程序在后台运行来实现。想在启动程序时在后台运行，可以在命令行后加上`&`来实现。

shell 的作业控制也提供了一种方式来查看从该终端启动的所有作业。使用`jobs`命令可以得到所有信息。

**使进程回到前台运行**

可以通过`fg`命令来实现。在命令后面加上百分比符号和作业编号，作业编号通过`jobs`命令获得。

`fg %1`

**停止（暂停）进程**

如果我们想暂停进程而不是终止进程，那么我们通常需要将前台运行的进程移到后台去运行。我们可以输入`ctrl + z`键。接触这种状态可以使用`fg`或`bg`来让进程在前台或后台恢复运行。

在图形化界面启动，程序会启动失败，但是在命令行启动可以查看错误信息。

### 信号

`kill`命令通常用来“杀死”进程，它可以用来终止运行不正常的程序或反过来拒绝终止的程序

这些看起来非常容易，实际上这些命令不是杀死进程，而是给进程发送信号。比如`ctrl + c`发送一个称为`INT`（终端，Interrupt）的信号，在按下`ctrl + z`时，他将发送一个成为`TSTP`（终端暂停，Terminal Stop）的信号。

**使用kill命令发送信号到进程**

`kill`命令常用语法格式如下

`kill [-signal] PID...`

如果命令行中没有指定信号，那么默认发送`TERM`信号。`kill`命令常用来发送信号如下所示


| 信号编号 | 信号名 | 含义                                                         |
| -------- | ------ | ------------------------------------------------------------ |
| 1        | HUP    | 挂起符号。该信号通过关闭终端会话的方式来表现，前台程序会被终止，后台程序会进行重新初始化，即终止并读取配置文件 |
| ２       | INT    | 中断信号，和按下ctrl + c的效果一样                           |
| ３       | KILL   | 杀死信号，此信号不会真正的发送到目标程序，而是内核宁愿立即终止了该进程，它不会对自己进行清理或保存 |
| ４       | TERM   | 终止信号，这是kill命令默认发送的信号类型，如果程序有足够的“活力”来接受信号，那么它将被终止 |
| ５       | CONT   | 继续运行账号，霍夫接受了STOP信号的进程                       |
| ６       | STOP   | 暂停信号，该信号将使进程暂停，而不是终止，和KILL信号类似     |

**使用killal命令发送信号给多个进程**
我们可以给指定程序或指定用户名的多个进程发送信号，一般格式如下

`killall [-u user] [-signal] name...`

记住，和`kill`命令一样，你必须具有超级用户权限，才能够使用`killall`命令给不属于自己的进程发送信号

### 更多与进程相关的命令

由于进程监控是一项重要的系统管理任务，所以存在很多命令用来为它服务

| 命令   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| pstree | 以树状的模式输出进程列表，该模式显示了进程间的父/子关系      |
| vmstat | 输出系统资源使用情况的快照，包括内存，交换空间和磁盘I/O，如果想要持续查看输出，可以在命令后面加上一个间隔时间（以秒为单位）动态更新显示内容 |
| xload  | 用来绘制显示系统时间负载情况图像的一种图形化界面程序         |
| tload  | 类似于xload程序，但是图形是在终端上绘制。                    |

## 环境

在 shell 会话调用环境期间，shell 会存储大量的信息。程序使用存储在环境中的数据来确定我们的配置。

### 环境中存储的是什么

尽管 shell 在环境中存储了两种基本类型的数据，但是在 bash 中，这两种数据基本没有区别。这两种数据类型分别是环境变量和 shell 变量。shell 变量是由 bash 存放的少量数据，环境变量就是除此之外的所有其他变量。除变量之外，shell 还存储了一些编程数据，也就是别名和 shell 函数。

**检查环境**

要了解环境中存储的内容，需要用到集成在bash中的`set`命令或`printenv`程序。不同的是，`set`命令会同时显示 shell 变量和环境变量，而`printenv`只会显示环境变量。由于环境的内容可能会比较冗长，所以最好以管道重定向到`less`命令中。

`printenv | less`

使用`set`命令时，如果不带选项或参数，那么只会显示 shell 变量、环境变量、以及任何已定义的 shell 函数。`set`命令的输出结果是按照字母顺序排列的。如果要查看单个变量的值，我们也可以使用`echo`命令

`echo $HOME`

如果想鉴别是否为别命只能使用`alias`

**一些有趣的变量**

| 变量    | 说明                                                         |
| ------- | ------------------------------------------------------------ |
| DISPLAY | 运行图形界面环境时的名称                                     |
| EDITOR  | 用于文本编辑的程序名称                                       |
| SHELL   | 本机 shell 名称                                              |
| HOME    | 本机主目录的路径名                                           |
| LANG    | 定义了本机语言的字符集和排序规则                             |
| OLD_PWD | 先前的工作目录                                               |
| PAGER   | 用于分页输出的程序名称。通常设置为`/user/bin/less`           |
| PATH    | 以冒号分割的一个目录列表，当用户输入一个可执行程序的名称时，会查找该目录列表 |
| PS1     | 提示符字符串1.定义了本机 shell 系统提示符的内容              |
| PWD     | 当前工作目录                                                 |
| TERM    | 终端类型的名称。此变量设定了本机终端模拟器使用的协议         |
| TZ      | 用于指定本机所处的时区                                       |
| USER    | 用户名                                                       |

### 环境是如何建立的

用户登录系统后，bash 程序会启动并读取一系列称为启动文件的配置脚本，这些脚本定义了所有用户共享的默认环境。接下来，bash 会读取更多存储在主目录下的用于定义个人环境的启动文件。

**login 和 non-login shell**

shell 会话存在两种类型，分别为`login shell`会话和`non-login shell`会话

`login shell`会话会提示用户输入用户名和密码，如虚拟控制台会话，而我们在 GUI 中启动的终端会话就是一个典型的`non-login shell`会话

`login shell`的启动文件

| 文件            | 说明                                               |
| --------------- | -------------------------------------------------- |
| /etc/profile    | 适用于所有用户的全局配置脚本                       |
| ~/.bash_profile | 用户的个人启动文件。可扩展或重写全局配置脚本的配置 |
| ~/.bash_login   | 若 ~/.bash_profile 缺失，则 bash 尝试读取此脚本    |
| ~/.profile      | 若上面两个文件缺失，则读取此文件                   |

`non-login shell`的启动文件

| 文件             | 内容                         |
| ---------------- | ---------------------------- |
| /etc/bash.bashrc | 适用于所有用户的全局配置脚本 |
| ~/.bashrc        | 用户的个人启动文件           |

此外`non-login shell`还会继承父类进程的环境，父类进程通常是一个`login shell`

用户可查看本机系统有哪些启动文件，它们通常是以`.`开头，所以用户在使用`ls`命令时，需要伴随使用`-a`选项。

**启动文件中有什么**

当用户输入命令`ls`，shell 不会搜索整个系统来寻早`/bin/ls`，而是会搜索`PATH`变量中存储的目录列表。

`PATH`变量通常是由启动文件`/etc/profile`中的一段代码设定

`PATH=$PATH:$HOME/bin`

这段代码将`$HOME/bin`添加到了`PATH`值的尾部。当系统需要检索用户输入的命令时，`$HOME/bin`这个路径就会处于被搜索的路径列表中。

### 修改环境

现在用户已经知道了系统启动文件的位置和内容，就可以修改启动文件来定义我们的环境

**用户应该修改哪些环境**

一般来说，在 PATH 中添加目录，或定义额外的环境变量，需要将这些更改放入到`.bash_profile`文件中，当然用户也可以修改其他目录下的文件，比如`/etc`下的 profile 文件。

**文本编辑器**

文本编辑器类似于字处理器，它允许用户通过移动移动光标到方式来编辑屏幕中的文字，与字处理器不同，文本编辑器只支持纯文本，它是软件开发人员编写代码的主要工具，系统管理员也可以使用文本编辑器来管理系统的配置文件

文本编辑器分为两种，图形界面和基于文本的。GNOME 和 KDE 都配备有一些流行的图形界面编辑器，GNOME 配备的编辑器叫 gedit，KDE 则配备了三种编辑器，分别是 kedit、kwrite 和 kate（复杂程度递增）

基于文本的编辑器中有 nano、vim 和 emacs

**使用文本编辑器**

使用 gedit 直接`gedit some_file`，如果没有输入的文件名会新建

当更改系统文件时，需要为文件备份，可以给复制的文件加上扩展名`.bak`，`.sav`，`.old`，`.orig`等

当更改`.bashrc`文件后，需要使用`source .bashrc`来让 bash 重新读取 .bashrc 文件

## VI 简介

### 为什么要学习 vi

现在这个时代存在着很多图形界面编辑器和易用的基于文本的编辑器，例如 nano，那么为什么要学习 vi？有三条充分的理由

- vi 总是可用的。如果用户面前的系统没有图形界面，例如是远程服务器或是本地系统的 X 配置不可用，那么 vi 就会成为救命的稻草。
- vi 是轻量级的软件，运行速度快，对很多任务来说，启动 vi 更便捷
- 用户不想被其他 Linux 和 UNIX 用户蔑视

### VI 背景

大多数 LInux 发行版配备的不是真正的 vi 而是 vi 加强版——vim(Vi Improved 的缩写)

### VI 操作

**启动和退出**

`vi`启动 vi

`:q`退出 vi，如果应为一些原因，vi 不能够退出，可以通过在命令后添加感叹号的方式强制退出 vi，`:q!`

**进入插入模式**

vi 是一个模态编辑器，vi 启动后进入的是命令模式，在命令模式中，几乎键盘上每一个按键都代表一条命令

可以按`i`进入插入模式，此时用户可以进行输入操作

**保存工作**

要保存用户修改后的文件，需要在命令模式下输入一条 ex 命令，也就是按`:`键，之后输入`w`

`:w`，文件写入硬盘驱动器后，用户会在屏幕底部得到一条确认信息

**移动光标**

在命令模式下，vi 提供了很多移动光标命令，其中一些命令是与`less`命令共用的

`L`或右方向键：右移一行

`H`或左方向键：左移一行

`J`或下方向键：下移一行

`K`或上方向键：上移一行

数字0：至本行开头

`shift + 6`：至本行第一个非空字符

`shift + 4`：至本行末尾

`W`：至下一单词或标点的开头

`shift + w`：至下一单词的开头，忽略标点

`B`：至上移单词的开头

`shift + b`：至上移单词的开头，忽略标点

`ctrl + f`或`page Down`：下翻一页

`ctrl + b`或`page Up`：上翻一页

`number + shift + G`：至第 number 行

`shift + G`至文件最后一行

很多 vi 的命令的前面都可以缀上数字。前缀数字可以控制命令执行的次数，比如`5j`可以使得光标下移 5 行

### 基本编辑

插入、删除、剪切、赋值等构成了基本的文本编辑操作，同时 vi 还支持有限形式的撤销错做，在命令模式下按`U`键就可以撤销用户最后一步操作

**添加文本**

`shift + a`：光标移动至行尾并进入插入模式

**插入一行**

插入文本的另一种方式是在文本中重开一行，即在两行现存的文字中间插入空白行并进入插入模式

`o`：当前行的上方

`shift + o`：当前行的下方

**删除文本**

就像用户期望的一样，vi 提供了很多种删除文本的方式，每一种都需要进行一次至两次的按键操作。首先，`x`键会删除光标处的字符，它也可以加数字前缀来明确删除的字数。`D`键则使用得更加普遍，它也可以加数字前缀来明确删除的字数

`x`：当前字符

`3x`：当前字符和之后的2个字符

`dd`：当前行

`5dd`：当前行和之后4行

`dW`：当前字符到下一单词的起始

`d$`：当前字符到当前行的末尾

`d0`：当前字符到当前行的起始

`d^`：当前字符到当前行的下一个非空字符

`dG`：当前行到文件末尾

`d20G`：当前行到文件第20行

**剪切、复制和粘贴文本**

命令`d`不是在删除文本而是在剪切文本。用户每次使用`d`命令之后，都会复制删除的内容进缓存，然后用户就可以使用`p`命令将缓存中的内容粘贴到光标之后或使用`p`命令将内容粘贴到光标之前

与命令`d`剪切文本的形式一样，命令`y`会复制文本

`yy`当前行

`5yy`当前行和之后4行

`yW`：当前字符到下一单词的其实

`y$`：当前字符到当前行的末尾

`y0`：当前字符到当前行的起始

`y^`：当前字符到当前行的下一个非空字符

`yG`：当前字符到文件末尾

`y20G`：当前字符到文件第20行

**合并行**

vi 在行的概念上非常严格，通常将光标移动到行的末端并删除行的末尾字符并不能将此行与下一行合并。因此，vi 专门提供了`J`命令

### 查找与替换

vi 提供了在一行或整个文件中，根据搜索条件将光标移动到指定位置的功能。vi 还可以执行文本替换工作，用户可指定替换时是否需要用户确认

**行内搜索**

命令`f`在行内进行搜索，并将光标移至搜索到的下一个指定字符，比如，命令`fa`就会将光标移动到本行下一处出现字符`a`的地方，在执行过一次行内搜索之后输入分号可以使 vi 重复上一次的搜索

**搜索整个文件**

命令`/`可以完成对单词或短语的搜索，当用户使用`/`命令后，一个`/`符号就会出现在屏幕的底部，接下来，输入需要搜索的代持或短语，以`Enter`结束。光标就会移动到下一出包含被搜索字符串的地方，使用`n`命令可以重复此搜索，vi 同样也支持正则表达式

**全局搜索和替换**

vi 使用 ex 命令来执行几行之内或整个文件中的搜索和替换操作，输入以下命令可将文件中的`Line`替换为`line`

`:%s/Line/line/g`

现在就来解析这条命令每一部分的功能

`:`：分号用于启动一条 ex 命令

`%`：确定了操作作用的范围，`%`表示从文件第一行到最后一行，本命令还可表示为`1, $`，或`1, 5`（本文件只有5行），如果不明确指出命令的作用范围，则命令只在本行生效

`s`：指定了具体操作——本次是替换操作

`/Line/line`搜索和替换的文本

`g`：代指全局，也就是说对搜索到底每一行的每一个实例进行替换，如果`g`缺失，那么只替换每一行第一个符合条件的实例

在命令末尾添加`c`则命令在每次替换之前都会请求用户确认

`:%s/Line/line/gc`

此命令会将文件替换为原来的样子，但是每次替换前，vi 都会停下来询问用户是否确认执行替换

`replace with Line (y/n/a/q/l/^E/^Y)?`

圆括号中每一字符都是一个可能的回答，下表阐述了每一个字符的含义

`y`：执行替换

`n`：跳过此次替换

`a`：执行此次替换和之后的所有替换

`q或ESC`：停止替换

`l`：执行此次替换并停止替换，是`last`的缩写

`Ctrl + E`或`Ctrl + Y`分别是向下滚动和向上滚动，能用于查看替换出的上下文

### 编辑多个文件

用户经常遇到需要同时编辑多个文件的情况。可能是需要对多个文件做出修改，或是拷贝文件的部分内容到另一个文件。用户可以通过在命令行具体指定多个文件的方式使 vi 打开多个文件

`vi file1 file2 file3...`

**切换文件**

使用以下 ex 命令来从一个文件切换到下一个文件

`:n`

切换回上一个文件

`:N`

当用户从一个文件切换到另一个的时候，vi 要求用户必须先保存对当前文件做出的修改才能切换到其他文件。若要放弃对文件的修改并使 vi 强制切换到另一个文件，可在命令后添加感叹号`!`

除了以上描述的切换方法之外，vim 还提供了一些 ex 命令让用户可以更轻松地编辑多个文本。用户可以使用`:buffers`来查看正在编辑的文件列表

输入`:buffer`加文件编号可切换到另一个文件

**载入更多的文件**

我们以可以在现有的编辑会话中载入更多的文件，使用 ex 命令`:e`加文件名可以载入另一个文件。先退出现有的编辑会话并回到命令行模式

`:e file`

**文件之间的内容复制**

用户在编辑多个文件的过程中，有时会需要将一个文件中的一部分复制到另一个文件中。使用之前使用过的复制和粘贴命令即可完成此功能

使用`:buffer 1`切换到文件1，之后使用`yy`命令复制第一行，使用`:buffer 2`来切换到文件2进行粘贴

**插入整个文件**

用户可以将一个文件完全插入正在编辑的文件中。

通过`vi file1`打开文件，使用`:r foo.txt`可以将指定文件内容插入到光标位置之前

**保存工作**

vi 提供了很多方式保存编辑过的文件，前面已经介绍过`:w`，但是还是有其他可用的方法，当命令`:w`指定一个随意的文件名时，命令的功能就类似于另存为，例如用户在编辑`foo.txt`的时候想要将其另存为`foo1.txt`，那么就可以输入如下内容

`:w foo1.txt`

## 定制提示符

和 Linux 中的很多提示符一样，shell 提示符的可配置性很高。尽管大多数用户并不重视提示符，但是，一旦我们学会了怎样控制它，它就会成为一种相当有用的设备

### 提示符的分解

系统默认提示符看起来如下所示

`[me@linuxbox ~]$`

提示符是由名为`PS1(prompt string 1 的缩写，即提示符字符串 1)`的环境变量定义的，`echo`命令可以帮助用户看到`PS1`的值

`echo $PS1` => `[\u@\h \W]\$`

可以看出，PS1 包含了一些提示符中出现的符号，它会与下表中的由反斜杠转义的特殊字符有关

`\a`：ASCII 铃声，在遇到该转义字符时，计算机发出哔哔声

`\d`：当前日期，以星期、月、日的形式表示，如`Mon May 26`

`\h`：本地机器的主机名，但是不带域名

`\H`：完整的主机名

`\j`：当前 shell 会话中进行的任务个数

`\l`：当前设备名称

`\n`：换行符

`\r`：回车符

`\s`：shell 程序的名称

`\t`：当前时间（24小时制），格式为小时：分钟：秒

`\T`：当前时间（12小时制）

`\@`：当前时间（12小时制，格式为 AM/PM）

`\A`：当前（24小时制），格式为小时：分钟

`\u`：当前用户的用户名

`\v`：shell 的版本号

`\V`：shell 的版本号和发行号

`\w`：当前工作目录名

`\W`：当前工作目录名称的最后一部分

`\!`：当前命令的历史编号

`\#`：当前 shell 会话中输入的命令数

`\$`：在非管理员全县辖输出`$`，管理员权限下输出`#`

`\[`：标志一个或多个非打印字符序列的开始。用于嵌入非打印的控制字符，使其以一定方式操纵总段仿真器，比如移动光标或更改文本颜色

`\]`：标志着非现实字符序列的结束

### 尝试设计提示符

通过这个特殊字符列表我们可以更该提示符来查看效果。我们首先备份现有字符串以便过后进行恢复，为此，将现有的字符串赋值到我们创建的另外一个 shell 变量中

`ps1_old="$PS1"`

### 添加颜色

大多数终端都会响应某些非打印字符序列，来控制光标位置、字符属性（如颜色、粗体、文本闪烁等）等内容。现在先来讲解颜色

字符颜色是由发送到终端的仿真器的一个 ANSI 转义代码来控制的，该转义代码嵌入到了要显示的字符流中。控制代码不会打印到屏幕上，而是被终端解释为一条指令。`\[`和`\]`这两个序列用来封装非打印字符串，一个 ANSI 转义代码以八进制 033 开始，后面跟着一个可选的字符属性，之后是一条指令。例如，将文本颜色设置为正常（attribute = 0）、黑色代码是`\033[0;30m`

下表列出了可用的文本颜色，需要注意的是，这些颜色分为两组，区别在于是否应用了粗体(bold)属性，这个属性使得色彩分为深色和浅色

`033[0;30m`：黑色

`033[0;31m`：红色

`033[0;31m`：绿色

`033[0;32m`：棕色

`033[0;33m`：蓝色

`033[0;34m`：紫色

`033[0;35m`：青色

`033[0;36m`：淡灰色

`033[0;37m`：深灰色

`033[1;30m`：淡红色

`033[1;31m`：深红色

`033[1;32m`：淡绿色

`033[1;33m`：黄色

`033[1;34m`：淡蓝色

`033[1;35m`：淡紫色

`033[1;36m`：淡青色

`033[1;37m`：白色

现在我们创造红色的提示符

`PS1="\[\033[0;31m]<\u@\h \W>\$\[\033[0m\]"`

使用下标代码可以设置文本的背景颜色，背景颜色不支持粗体属性

`033[0;40m`：黑色

`033[0;41m`：红色

`033[0;42m`：绿色

`033[0;43m`：棕色

`033[0;44m`：蓝色

`033[0;45m`：紫色

`033[0;46m`：青色

`033[0;47m`：淡灰色

> 文本除了正常的(0)和粗体(1)属性外，开可以设置为下划线(4)，闪烁(5)和斜体(7)

### 移动光标

转移代码也可以用来定位光标。比如在提示符出现的时候，这些转移代码通常用来在屏幕的不同位置（比如屏幕上方的一角）显示一个时钟或其他信息。下表为可以定位光标的转移代码

`033[1;cH`：将光标移动至1行c列

`033[nA`：将光标向上移动 n 行

`033[nB`：将光标向下移动 n 行

`033[nC`：将光标向前移动 n 个字符

`033[nD`：将光标向后移动 n 个字符

`033[nB`：清空屏幕并将光标移动至左上角（第0行第0列）

`033[1;cH`：清空当前光标位置到行末的内容

`033[1;cH`：存储当前光标位置

`033[1;cH`：恢复之前存储的光标位置

### 保存提示符

很显然，用户不会想要每次都输入这样一长串代码，所以就需要将提示符存储在某个地方，将提示符添加到`.bashrc`文件中是一个一劳永逸的解决办法











