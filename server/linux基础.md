# linux 基础
## 文件权限与目录配置
### 用户与用户组
常见权限有以下四种
1. 文件拥有者
2. 用户组，用于合作的权限
3. 其他人
4. root，啥都可以做
默认情况下，所有系统上的账号与一般身份用户，还有那个`root`相关信息，都在`/etc/passwd`这个文件内，个人密码则是记录在`/etc/shadow`这个文件内，所有用户组名记录在`/etc/group`

### 文件权限概念
`ls -al`可以查看目录下的文件属性和权限，包括隐藏文件。每个文件和目录都会显示 7 个字段，比如`-rw-r--r-- 1 root root 1864 May 4 18:01 initial-setup-ks.cfg`
- `-rw-r-r--`文件类型权限
  - 第一个字符代表文件是目录、文件或是链接文件等，`d`为目录，`-`为文件，`l`为链接，`d`为设备与设备文件，`s`为接口文件，`p`为数据输送文件
  - `r(read)`为读权限，可以查询该目录下的文件名数据。可以查看文件的文本内容
  - `w(write)`为写权限，具有改动该目录结构列表的权限，与该目录下的文件名的变动有关。可以编辑、新增或是修改该文件的内容，但不能删除
  - `x(execute)`为执行权限，用户能否进入该目录成为工作目录，比如`cd`。文件是否可悲系统执行
  - 三组权限描述的分别为文件拥有者、加入此用户组账号的权限、为本人且没有加入本用户组其他账号的权限
- `1`链接数，表示多少文件名链接到此节点`inode`
- `root`文件拥有者的账号
- `root`文件所属用户组
- `1864`文件大小，默认为`Bytes`
- `May 4 18:01`文件为创建日期或是最后被修改时间，如果想要看完整时间，可以使用`ls -l --full-time`
- `initial-setup-ks.cfg`文件名，如果文件之前有`.`则为隐藏文件，使用`ls -a`可查看

### 修改文件属性与权限
下面有几个常用与用户组、拥有者、各种身份的权限修改的命令
- `chgrp(change group)`修改文件用户组，用户组必须在`/etc/group`文件中
- `chown(change own)`修改文件拥有者，用户必须存在于`/etc/passwd`文件中
  - `-R`递归修改，所有子目录的文件都会被修改
  - `chown 用户:用户组 文件`可同时修改拥有者和用户组
  由于`cp`会复制执行者的属性与权限，所以有时需要修改权限
- `chmod`修改文件的权限，`SUD`、`SGID`、`SBIT`等的特性，我们可以通过数字来代表各个权限，`r:4 w:2 x:1`每种角色的权限是可以累加的，比如
`-rwxrwx---`的数字则是`770`
  - `-R`也是递归修改权限
  - 我们也可借由`u`、`g`、`o`来代表`user`、`group`、`other`三种角色，`a`则表示`all`，比如
  `-rwxr-xr--`可`chmod u=rwx,g=rx,o=r 文件名`来进行设置，同时有几种操作用于设置`+`加入，`-`移除、`=`设置

### 目录配置
Linux发行版它们的配置文件、执行文件、每个目录内放置的东西都是有一套标准依据
`FHS(Filesystem Hierarchy Standard`，它的主要目的是希望让用户可以了解到已安装软件通常放置于哪个目录下，一般来讲目录有下面四种交互作用的形态
| | 可分享 | 不可分享 |
| 不变 | /usr 软件存放处 | /etc 配置文件 |
| | /opt 第三方辅助软件 | /boot 启动与内核文件 |
| 可变动 | /var/mail 用户邮箱 | /var/run 程序相关 |
| | /var/spool/news 新闻组 | /var/lock 程序相关 |
- 可分享：可分享给其他系统挂载使用的目录
- 不可分享：自己机器上运行设备文件或是与程序有关的`socket`文件等
- 不变：有些数据是不经常变动的，比如函数库，文件说明，系统管理员所管理的主机服务配置文件等
- 可变动：经常修改单数据，比如日志文件、一般用户可自行接收的新闻组等
事实上，FHS 针对目录数架构仅定义出三层目录下面应该防止什么数据而已
- `/(root, 根目录)`：与启动系统相关
- `/usr(unix software resource)`：与软件安装、执行有关
- `/var(variable)`：与系统运行过程有关

## 文件与目录管理
### 目录的相关操作
- `cd(change directory)`：切换目录
- `pwd(print working directory)`：显示当前目录
- `mkdir(make directory)`：建立一个新目录
- `rmdir`：删除一个空目录

### $PATH
环境变量`PATH`可以让在输入命令时找到对应的命令文件，它是由一堆目录组成，每个目录中间用`:`隔开，每个目录有顺序之分。当执行目录时会根据`PATH`的设置去每个`PATH`定义的目录下查找文件名为命令名的可执行文件，先查找到的同名命令先被执行，另外要注意
- 不同身份用户默认的`PATH·不同，默认能够随意执行的命令也不同
- `PATH`是可以被修改单
- 使用绝对路径或是相对路径来指定某个命令的文件名执行会比查找`PATH`来的正确
- 命令应该要放到正确的目录下执行才会更方便
- 本目录`.`最好不要放到`PATH`当中

### ls
- `-a`全部文件，包括隐藏文件
- `-d`仅列出目录本身，而不是列出目录内地文件数据
- `-l`详细信息显示，包括文件的属性与权限等数据
- `-i`列出`inode`号码
- `-f`直接列出结果，而不进行排序
- `-S`根据文件大小列出文件
- `-t`根据时间排序

### cp、rm、mv
- `cp`命令除了单纯地复制之外，还可建立链接文件，比如两文件的新旧而予以更新，默认情况下目标文件拥有者会是命令操作者本身
  - `-a`：相当于`-dr --preserve=all`的意思
  - `-i`：若目标文件已经存在时，在覆盖时会先寻味操作的进行
  - `-p`：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性
  - `-r`：递归复制，用于目录的赋值操作
  - `-s`：复制成为符号链接问价，即”快捷方式“文件
  - `-l`：硬链接的链接文件建立
  - `-u`：当`destination`比`source`旧或是`destination`旧的情况下才更新`destination`
- `rm`用于删除文件或目录，默认情况下，会加入`-i`选项
  - `-f`：就是`force`的意思，忽略不存在的文件，不会出现警告信息
  - `-I`：交互模式，再删除前会询问使用者是否操作
  - `-r`：递归删除，最常用于目录的删除，是非常危险的选项
- `mv`移动文件与目录或是重命名
  - `-f`强制删除文件
  - `-i`覆盖前询问是否覆盖
  - `-u`若目标文件已经存在，且`source`比较新才会更新
- `basename <路径>`取得最后的文件名
- `dirname <路径>`取得前面的目录名

### 文件内容查看
- `cat(concatenate 串联)`从第一行开始显示文件内容
- `tac`也就是`cat`倒过来写，从最后一行开始显示
- `nl`显示的时候同时输出行号
- `more`只能往后翻页
  - 空格键往后翻页
  - `Enter`代表向下翻一行
  - `/字符串`表示向下查找字符串
  - `:f`立刻显示出文件名以及目前显示的行数
  - `:q`代表立即离开`more`，不再显示该文件内容
  - `b`或`ctrl + b`表示往前翻页
- `less`可以往前后翻页
  - 空格键向下翻页
  - `[pagedown]`向下翻页
  - `[pageup]`向上翻页
  - `/字符串`向下查找字符串的功能
  - `?字符串`向上查找字符串的功能
  - `n`重复前一个查找
  - `N`反向重复前一个查找
  - `g`前进到文件第一行
  - `G`前进到文件的最后一行
  - `q`离开`less`
- `head`只看前面几行，默认显示 10 行
  - `-n`可接收一个负数和正数，其中负数就是除了后面的几行不会被打印
- `tail`只看后面几行，默认显示 10 行
  - `-n`可接收一个负数和正数，其中负数就是除了前面的几行不会被打印
- `od`以二进制方式读取文件内容
  - `-t c`的选项来以哪种格式打印
- `touch`用于修改文件时间或创建新文件
  当使用`ls`这个命令时，每个文件有三个主要的变动时间
  - 修改时间`modified time(mtime)`：当文件的内容数据变更时，就会更新这个时间，内容数据指的是文件的内容，而不是文件的属性或权限
  - 状态时间`status time(ctime)`：当文件的状态改变时，就会更新时间，比如权限或是属性被修改了
  - 读取时间`access time(atime)`：当文件被读取时，就会更新这个时间，比如使用`cat`去读取文件
  使用`ls -l`默认显示的时间就是`mtime`
  - `-a`仅自定义`access time`
  - `-c`仅修改文件的时间，若该文件不存在则不建立新文件
  - `-m`仅修改`mtime`
  - `-t`后面可以接欲自定的时间而不用目前的时间，格式为`[YYYYMMDDhhmm]`

### 文件与目录的默认权限
- `umask`就是指定目前用户在建立文件或目录时候的权限默认值，默认会输出四个权限数字，其中第一组是特殊权限用的
  - `-S(Symbolic)`会以符号类型的方式来显示出权限
  - 后面可以跟上数字，数字为需要删除的权限
- `file`可以知道某个文件的基本信息，例如是属于`ASCII`或是数据文件或是二进制文件，且其中有没有使用到动态链接库`share library`

### 命令与文件的查找
- `which`可以查找*执行文件*，这个命令是根据`PATH`这个环境变量所规范的路径去查找执行文件的文件名，所以重点是查找出执行文件而已
  - `-a`：将所有由`PATH`目录中可以找到的命令均列出，而不是第一个被找到的文件名称
- `whereis`：从一些特定目录中查找文件，主要是针对`/bin,/bins,/usr/share/man`以及几个特定的目录来处理而已
  - `-l`：列出`whereis`会去查询的几个目录
  - `-b`：只找出二进制文件
  - `-m`：只找在说明文件`manual`路径下的文件
  - `-s`：只找`source`源文件
  - `-u`：查找不在上述三个项目当中的其他特殊文件
- `locate`直接在后面输入文件部分名称后，就能够得到结果，但它寻找的命令是在已建立的数据库`/var/lib/mlocate/`里面的数据所查找到的，数据库默认每天更新一次
- `updatedb`用于直接更新`locate`所依赖的数据库
- `find`可以查找所有文件
  - `-mtime n`：`n`为数字，为`n`天之前的*一天之内*被修改过内容的文件
  - `-mtime +n`：列出在`n`天之前*不包含`n`天本身*被修改过内容的文件
  - `-mtime -n`：列出在`n`天之内*含`n`天本身*被修改过内容的文件
  - `newer file`：`file`为一个存在的文件，列出比`file`更新的文件
  - `-uid n`：`n`为数字，这个数字是使用者的账号ID，就是`UID`，记录在`/etc/passwd`里
  - `-gid n`：`n`为数字，这个数字式用户组名称的ID，就是`GID`，记录在`/etc/group`里
  - `-user name`：`name`为使用者账号名称
  - `-group name`：`group`为用户组名称
  - `-nouser`：查找文件的拥有者不再`/etc/passwd`中的文件
  - `-nogroup`：查找文件的拥有用户组不存在于`/etc/group`中的文件
  - `-name filename`：查找文件名为`filename`的文件
  - `-size [+-]SIZE`：查找比`SIZE`还要大`+`或是小`-`的文件，`c`代表`Bytes`，`k`代表`1024Bytes`
  - `-type TYPE`：查找文件类型为`TYPE`的
  - `-perm mode`：查找文件权限刚好等于`mode`的文件
  - `-perm -mode`：查找文件权限必须要全部囊括`mode`的权限
  - `-perm /mode`：查找文件权限包含任一`mode`的权限

## linux 磁盘与文件系统管理
linux 最传统的磁盘文件系统使用的是`ext2`。较新的操作系统的文件除了文件实际内容外，通常含有非常多的属性，文件系统通常会将这两部分数据分别存放在不同的区块，权限与属性放在`inode`中，实际数据则放置到数据区块中。另外还会有一个超级区块`superblock`会记录整个文件系统的整体信息，包括`inode`与数据区块的总量、使用量和剩余量
需要碎片整理的原因就是文件写入的区块太过于离散，此时文件读取的性能将会变得很差，此时可以通过碎片整理将同一个文件所属地曲会计合在一起，这样数据的读取就会比较容易
每个文件都会占用一个`inode`，可依据文件内容的大小来分配多个区块给该文件使用
- 当我们在 Linux 下单文件系统建立一个目录时，文件系统就会分配一个`inode`和至少一块区块给该目录，其中，`inode`记录该目录的相关权限与属性，并记录分配到的那块区块号码，但当目录下文件太多时，会多给一个区块记录区块号码，可以使用`ls -i`来观察文件占用的`inode`号码
- 当我们在 linux 下的`ext2`建立一个一般文件时，`ex2`会分配一个`inode`与相对于该文件大小的区块数量给该文件
- 当需要读取某个文件时，会先读取目录的`inode`再读取目录的区块，最后读取文件的`inode`和区块
- 当我们需要创建一个文件，此时文件系统的操作是
  1. 先确定用户对于欲新增文件的目录是否具有`w`与`x`的权限，有的话才能新增
  2. 根据`inode`对照表找到没有使用的`inode`号码，并将新文件的权限/属性写入
  3. 根据区块对照表找到没有使用中的区块号码，并将实际的数据写入区块中，且更新`inode`的区块指向数据
  4. 将刚刚写入的`inode`与区块数据同步更新`inode`对照表与区块对照表，并更新超级区块的内容
- 我们将数据区块称为数据存放区域，`inode`对照表，区块对照表和超级区块则被称为元数据`metadata`，因为每次增删改都会影响到这三部分数据
所有的数据要加载到内存后 cpu 才能进行处理，所以在编辑较大文件时，不能让系统频繁地在磁盘上读写内容，此时 linux 使用了一个别称为异步处理`asynchronously`的方式
当系统加载一个文件到内存后，如果该文件没有被修改过，则在内存区段的文件数据会被设置为`clean`。但如果内存中的文件数据被更改过了，则被设置为`dirty`，此时所有操作还在内存中执行，没有写入到磁盘中，系统会不定时地将内存中的`dirty`数据写回磁盘，以保证磁盘与内存数据的一致性，我们可以使用`sync`命令来强制写入磁盘，如果主动关机，会调用`sync`命令将数据写入磁盘
- 每个文件系统都有独立的`inode`、区块、超级区块等信息，将文件系统与目录树结合的操作我们称为挂载。挂载点一定是目录，该目录为进入该文件系统的入口
- 同一个文件系统的`inode`号码只会对应到一个文件内容
- centos 7 使用的文件系统已经切换为`xfs`了，它一般用来开发高容量磁盘以及高性能文件系统，并且几乎所有`ext4`文件系统所特有的功能，`xfs`都具备。

### 文件系统的简单操作
- `df`：列出文件系统的整体磁盘使用量，由于读取的是超级区块的信息，因此速度非常快
  - `-a`：列出文件系统的整体磁盘使用量
  - `-k`：以`KBytes`的容量显示各文件系统
  - `-m`：以`MBytes`的容量显示各文件系统
  - `-h`：以人类更易阅读的`GBytes`、`MBytes`、`KBytes`等格式自行显示
  - `-H`：以`M=1000K`替换`M=1024K`的进位方式
  - `-T`：连同该硬盘分区的文件系统名称列出
  - `-i`：不用磁盘容量，而以`inode`的数量来显示
- `du`：查看文件系统的磁盘使用量，常用查看目录的磁盘使用量
  - `-a`：列出所有文件与目录容量
  - `-h`：以人们较易读懂的格式`G/M`来显示
  - `-s`：仅列出容量，而不列出每个个别的目录占用容量
  - `-S`：不包括子目录下的总计
  - `-k`：以`KBytes`的容量显示
  - `-m`：以`MBytes`的容量显示
- `ln`：不加任何参数就是建立硬链接
  - 硬链接实际上就是新增一条文件名链接到某`inode`号码的关联记录，即多个文件名对应到同一个`inode`号码。使用硬链接链接文件时，磁盘的空间和`inode`数据都不会改变
硬链接其实是有限制的
    - 不能跨文件系统
    - 不能链接目录
  - 符号链接实际上就是建立一个独立的文件，而这个文件会让数据的读取指向它链接的那个文件的文件名，所以当源文件被删除之后，符号链接的文件只会一直说无法打开某文件。另外注意，它会占用`inode`和区块
  - `-s`建立符号链接
  - `-f`如果目标文件存在时，就主动将目标文件直接删除后再建立
  - 当我们建立一个空目录时，会存在`.`与`..`两个目录，所以新的目录的连接数为`2`

### 磁盘的分区、格式化、检验与挂载
如果我们想在系统里新增一个磁盘，有以下操作需要做
1. 对该磁盘进行划分，建立可用的磁盘分区
2. 对该硬盘分区进行格式化，建立系统可用的文件系统
3. 在 Linux 系统上，需要建立挂载点，将它挂载出来
- `lsblk(list block device)`列出系统上所有的磁盘列表
  - `-d`：仅列出磁盘本身，不会列出磁盘分区数据
  - `-f`：同时列出该磁盘内的文件系统名称
  - `-i`：使用 ASCII 的字符输出，不要使用复杂编码
  - `-m`：同时输出该设备在`/dev`下的权限信息
  - `-p`：列出该设备的完整名，而不是仅列出最后的名字而已
  - `-t`：列出该磁盘设备的详细数据
  列出的字段表示
  - `NAME`：设备的文件名
  - `MAJ:MIN`：内核识别的设备都是通过这两个代码来实现，分别是主要与次要设备代码
  - `RM`：是否为可卸载设备`remotable device`，比如光盘、usb等
  - `SIZE`：容量
  - `RO`：是否为只读设备
  - `TYPE`：是磁盘`disk`，分区`partition`，还是只读存储器`rom`
  - `MOUNTPOINT`：挂载点
- `blkid`列出设备的`UUID`等参数
- `parted`列出磁盘的分区表类型与分区类型
- `gdisk <设备名称>`GPT分区表用于分区，同时能执行各种操作比如删除，分区，输入`?`可以查看
- `fdisk <设备名称>`MBR分区表用于分区
当我们需要给磁盘分区时，只需要
1. `lsblk`或`blkid`找到磁盘
2. `parted`找出内部的分区表类型
3. `gdisk`或`fdisk`操作系统，另外在操作途中，按下`q`可以直接退出分区操作，`w`可使操作生效
- `partprobe`直接更新`Linux`内核的分区表信息
- 不要直接处理正在使用的分区，要卸载后再进行分区
- `mkfs(make filesystem)`用于创建文件系统
  - `-b`：后面接区块容量，可由 512 到 64k
  - `-d`：后面接的是重要的`data section`的相关参数
  - `-f`：按已有的文件系统来进行强制格式化
  - `-i`：与`inode`有较相关的设置
  - `-L`：指定`realtime section`的相关设置值
- `xfs_repair`：当`xfs`系统错乱使用这个命令检查/修复文件系统
- `fsck.ext4`：处理`ext4`文件系统
- 当我们要进行挂载时，需要确定以下几件事
  1. 单一文件系统不应该被重复挂载在不同的挂载点
  2. 单一目录不应该重复挂载多个文件系统
  3. 要作为挂载点的目录，理论上应该都是空目录。如果不是空目录，则在挂载之后原目录内容会被隐藏，卸载之后才会恢复显示
- `mount`将文件系统挂载到 Linux 系统上
  - `-a`：依照配置文件`/etc/fstab`的数据将所有未挂载的磁盘都挂载上来
  - `-l`：单纯地输入`mount`会显示挂载信息，加上`-l`可增列`Label`名称
  - `-t`：加上文件系统种类来指定欲挂载的类型
  - `-n`：不将挂载情况写入`/etc/mtab`
  - `-o`：加上一些挂载时额外加入的参数
- `unmount`将已挂载的文件系统进行卸载，卸载之后通过`df`或是`mount`看看是否还存在于目录树中

### 设置启动挂载
系统挂载的限制
- 根目录必须是挂载的，而且一定要先于其他挂载点`mount point`被挂载进来
- 其他挂载点必须为已建立的目录，客人已制定，但必须遵守`FHS`
- 所有挂载点在同一时间内只能挂在一次
- 所有硬盘分区在同一时间内只能挂载一次
- 如果进行卸载，必须将工作目录移到挂载点之外
`/etc/fstab(filesystem table)`就是我们利用`mount`命令进行挂载时，将所有选项与参数写入的文件。这个文件的内容共有六个字段，它们**非常重要**
1. 磁盘设备名：`/UUID/LABEL name`，这个字段可以填写的数据主要有三个项目：
  - 文件系统或磁盘的设备文件名，比如`/dev/vda2`等
  - 文件系统的`UUID`名称
  - 文件系统的`LABEL`名称
2. 挂载点`mount point`：目录
3. 磁盘分区的文件系统：在手动挂载时可让系统自动测试挂载
4. 文件系统参数
5. 能否被`dump`备份命令作用
6. 是否以`fsck`检验扇区

## 文件与文件系统的压缩
在 Linux 上有非常多的压缩命令可以运行，这些压缩命令可以让我们更方便地从网络上下载容量较大的文件
### 压缩文件的用途与技术
比较大型的文件通过所谓的文件压缩技术之后，可以将它的磁盘使用量降低，从而达到降低文件容量的效果。此外，有的压缩程序可以进行容量限制，使一个大型文件可以划分为数个小型文件，以方便携带
### Linux常用的压缩命令
压缩文件的扩展名大多是`*.tar`、`*.tar.gz`、`*.tgz`、`*.gz`、`*.Z`、`*.bz2`、`*.xz`
Linux 支持的压缩命令非常多，且不同的命令所有的压缩技术并不相同
- `*.z`：`compress`程序压缩的文件
- `*.zip`：`zip`
- `*.gz`：`gzip`
- `*.bz2`：`bzip2`
- `*.xz`：`xz`
- `*.tar`：`tar`
- `*.tar.gz`：`tar` + `gz`
- `*.tar.bz2`：`tar` + `bzip2`
- `*.tar.xz`：`tar` + `xz`
`tar`可以将很多文件打包成为一个文件，甚至是目录也可以这么玩。不过，单纯的`tar`只是打包而已并没有其它压缩的功能
- `gzip`所建立的压缩文件为`*.gz`，而`bzip2`则是为了替换`gzip`，它用法也和`gzip`类似。使用`gzip`后，源文件就不再存在了
  - `-c`：将压缩过程所产生的数据输出到屏幕上，可加上`>`来转成文件输出
  - `-d`：解压缩的参数
  - `-t`：可以用来检验一个压缩文件的一致性
  - `-v`：可以显示出源文件/压缩文件的压缩比
  - `-#`：`#`为数字，代表压缩登记`-1`最快，但压缩比最差，`-9`最差，默认为`-6`
- `zcat | zmore | zless | zgrep`可以对应`cat | more | less | grep`来读取纯文本文件被压缩后的压缩文件
- `xz`的用法和`gzip`类似，不过他会消耗很多时间来进行压缩，同时它的压缩比也是最好的
### `tar`
- `tar`用于将多个文件打包到一起
  - `-c`：建立打包文件，可搭配`-v`来查看过程中被打包的文件名
  - `-t`：查看打包文件的内容含有那些文件名，重点在查看文件名
  - `-x`：解包或解压缩的功能，可搭配`-C`在特定目录解压，`-c -t -x`不可出现在一串命令行中
  - `-z`：通过`gzip`的支持进行压缩/解压缩，此时文件名最好为`*.tar.gz`
  - `-j`：通过`bzip2`的支持进行压缩/解压缩
  - `-J`：通过`xz`进行压缩/解压缩
  - `-v`：在压缩/解压缩过程中将正在处理文件名展示出来
  - `-f <文件名>`：后面接要被处理的文件名
  - `-C`：在特定目录解压缩
  - `-p`：保留备份数据的原本权限与属性
  - `-P`：保留绝对路径，即允许备份的文件中保存根路径
  - `--exclude=FILE`：在压缩过程中不要将`FILE`打包
其实最简单的使用`tar`就是使用下面的命令即可
- 压缩：`tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称;
- 查询：`tar -jtv -f filename.tar.bz2`;
- 解压缩：`tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录；

### XFS 文件系统备份与还原
使用`tar`通常是对目录树系统来进行备份的工作，如果想要针对整个文件系统来进行备份与还原可以使用 XFS 的`xfsdump`和`xfsrestore`来进行备份
- `xfsdump`使用此命令进行完整备份后，等一段时间的文件系统自然运行后，在进行第二次`xfsdump`进行备份时，可以使用增量备份，另外使用`xfsdump`时，应该注意下面的限制
  - 不支持没有挂载的文件系统备份，所以只能备份已挂载的文件系统
  - 必须使用 root 的权限才能操作
  - 只能备份 xfs 系统
  - 备份下来的数据只能让`xfsrestore`解析
  - 它是通过文件系统的`UUID`来辨别各个备份文件，因此不能备份两个具有相同`UUID`的文件系统
  如果只是想要简单的操作，只需要记得下面的选项
  - `-L`：会记录每次备份的`session`标头，这里可以填写针对此文件系统的简易说明
  - `-M`：可以记录存储媒介的标头，这里可以填写此媒介的简易说明
  - `-l`：是`L`的笑了，就是指定等级，有`0~9`共10个等级
  - `-f`：有点类似`tar`，后面接产生的文件
  - `-I`：从`/var/lib/xfsdump/inventory`列出目前备份的信息状态
- `xfsrestore`：备份文件可以在急用时恢复系统的重要数据，这个命令可以恢复备份文件
  - `-I`：查询备份数据
  - `-f`：后面接的备份文件，可以接文件名
  - `-L`：就是`session`的`Label name`，可用`-I`查询到的数据，在这个选项后输入
  - `-s`：需要接某特定目录
  - `-r`：如果用文件来存储备份数据，则不需要使用，如果有多个文件，则需要此选项来完成累积恢复
  - `-i`：进入交互模式

## BASH
bash 操作环境的创建、数据流重定向的功能，还有好用的管道命令

### 认识`bash`这个`shell`
`shell`让我们能够操作系统的内核`kernel`来控制硬件进行工作，`/etc/shells`这个文件至少有下面这几个可以用的`shells`
- `/bin/sh`：被`/bin/bash`替换
- `/bin/bash`：为 Linux 默认的 shell
- `/bin/tcsh`：整合`C Shell`，提供更多的功能
- `/bin/csh`：已经被`/bin/tcsh`所替换
`bash`的主要优点有下面几个
- `history`：使用过的命令存在`~/.bash_history`中，记录的是前一次登录以前所执行的命令，而这一次登录所执行的命令都被缓存到内存中，注销系统后才会记录到`.bash_history`中
- `[Tab]`键的时机根据`[tab]`接在命令后或参数后而有所不同
  - `[tab]`接在一串命令的第一个字后面，则为命令补全
  - `[tab]`接在一串命令的第二个字后面，则为`文件补齐`
  - 若安装`bash-completion`软件，则在某些命令后使用`[tab]`按键时，可进行`选项参数的补齐`功能
- `alias`：可设置别名，比如`alias ll = 'ls -al'`
- `job control | foreground | background`：可进行任务管理、前台、后台控制
- `shell script`：也就是程序化脚本
- `wildcard`：通配符
- `type`：`bash`会内置很多命令，而`type`可以查看命令是否来自于外部命令
  - `-t`：会将`name`以下面这些字眼显示出它的意义
    - `file`：表示为外部命令
    - `alias`：表示该命令别名所设置的名称
    - `builtin`：表示该命令为`bash`内置的命令功能
  - `-p`：如果后面接的`name`为外部命令时，才会显示完整文件名
  - `-a`：会由`PATH`变量定义的路径中，将所有含`name`的命令都列出来，包含`alias`

### 变量
在我目前这个`shell`的情况下启动另一个新的`shell`，则新的那个`shell`就是子进程，父进程的自定义变量无法在子进程内使用
- `$(命令)`为命令的输出
- 单引号和双引号的最大不同是双引号可以保有变量的内容，但单引号近视一般字符，不会有特殊字符
- 环境变量可以帮我们实现很多功能，我们可以利用两个变量来查看，分别是`env`和`export`
- `env`观察环境变量与常见环境变量说明，会展示下面几个环境变量
  - `HOME`：用户的根目录，利用`cd ~`可以回到根目录
  - `SHELL`：当前环境使用的是哪个`shell`
  - `HISTSIZE`：这个和历史命令有关
  - `MAIL`：使用这个命令收信时，系统会去读取的又想我呢间
  - `PATH`：执行文件查找的路径
  - `LANG`：就是语系数据
  - `RANDOM`：就是随机数的变量，随机数生成器就是`/dev/random`这个文件
- `set`可以观察所有变量，在 linux 默认的变量中，大写字母的就是系统内定需要设置的变量，比较重要的有
  - `PS1`：提示字符的设置，当我们每次按下`Enter`执行命令后，最后要再次出现提示字符时，就会主动去读取这个变量值
  - `$`：也就是当前正在进行的进程的`PID`
  - `?`：上个执行命令的返回值。如果成功执行，则返回`0`，如果执行过程发生错误，会返回非`0`数值
  - `OSTYTE | HOSTTYPE | MACHTYPE`：主机硬件和内核的等级
- `export`：自定义变量转成环境变量，环境变量和自定义变量的差异在于*该变量是否被子进程所引用*，此时使用这个命令可以共享自己的变量设置给后来调用的文件或其他进程。如果没有接变量名就会展示所有变量
- `locale`可以查看支持的语系
  - `-a`：可以展示所有支持的语系
- 当启动一个`shell`，操作系统会分配一块内存区域给`shell`使用，此内存中的变量可让子进程使用，当加载另一个`shell`时，子`shell`可将父`shell`的环境变量所在的内存区域导入到自己的环境变量区域
- `read <变量>`：读取来自键盘树的变量
  - `-p`：后面接提示字符
  - `-t`：后面接等待的*秒数*
- `declare | typeset`是一样的功能，就是声明变量的类型，如果`declare`后面没有接任何参数，那么`bash`会主动将所有的变量名称和内容统统显示出来
  - `-a`：将后面的变量定义为数组
  - `-i`：整数
  - `-x`：变为环境变量
  - `-r`：设置为`readOnly`类型，需要注销再登录才能恢复该变量的类型
- `ulimit`：可以限制用户端某些系统资源，包括可以开的文件数量，可以使用的 CPU 时间，可以使用的内存总量等
  - `-H`：严格的设置，必定不能超过这个设置的数值
  - `-S`：警告的设置，可以超过这个设置的数值，操作将有警告信息
  - `-a`：不接参数可列出所有限制的额度
  - `-c`：某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件
  - `-f`：此`shell`可以建立的最大文件容量，单位为`Kbytes`
  - `-d`：此程序可使用的最大段内存容量
  - `-l`：可用于锁定`lock`的内存量
  - `-t`：可使用的最大`CPU`时间（单位为秒）
  - `-u`：单一使用者可以使用的最大进程`process`数量
- `path#/*local/bin:`：可以删除变量中的字符串，`#`表示符合替换文字的最短的那一个，`##`表示符合替换文字最长的那一个, `%`和`%%`表示由后向前匹配，`\`和`\\`表示替换
- `${username-root}`：可以用来测试变量是否为空，如果为空，则`root`的值会替换`username`的值，如果没替换而`echo $username`还为空，则`username`的值为空字符串

### 命令别名与历史命令
- `alias`：可将命令替换为其他命令
- `unalias`：删除别名
- `history`：可以读取使用过的命令
  - 当我们以`bash`登录 Linux 主机之后，系统会主动地由家目录的`~/.bash_history`读取以前执行过的命令，读取的命令条数和`bash`的`HISTFILESIZE`这个变量值有关
  - `!<number>`：用于执行对应`number`的命令
  - `!<command>`：由最近的命令向前查找命令串开头为`command`的命令，并执行
  - `!!`：执行上一个命令

### BASH SHELL 的操作环境
- 命令运行的顺序可以这样看
  1. 以相对/绝对路径执行命令，例如`/bin/ls`或`./ls`
  2. 由`alias`找到该命令来执行
  3. 由`bash`内置的`builtin`命令来执行
  4. 通过`$PATH`这个变量的顺序查找到的第一个命令来执行
- `/etc/issue`：保存了登陆画面与登录信息
- `/etc/motd`：可让用户登录后取得一些信息
如果想要你的配置在每次打开shell都会生效，就需要将设置写入配置文件
- `login shell`为需要输入账号密码才能获取的终端，它只会读取以下两个配置文件
  - `/etc/profile`：这个系统整体的设置，最好不要修改。这个配置文件可以利用用户标识符`UID`来决定很多中啊哟的变量数据，这也是每个用户登录一定会读取的配置文件，它还会调用外部的配置文件，在 Centos7 下，还会调用以下文件
    - `/etc/profile.d/*.sh：`这是个目录内的众多文件。只要在`/etc/profile.d/`这个目录内且扩展名为`.sh`并且具有`r`的权限，那么就会被`/etc/profile`调用
    - `/etc/locale.conf`：这个文件是由`/etc/profile.d/lang.sh`调用的，决定默认使用何种语系
    - `/usr/share/bash-completion/completions/*`：用于进行命令补齐，文件名补齐
  - `~/.bash_profile`或是`~/.bash_login`或`~/.profile`：属于个人设置，按先后顺序调用，如果前一个存在，后一个就不会被调用
- `source`：可以不用重新登录直接读入环境配置文件
- `non-login shell`仅仅只会读取`~/.bashrc`
- `/etc/man_db.conf`：用于规范`man page`的路径到那里去寻找
- `~/.bash_history`：用于记录历史命令
- `~/.bash_logout`：记录了在注销 bash 后，系统帮我做完什么操作才离开
- `stty(setting tty)`：可以帮助设置终端的输入按键代表的意义
  - `-a`：可以列出目前环境中所有的按键列表
- `set`：可以设置一些 bash 自己的一些终端设置值，以及整个命令输出/输入的环境

###  数据流重定向
- 标准输出指的是命令执行返回的正确信息，而标准错误输出可理解为命令执行失败后，所返回的错误信息
- 标准输出如果没有重定向就会显示在屏幕上，数据流重定向传送所用的特殊字符如下
  - 标准输入`stdin`：代码为`0`，使用`<`或`<<`
  - 标准输出`stdout`：代码为`1`，使用`>`或`>>`，`>`会覆盖文件，`>>`会累加文件内容
  - 标准错误输出`stderr`：代码为`2`，使用`2>`或`2>>`
- `/dev/null`：垃圾桶黑洞设备与特殊写法，可以将错误信息忽略掉而不显示或存储，可以吃掉任何导向这个设备的信息
- `<command1>;<command2>`：可一次执行多个命令，执行完前一个后就会立即执行下一个
- `<command1>&&<command2>`：如果`command1`执行完毕且正确执行`$?=0`，则开始执行`command2`，如果为错误`$?!=0`则不执行`command2`
- `<command1>||<command2>`：如果`command1`执行完毕且正确执行`$?=0`，则开始不执行`command2`，如果为错误`$?!=0`则开始执行`command2`

### 管道命令(pipe)
管道命令只会处理经过前一个命令的标准输出的信息，对于标准错误并没有处理能力
- `cut`：可以将一段信息的某一段切出来，处理的信息以行为单位
  - `-d`：后面接分隔字符，与`-f`一起使用
  - `-f`：根据`-d`的分隔字符将一段信息划分为数段，用`-f`取出第几段
  - `-c`：以字符的单位去除固定字符区间
- `grep`：分析一行信息，如果有我们所需要的信息，就将该行取出
  - `-a`：将二进制文件以文本文件的方式查找文件
  - `-c`：计算找到查找字符的次数
  - `-i`：忽略大小写的不同
  - `-n`：顺便输出行号
  - `-v`：反向选择
  - `-A(after)`：可接数字，在匹配行之后的多少行也会显示
  - `-B(before)`：可接数字，在匹配行之前的多少行也会显示
  - `--color=auto`：可以将找到的关键字部分加上盐泽的提示
- `sort`：可以帮我们进行排序，且可以更具不同的数据形式来排序
  - `-c`：忽略大小写的差异
  - `-b`：忽略最前面的空格字符部分
  - `-M`：以月份的名字来排序，比如`JAN、DEC`等的排序方法
  - `-n`：使用纯数字进行排序
  - `-r`：反向排序
  - `-u`：就是`uniq`，相同的数字中，仅出现一行代表
  - `-t`：分隔符号，默认为`tab`来分隔
  - `-k`：以哪个区间进行排序的意思
- `uniq`：如果排序完成，可以将重复的数字仅列出一个显示
  - `-i`：忽略大小写字符的不同
  - `-c`：进行计数
- `wc`：可以计算出输出信息的整体数据
  - `-i`：仅列出行
  - `-w`：仅列出多少字
  - `-m`：多少字符
- `tee`：此命令会将数据流分送到文件与屏幕
- `tr`：可以删除一段信息当中的文字
  - `-d`：删除信息当中的字符
  - `-s`：替换掉重复的字符
- `col`：将`[tab]`替换为空格
  - `-A`：显示所有特殊按键最后以`col`将`[tab]`转成空白
  - `-x`：将`[tab]`键转换为对等的空格键
- `join`：处理两个文件之间的数据，主要是处理两个文件当中，有相同数据的一行，才将它加到一起
  - `-t`：以空格符分隔数据，并且比对第一个阑尾的数据，如果两个文件相同，则将两条数据连成一行，且第一个栏位放在第一个
  - `-i`：忽略大小写的差异
  - `-1`：代表第一个文件要用哪个栏位分析
  - `-2`：代表第二个文件要用哪个栏位分析
- `paste`：直接将两行贴在一起，且中间以`[tab]`键隔开
  - `-d`：后面可以接分隔字符，默认为`[tab]`
- `expand`：将`[tab]`按键转成空格键
  - `-t`：一个`[tab]`键可以用几个空格键代替
- `unexpand`：将空格键转成`[tab]`
- `split`：可以将一个大问价根据文件大小或是行数来划分
  - `-b`：后面可接欲划分成的文件大小，可接单位，比如`b`、`k`、`m`等
  - `l`：以行数划分
- `xargs <command>`：可以将管道输出变为某个命令的参数
  - `-0`：如果输入的`stdin`含有特殊字符，例如`\`，空格等字符，这个`-0`可将它还原为一般字符
  - `-e`：这个`EOF(end of file)`的意思，后面可以接一个字符，当`xargs`分析到这个字符时，就会停止工作
  - `-p`：执行每个命令时，会询问使用者
  - `-n`：后面接次数，每次`command`命令执行时，要使用几个参数
- `-`：某些命令需要用到文件名来处理时，该`stdin`和`stdout`可以利用`-`来替代

## 文件格式化处理
- `sed`：它也是一个管道命令，可以分析标准输入
- `awk`：它倾向于一行当中分成几个字符案处理
- `diff <from-file> <to-file>`：用于对比两个文件的差异，并且是以行为单位比较，`diff`通常使用在同一个文件或软件的新旧版本差异上
  - `-b`：忽略一行当中，仅有的多个空白的差异
  - `-B`：忽略空白行的差异
  - `-i`：忽略大小写的不同
- `cmp`：通过字节单位进行文件之间的对比

## shell 脚本
shell 的编写有以下注意事项
1. 命令是从上而下、从左而右地分析执行
2. 命令的执行中，命令、选项与参数的多个空格都会被忽略掉
3. 空白行也将被忽略掉，并且`[tab]`按键产生的空白同样为空格键
4. 如果读取到一个`Enter`符号`CR`，就尝试执行该行命令
5. 如果一行的内容太多，则可以使用`\[Enter]`来扩展至下一行
6. `#`可为注释
如何执行命令
- 直接命令执行，`.sh`文件必须具有`rx`的权限，然后
- 绝对路径
- 相对路径
- 变量`PATH`功能：将`.sh`文件放在`PATH`指定的目录内，比如`~/bin/`
### 简单范例
1. 交互式脚本：变量内容由用户决定
  ```shell
  read -p "Please input your first name: " firstname # 提示使用者输入
  read -p "Please input your last name: " lastname # 提示使用者输入
  echo -e "\nYour full name is: ${firstname} ${lastname}"# 提示使用者输入
  ```
2. 随日期变化：利用`date`建立文件，用于将每天的数据备份成不同的文件名
  ```shell
  echo -e "I will use 'touch' command to create 3 files." # 纯粹显示信息
  read -p "Please input your filename: " fileuser # 提示使用者输入
  # 为了避免使用者随意按 Enter，利用变量功能分析文件名
  filename=${fileuser:-"filename"} # 开始判断是否有配置文件名
  # 开始利用`date`命令来取得所需文件名
  date1=$(date --date='2 days ago' +%Y%m%d) # 前两天的日期
  file1=${filename}${date1}
  touch "${file1}"
  ```
3. 数值运算：简单的加减乘除
  利用`declare`将变量定义为整数时才能进行运算，shell 脚本只支持整数运算
### 脚本的执行方式差异
不同的脚本执行方式会造成不一样的结果，尤其对 bash 的环境影响大。脚本的执行除了前面的方式之外，还可以利用`source`或是小数点`.`执行
- 利用直接执行的方式执行脚本，当使用直接命令执行或是利用`bash`来执行脚本时，该脚本都会使用一个新的`bash`环境来执行脚本内的命令。使用这种执行方式时，其实脚本是在子进程的 bash 内执行的，也就是说当子进程完成后，在子进程内的各项变量或操作将会结束而不会传回到父进程中
- 利用`source`会在父进程中执行脚本
### 善用判断式
- `test`：可以用来检测系统上面某些文件或是相关的属性，有下面这些选项处理文件名
  - `-e`：是否存在
  - `-f`：是否存在且为文件
  - `-d`：是否存在且为目录
  - `-b`：是否存在且为一个`block device`设备
  - `-c`：是否存在且为一个`character device`设备
  - `-S`：是否存在且为一个`socket`文件
  - `-p`：是否存在且为一个`FIFO(pipe)`文件
  - `-L`：是否存在且为一个链接文件
  关于文件的全线检测，如`test -r filename`表示可读否
  - `-r`：是否存在且具有可读权限
  - `-w`：是否存在且具有可写权限
  - `-x`：是否存在且具有可执行权限
  - `-u`：是否存在且具有`SUID`的属性
  - `-g`：是否存在且具有`SGID`的属性
  - `-k`：是否存在且具有`Sticky bit`的属性
  - `-s`：是否存在且为非空文件
  两个文件之间的比较
  - `-nt`：判断`file1`是否比`file2`新
  - `-ot`：判断`file1`是否比`file2`旧
  - `-ef`：判断`file1`是否比`file2`为同一文件，可用在判断`hark link`的判定上，主要意义在判定两个文件是否指向同一个`inode`
  两个整数之间的比较
  - `-eq(equal)`：两数值相等
  - `-ne(not equal)`：两数值不等
  - `-gt(greater than)`：是否大于
  - `-lt(less than)`：是否小于
  - `-ge(greater than or equal)`：大于或等于
  - `-le(less than or equal)`：小于或等于
  判定字符串的数据
  - `test -z string`：判定字符串是否为`0`？如果`string`为空字符串，则为`true`
  - `test -n string`：判定字符串是否为`0`？如果`string`为空字符串，则为`false`，`-n`可省略
  - `test str1 == str2`：判定`str1`是否等于`str2`，若相等，返回`true`
  - `test str1 != str2`：判定`str1`是否等于`str2`，若相等，返回`false`
  多重条件判定，比如`test -r filename -a -x filename`
  - `-a`：两条件同时成立
  - `-o`：两条件任何一条成立
  - `!`：反相状态，比如`test ! -x file`
- 可以使用判断符号`[]`来进行数据的判断，和`test`使用的场景几乎一模一样，在`if`中比较常用。比如`[ "$HOME" == "$MAIL" ]`，使用它时，需要注意
  - 在中括号`[]`内的每个组件都需要空格来分隔
  - 在中括号内的变量，最好都以双引号括起来
  - 在中括号内的常数，最好都以单或双引号括起来
- 可以在脚本文件名后带有参数
  - `restart`：比如`/etc/init.d/network restart`可以重启网络程序
  - `stop`：可以终止程序
- 脚本针对参数已经设置了一些变量名称
```shell
/path/to/scriptname opt1 opt2 opt3 opt4
$0                  $1   $2   $3   $4
```
- 除了数字变量之外，还有一些比较特殊的变量可以在脚本内使用
  - `$#`：代表后接的参数个数，比如上例显示`4`
  - `$@`：代表`["$1" "$2" "$3" "$4"]`之意，每个变量都是独立的
  - `$*`：代表`[”$1c$2c$3c$4“]`其中`c`为分隔字符，默认为空格

### 条件判断式
- `if...then`：最常见的条件判断式，`elif`后需要有`then`，而`else`后不需要有`then`
- `netstat -tuln`：获取目前主机启动的服务
  - `Local Address`：此字段代表的是本机所启动的网络服务，IP 的部分说明的是该服务位于哪个接口上，若为`127.0.0.1`则是针对本机开放
  - 每个端口都有特定的网络服务
    - `80`：`www`
    - `22`：`ssh`
    - `21`：`ftp`
    - `25`：`mail`
    - `111`：`RPC`远程过程调用
    - `631`：`CUPS`打印服务功能
- `case...esac`：也就是`switch case`
- `function fname() {...}`：`function`的设置一定要在最前面
  - `${<数量>}`：表示输入的第几个参数

### 循环
- 不定循环
```shell
# condition 成立时进行循环
while [ condition ]
do
  # do something
done

# condition 成立时终止循环
until [ condition ]
do
  # do something
done
```
- 固定循环，比如循环`1 ~ 100`，可以是`for sitenu in $(seq 1 100)
```shell
for var in con1 con2 con3 ...
do
  # do something
done
```
还有一种数值处理的写法，比如`for ((i = 1; i <= ${nu}; i=i+1))`
```shell
for (( <初始值>; <限制值>; <赋值运算>; ))
do
  # do something
done
```

### 跟踪和调试
- `sh <脚本名>`
  - `-n`：不执行脚本，仅查询语法问题
  - `-v`：执行脚本前，先将脚本文件的内容打印到屏幕上
  - `-x`：将使用到的脚本内容显示到屏幕上，执行过程也会一起显示

## Linux 账号管理与 ACL 权限设置
管理员的工组中，相当重要的一环就是管理账号
### 账号和用户组
- 当我们登录Linux主机的时候，输入的是我们的账号，但其实`Linux`主机并不会直接认识你的账号名称，它仅认识`ID`，你的`ID`与账号的对应关系就在`/etc/passwd`中
当我们输入账号密码的时候，系统帮我们处理了以下内容
1. 先查找`/etc/passwd`里是否有输入的账号，没有就退出，有的话将该账号对应的`UID`和`GID(在/etc/group中)`读出来。另外，该账号的家目录和`shell`设置也一并读出
2. 核对密码表，进入`/etc/shadow`里找出对应的账号和`UID`，然后核对输入的密码与里面的密码是否相符
3. 一切OK就进入shell管理的阶段
- `/etc/shadow`：这个文件的构造是这样的，每个账号都代表一个账号，有几行就代表有几个账号在你的系统中。里面有很多账号本来就是系统正常运行所必须的，我们可以简称它为系统账号，比如`bin`、`daemon`、`adm`、`nobody`等，请不要随意删除
  使用`head -n 1 /etc/passwd`可以打印出第一行，为`root:$433wtbCCce:16559:0:99999:7:::`，这里的由`:`分隔的字段分别表示的是
  1. 账号名称：就是账号，需要用来对应`UID`，例如`root`对应的`UID`就是`0`
  2. 密码：这个字段内的数据才是真正的密码，而且是经过编码的密码。你只会看到一些特殊的字母。另外因为这个文件可能会被破解所以它的权限是`-rw--------`或是`----------`，即只有`root`可以读写
  3. 最近修改密码的日期，从`1970/1/1`开始计算
  4. 密码不可被修改的天数：和第三个字段相比，如果是`0`则表示密码可以随时被修改
  5. 密码需要重新修改的天数(与第三个字段相比)：指定最近一次修改之后，多少天之内必须重新设置密码
  6. 密码需要修改期限前的警告天数(与第五个字段相比)：当密码有效期限快要到的时候(第五字段)，系统会更具这个字段的设置，发出警告信息给这个账号
  7. 密码过期后的账号宽限时间(与第五个字段相比)：密码过期几天后，如果用户还是没有登录更改密码，那么这个账号的密码就会失效，该账号再也无法使用该密码登录
  8. 账号失效日期：1970/7/1 以来的总天数，该账号在此字段规定的日期之后，敬无法再被使用
  9. 保留：看以后是否还有新功能加入
- `authconfig --test | grep hashing`可以知道`shadow`是哪种加密机制
- `/etc/group`：这个文件就是在记录`GID`与组名的对应记录
  使用`head -n 1 /etc/group`可以打印出第一行，为`root:x:0:`，每一行代表一个用户组，以冒号`:`作为分隔符，这里的字段分别表示的是
  1. 组名，用来给人使用，基本上需要与第三字段的`GID`相对应
  2. 用户组密码，不需要设置，通常是给用户组管理员使用，。密码已经移动到`/etc/shadow`中，因此这个字段只会存在一个`x`而已
  3. `GID`，我们`/etc/passwd`第四个字段使用的`GID`对应的用户组名，就是这里对应比来的
  4. 此用户组支持的账号名称，如果某个账号想要加入此用户组，将该账号填入这个字段即可。比如可以使用`root:x:0:dmtsai,alex`
- 假如我同时假如多个用户组，那么我在作业的时候，到底是以哪个用户组为准呢？
  - 初始用户组`initial group`：就是在`/etc/passwd`里的第四栏所谓的`GID`。也就是用户一登录系统，就会拥有这个用户组的相关权限。而非初始用户组就需要在`/etc/group`的第四个字段中加入用户名。只要用户处于一个用户组，就能获得这个用户组的所有权限
  - 有效用户组`effective group`
    - `groups`：这个命令输出的第一个用户组即为有效用户组，当我们创建一个新文件时，用户组就是这个用户组
    - `newgrp`：可以切换有效用户组，但是想要切换的用户组必须是你已经有支持的用户组。它切换用户组时是以另外一个`shell`来提供这个功能，新的shell基于用户有效的GID，所以用户的用户组权限将会被重新计算
- `/etc/gshadow`：这个文件内同样还是使用冒号`:`来作为字段的分隔字符，而且这个文件几乎和`/etc/group`一模一样。不过它的第二个字段是密码栏，如果密码栏上面是`!`或为空时，表示改用户组不具有用户组管理员。所以这个`gshadow`的最大功能就是建立用户组管理员

### 账号管理
- `useradd`：可以使用这个命令新建账号，而密码使用`passwd`来新建
  - `-u`：后面接的是`UID`，直接指定一个特定的`UID`
  - `-g`：后面接的用户组就是上面提到的初始用户组，该用户组的`GID`会被放到`/etc/passwd`的第四个阑尾
  - `-G`：后面接的用户组就是该账号还可加入的用户组，这个选项与参数会修改`/etc/group`内的相关内容
  - `-M`：强制，不要建立使用者家目录。系统账号默认值
  - `-m`：强制，要建立使用者家目录。一般账号默认值
  - `-c`：为·`/etc/passwd`的第五栏的说明内容，可以随便我们设置
  - `-d`：指定某个目录成为家目录，而不要使用默认值，务必使用绝对路径
  - `-r`：建立一个系统的账号，这个账号的`UID`会有限制
  - `-s`：后面接一个 shell，若没有指定则默认是`/bin/bash`
  - `-e`：后面接一个日期，格式为`YYYY-MM-DD`，此选项可写入`shadow`第八栏位，亦即账号失效日的设置选项
  - `-f`：后面接`shadow`的第七栏位选项，指定密码是否会失效，`0`为立刻失效，`-1`为永不失效（密码只会过期而强制于登录时重新设置而已）
  其实系统已经帮我们规定好非常多的默认值了，所以我们可以简单地使用`useradd <账号>`来建立用户。在 CentOS 这些默认值主要会帮我们处理几个选项：
  - 在`/etc/passwd`里建立一行与账号相关的数据，包括建立`UID/GID/家目录`等；
  - 在`/etc/shadow`里将此账号的相关参数写入，但是尚未有密码
  - 在`/etc/group`里加入一个与账号名一模一样的组名
  - 在`/home`下面建立一个与账号同名的目录作为用户家目录，且权限为`700`
  由于在`/etc/shadow`里仅仅会有密码参数而不会有加密过的密码数据，所以我们在建立用户账号时，还需要使用`passwd <账号>`来设置密码才算是完成了用户建立的流程
  一般账号应该是`1000`号以后，用户自己建立的系统账号一般是小于`1000`号以下，所以加上`-r`后，系统会主动将账号与账号同名用户组的`UID/GID`都指定小于`1000`以下。由于系统账号主要是用来执行系统所需服务的权限设置，所以系统账号默认都不会主动建立家目录
  - `useradd`参考文件，其实`useradd`的默认值可以使用`useradd -D`查看。这些数据是由`/etc/default/useradd`调用出来的
  - `/etc/longin.defs`：用于查看`UID/GID`的密码参数
  - `/etc/skel`：用户家目录参考基准目录
- `passwd`：用于设置密码
  - `--stdin`：可以通过来自前一个管道的数据，作为密码输入，对 shell 脚本有帮助
  - `-l`：`Lock`的意思，会将`/etc/shadow`第二栏最前面加上`!`使之失效
  - `-u`：与`-l`相对，为·`unlock`的意思，即为解锁
  - `-S`：列出密码相关参数，即`shadow`文件内的大部分信息
  - `-n`：后面接天数，`shadow`的第四栏位，多久不可修改密码天数
  - `-x`：后面接天数，`shadow`的第五栏位，多久内必须要修改密码
  - `-n`：后面接天数，`shadow`的第六栏位，密码过期前的警告天数
  - `-n`：后面接日期，`shadow`的第七栏位，密码失效日期
  要帮一般账号建立密码需要使用`passwd <账号>`的格式，使用`passwd`表示修改自己的密码
- `chage`：用于详细的密码参数显示
  - `-l`：列出该账号的详细密码参数
  - `-d`：接日期，修改`shadow`第三栏位
  - `-E`：接日期，修改`shadow`第八栏位
  - `-I`：接天数，修改`shadow`第七栏位
  - `-m`：接天数，修改`shadow`第四栏位
  - `-M`：接天数，修改`shadow`第五栏位
  - `-W`：接天数，修改`shadow`第六栏位
- `usermod`：进行账号相关的微调
  - `-c`：接账号的说明，即`/etc/passwd`第五栏的说明栏
  - `-d`：接账号的家目录，即`/etc/passwd`第六栏
  - `-e`：接日期，即`/etc/shadow`第八个栏位
  - `-f`：接天数，即`shadow`的第七栏位
  - `-g`：接初始用户组，即`/etc/passwd`第四栏，亦即是`GID`的栏位
  - `-G`：接次要用户组，修改这个使用者能够支持的用户组，修改的是`/etc/group`
  - `-a`：与`-G`合用，可增加次要用户组的支持
  - `-l`：接账号名称，修改账号名称，即`/etc/passwd`第一栏
  - `-s`：接shell的实际文件，例如`/bin/bash`或`/bin/csh`等
  - `-u`：后面接`UID`数字，即`/etc/passwd`第三栏
  - `-L`：暂时将使用者的密码冻结，让它无法登录，其实仅改`/etc/shadow`的密码栏
  - `-U`：将`/etc/shadow`密码栏的感叹号`!`拿掉，解锁
- `userdel <username>`：用于删除用户的相关数据，可以将`/etc/shadow`里的第八字段即账号失效日期设置为`0`就可让账号无法使用，但数据会保留。而这个命令不会保存数据
  - `-r`：连同使用者的家目录一起删除
- `id <username>`：可查询到`UID/GID`等信息
- `finger`：可以查看很多用户的相关信息，大部分信息都是`/etc/passwd`这个文件里的信息。但是新的系统默认不安装这个软件
- `chsh`：就是`change shell`的缩写
  - `-l`：列出目前系统上可用的`shell`，其实就是`/etc/shell`的内容
  - `-s`：设置修改自己的 shell
- `groupadd <用户组名称>`：用于新增用户组
  - `-g`：后面接某个特定的`GID`，用来直接设置某个`GID`
  - `-r`：建立系统用户组，与`/etc/login.defs`内的`GID_MIN`有关
- `groupmod`：与`usermod`类似，仅是在进行`group`相关参数的修改而已
  - `-g`：修改既有的`GID`数字
  - `-r`：修改既有用户组名称
- `groupdel`：删除用户组
- `groupwd`：用户组管理员功能，就是让某个用户组具有一个管理员

### 用户身份切换
身份的切换一般包括以下原因
- 使用一般账号：系统日常操作的好习惯，这样可以避免操作错一些严重的命令
- 用较低权限启动系统服务：相对于系统安全，有的时候，我们必须要以某些系统账号来执行程序
- 软件本身的限制：一般使用一般账号登录系统，等到需要进行系统维护或软件更新时再转换身份
- 通过`su -`直接将身份变为`root`即可，但这个命令却需要`root`的密码
- 通过`sudo 命令`执行`root`的命令串，由于`sudo`需要事先设置妥当，且`sudo`需要输入用户自己的密码，因此多人共管一台主机时，`sudo`比`su`好
下面是`su`和`sudo`的用法
- `su`：它可以进行任何身份的切换。单纯使用这个命令切换成为`root`的省份，读取的变量设置方式为非登录 shell 的方式，这种方式很多原本的变量不会被修改
  - `- `：代表使用`login-shell`的变量文件读取方式来登录系统。若使用者的名称没有加上，则代表切换为`root`的身份
  - `-l`：与`-`类似，但后面需要加欲切换到使用者账号，也就是`login-shell`的方式
  - `-m`：`-m`与`-p`一样，表示使用目前的环境设置，而不读取新使用者的配置文件
  - `-c`：仅进行一次命令，所以`-c`后面可以加上命令
  总结下用法
  - 若要完整地切换到到新用户的环境，必须使用`su - username`或`su -l username`才会连同`PATH`、`USER`、`MAIL`等变量转换成新用户的环境
  - 如果仅想要执行一次`root`的命令，可以利用`su - -c <命令串>`的方式来处理
  - 使用`root`切换成为任何用户时，并不需要输入新用户的密码
- `sudo`：此命令可以让你以其他用户的身份执行命令，因此并非所有人都能执行`sudo`，而是仅有规范到`/etc/sudoers`内的用户才会执行`sudo`这个命令
  - `-b`：将后续的命令放到后台中让系统自动执行，而不与目前的 shell 产生影响
  - `-u`：后面可以接欲切换到使用者，若无此项则代表切换身份为`root`
  - `sudo`默认仅有`root`能使用，因为`sudo`的执行时这样的流程
  1. 当用户执行`sudo`时，系统于`/etc/sudoers`文件中查找该用户是否有执行`sudo`的权限
  2. 若用户具有可执行`sudo`的权限后，便让用户`输入用户自己的密码`来确认
  3. 若密码输入成功，便开始进行`sudo`后续阶段命令，`root`不用输入密码
  4. 若欲切换的身份与执行者身份相同，也不需要输入密码
- `visudo`：`/etc/sudoers`文件需要这个命令进行修改，如果文件设置错误会导致无法使用`sudo`命令的后果

### 用户的特殊 shell 和 PAM 模块
如果想让用户无法使用 bash 或其他 shell 来登录系统，我们可以考虑单独使用`/sbin/noligin`作为他们的`shell`，这样，当我的主机被尝试想要登录系统以获取 shell 环境时，可以拒绝该账号
如我们想要某个具有`/sbin/nologin`的用户知道，它们不能登陆主机，可以建立`/etc/nologin.txt`这个文件
- `PAM(Pluggable Authentication Modules，插入式验证模块)`可以说是一套应用程序编程接口，它提供了一连串的验证机制，只要用户将验证阶段的需求告知`PAM`后，`PAM`就能够返回用户验证的结果`成功或失败`
- 当你执行`passwd`后，这个程序调用`PAM`的流程是：
1. 用户开始执行`/usr/bin/passwd`这个程序，并输入密码
2. `passwd`调用`PAM`模块进行验证
3. `PAM`模块会到`/etc/pam.c/`找寻与程序`passwd`同名的配置文件
4. 根据`/etc/pam.d/passwd`内的设置，引用相关的`PAM`模块逐步进行验证分析
5. 将验证结果返回`passwd`这个程序
6. `passwd`这个程序会更具`PAM`返回的结果决定下一个操作

### 用户信息传递
- `w`和`who`可以查询目前已登录在系统上的用户
- `lastlog`：会获取`/var/log/lastlog`这个文件来知道每个账号最近登录的时间
- `write <使用者账号> <使用者所在终端页面>`：可以和其他用户讲话，但会中断使用者原本的任务
- `mesg n`：可以阻止接收消息，启用就是`mesg y`
每个主机上的用户都有一个`mailbox`，我们可以寄、收`mailbox`里的邮件，一般来说，`mailbox`都会放置在`/var/spool/mail`里
- `mail -s <邮件标题> username@localhost`：可以寄出邮件，可以使用数据流定向来设置 mail 内容`mail -s <邮件标题> username@localhost < <filename>`
  `mail`：可以接收邮件

## 进程管理与 SELinux
一个程序被加载到内存当中运行，那么内存中的那个数据就被称为进程`process`，进程是操作系统上非常重要的概念，所有系统上面运行的程序都会以进程的形式存在
### 什么是进程
触发任何一个事件时，系统都会将它定义成一个进程，并且基于这个进程一个`ID`，称为`PID`，同时根据触发这个进程的用户与相关属性关系，给予这个`PID`一组有效的权限设置
执行一个程序或命令可以触发一个事件而获取一个`PID`，当我们要让系统工作的时候，需要启动一个二进制文件，这个二进制文件就是程序
每个进程都有三组权限，没组都具有`rwx`的权限，所以`不同的用户身份执行这个程序时，系统给予的权限也不同`
当我们登录并执行`bash`时，系统已经给了我们一个`PID`，这个`PID`就是根据登陆者的`UID/GID(/etc/passwd)`而来，而这个进程执行其他作业时，由这个进程衍生出来的进程在一般状态下，也会沿用这个进程的相关权限
做个总结
- 程序`program`：通常为二进制程序，放置在存储媒介中，以物理文件的形式存在
- 进程`process`：程序被触发后，执行者的权限与属性、程序的代码与所需数据等都会被加载到内存中，操作系统回个这个内存中的单元一个标识符`PID`，可以说进程就是一个正在运行中的程序
- 子进程与父进程
  - 比如当我们登录系统后，会获取一个`bash`的`shell`，此时我们用这个`bash`提供的接口去执行另一个命令，那些另外执行的命令也会被触发成为`PID`，而这个`PID`就是子进程，通过`PPID(ParentPID)`来判断父进程
  - 子进程与父进程之间的关系还挺复杂，最大的复杂点在于进程之间的调用。`Linux`的程序调用通常被称为`fork-and-exec`的流程。进程都会借由父进程以复制的方式产生一个一模一样的子进程，然后被复制出来的进程再以`exec`的方式来执行实际要执行的进程，最终就成为一个子进程
- 很多进程会在常驻在内存中并一直持续不断地运行，比如系统或网络服务，这些常驻进程就会被我们称为服务
- linux 的多人多任务的特色
  - 多人环境，linux 上有多种不同的账号，每种账号都有特殊的权限
  - 多任务操作，linux 可以让 CPU 在各个任务间切换，也就是`CPU`频率
  - 多重登录环境中的七个基本终端界面，在 linux 中，默认提供了六个命令行登录界面，以及一个图形界面，可以使用`[ALT]+[F1]+...[F7]`来进行切换，而且每个终端界面的登录者可以不同
  - 特殊的进程管理操作。linux 可以仅将错误的进程踢掉，而不干酪其他进程的执行
  - bash 下的任务管理。我们可以在单一的 bash 界面下，同时执行多个任务
  - 多人多任务确实有很多好处，但其实也有管理上的难题，因为 CPU 的计算能力与内存可能会因为用户数量的增多而不够用了

### 任务管理`job control`
当我们登录系统获取 bash shell 之后，在单一终端下执行多个任务的操作管理。在执行任务管理的操作中，其实每个人物都是目前 bash 的子进程，彼此之间是有相关性的，我们无法用任务管理的方式由`tty1`的环境去管理`tty2`的 bash
假设我们只有一个终端，na因此可以出现提示字符让你操作的环境就成为前台，至于其他任务就可以放入后台去暂停或运行，而放入后台的任务不能用`[ctrl] + c`来终止的。总之会有以下限制
- 这些任务所触发的进程必须来自于你的`shell`的子进程
- 前台：可以控制与执行命令的这个环境称为前台的命令
- 后台：可以自动执行的任务，你无法使用`[ctrl]+c`来终止它，可以使用`bg`、`fg`调用该任务
- 后台中执行的进程不能当代`terinal`或 shell 的输入
实际执行`job`控制的命令有以下这些
- `&`：当在命令的结尾加上这个符号会进入后台执行，此时会输出一行`[1] 14432`其实对应的就是`[job number] PID`
- `[ctrl]+z`：将目前的任务丢到后台中**暂停**，此时会打印出`[<job number>]+<任务状态>
- `jobs`：可以查看目前的后台任务状态
  - `-l`：除了列出`job number`与命令串之外，同时列出`PID`的号码
  - `-r`：列出正在后台`run`的任务
  - `-s`：仅列出在后台中暂停`stop`的任务
  - `+`代表最近被放在后台的任务号码，`-`代表最近第二个被放置到后台中的任务号码
- `fg %<jobnumber>`：可将后台任务拿到前台处理，`%`是可有可无的，如果没有参数，则为`+`的任务
- `bg`：可以将一个任务在后台**运行** 
- `kill -<singnal> %<jobnumber>`：可以直接将任务删除，如果没有`%`，则会以`PID`处理
  - `-l`：列出目前`kill`能够使用的信号有哪些
  - `singnal`：代表基于后面接的任务什么样的只是
    - `-1`：重新读取一次参数的配置文件(类似`reload`)
    - `-2`：代表由键盘输入`[ctrl]+c`同样的操作
    - `-9`：立即强制删除一个任务，特别是删除不正常的任务
    - `-15`：以正常的进程方式终止一项任务，与`-9`不同
我们在任务管理当中提到的后台是指在终端模式下可以避免`[ctrl]+c`终端的一个清净，你可以说那个是 bash 的后台，而不是放到系统的后台中，所以，任务管理端后台依旧与终端有关。在任务尚未结束的情况下，你脱机了，则该任务不会继续执行
- `nohub [命令与参数]`：其中命令与参数是在终端前台中的任务
- `nohub [命令与参数] &`：其中命令与参数是在终端后台中的任务

### 进程管理
一个称职的系统管理员，必须要熟悉进程的管理流程才行
- `ps`：将某个时间点的进程情况打印出来
  - `ps aux`：查看系统所有进程
  - `ps -lA`：也能够查看系统所有进程
  - `-A`：所有进程都显示出来，与`-e`具有相同效果
  - `-a`：不显示与终端相关的所有进程
  - `-u`：有效使用者相关的进程
  - `-l`：仅查看自己的 bash 相关进程
  - `x`：通常和`a`这个参数一起使用，可以列出完整信息
  输出格式规划
  - `l`：较长、较详细的将该`PID`信息列出
  - `j`：任务的格式`jobs format`
  - `-f`：做一个更为完整的输出
  `ps -l`：可以仅列出与你操作系统有关的进程，即最上层的父进程会是你自己的 bash 而没有扩展到`systemd`这个进程中，`ps -l`显示的数据有下面这些
  - `F`：代表这个进程表示`process flag`，说明这个进程的权限
    - `4`：root
    - `1`：表示此子进程只是执行复制而没有实际执行
  - `S`：进程状态
    - `R(Running)`：正在运行
    - `S(Sleep)`：正在睡眠状态`idle`，但可以被唤醒`signal`
    - `D`：不可被唤醒的睡眠状态，通常这个进程可能在等待`I/O`的状态
    - `T`：停止状态`stop`，可能是在任务控制(后台暂停)或是跟踪`trace`状态
    - `Z(Zombie)`：僵尸状态，流程已经终止但却无法被删除至内存外
  - `UID/PID/PPID`：对应ID
  - `C`：CPU 使用率，单位为白分别
  - `PRI/NI`：`Priority/Nice`的缩写，代表该进程被 CPU 所执行的优先级，数值越小代表该进程越快被 CPU 执行
  - `ADDR/SZ/WCHAN`：都与内存有关，`ADDR`是`kernel function`，指出该进程在内存中的哪个部分，`SZ`表示该进程用掉多少内存，`WCHAN`表示目前进程是否运行
  - `TTY`：登陆者的终端位置，如为远程登录则使用动态终端接口名称`pts/n`
  - `TIME`：使用的 CPU 时间，此进程实际花费 CPU 运行时间，而不是系统时间
  - `CMD`：就是`command`的缩写，表示触发此进程的触发进程的命令是什么

## daemon
系统为了提供某些功能必须提供一些服务，这个服务就被称为`service`，而`service`的提供需要程序的运行，所以完成这个`service`的程序我们就称呼它为`daemon`
每一个程序的开发者，在开发它们的服务时，通常在服务的名称后会加上一个`d`，比如计划任务命令健力多`at`与`cron`这两个服务，它的程序就会被趣味`atd`和`crond`，这个`d`代表的就是`daemon`的意思
CentOS 7.x 之后，Red Hat 系列的发行版改用`systemd`这个启动服务管理机制，它有以下好处
- 并行处理所有服务，加速开机流程
- 一经要求就响应的`on-demand`启动方式
- 服务依赖性的自我检查，由于`systemd`可以自定义服务依赖性的检查，因此如果`B`服务是在`A`服务的上面启动的，那么手动启动`B`服务时，会自动启动`A`服务
- 依`daemon`功能分类，为了梳理清楚所有服务的功能，因此，首先`systemd`先定义所有的服务为一个服务单位`unit`，并将该`unit`归类到不同的服务类型`type`中。它将服务单位区分为`service`、`socket`、`target`、`path`、`snapshot`、`timer`等多种不同的类型
- 将多个`daemons`集合成一个群组
- 向下兼容旧有的`init`服务脚本
- `systemd`的配置文件放置目录
  - `/usr/lib/systemd/system/`：每个服务最主要的启动脚本，这些脚本的优先级比`/usr/lib/systemd/system`高
  - `/run/systemd/system/`：系统执行过程中所产生的的服务脚本，这些脚本的优先级比`/usr/lib/systemd/system/`高
  - `/etc/systemd/system/`：管理员根据主机系统的需求所建立的执行脚本，执行优先级又比`/usr/lib/systemd/system/`高
  到底操作系统启动会不会执行某些服务其实是看`/etc/systemd/system/`下面的设置，所以该目录下面是一大堆链接文件。而实际执行的`systemd`启动脚本配置文件其实都是放置在`/usr/lib/systemd/system/`下面，所以修改某个服务启动的设置，应该在`/usr/lib/systemd/system/`下
`/usr/lib/systemd/system/`以下的数据是通过扩展名来区分不同的类型`type`

### systemctl
基本上`systemd`这个启动服务的机制，主要是通过一个名为`systemctl`的命令来完成
一般来说服务的启动有两个阶段，一是开机的时候设置要不要启动这个服务，二是你现在要不要启动这个服务
- `systemctl <command> <unit>`：其中`command`主要有
  - `start`：立刻启动后面接的`unit`
  - `stop`：立刻关闭后面接的`unit`
  - `restart`：立刻重新启动后面接的`unit`
  - `reload`：不关闭后面接的`unit`的情况下，重新加载配置文件，让设置生效
  - `enable`：设置下次开机时，后面接的`unit`会被启动
  - `disable`：设置下次开机时，后面接的`unit`不会被启动
  - `status`：后面接的这个`unit`的状态会列出有没有正在执行，开机默认执行与否，登录等信息等
  - `is-active`：当前是否正在运行
  - `is-enable`：开机时有没有默认要启动这个`unit`
- `systemctl <command> <--type==TYPE> <--all>`：用于查看系统上所有的服务
  - `command`
    - `list-units`：依据`unit`显示目前有启动的`unit`，若加上`--all`才会列出没启动的
    - `list-units-files`：依据`/usr/lib/systemd/system/`的文件，将所有文件列表说明
  - `--type==TYPE`：也就是之前提到的`unit`类型
- `systemctl list-dependencies <unit> <--reverse>`：追踪一个`unit`的依赖性
